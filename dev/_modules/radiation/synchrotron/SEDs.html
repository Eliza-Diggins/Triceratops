
<!DOCTYPE html>


<html lang="en" data-content_root="../../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>radiation.synchrotron.SEDs &#8212; Triceratops  documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=4ae1632d" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css?v=d2d258e8" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-binder.css?v=f4aeca0c" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-dataframe.css?v=2082cf3c" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-rendered-html.css?v=1277b6f3" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- So that users can add custom icons -->
  <script src="../../../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../../_static/doctools.js?v=fd6eb6e6"></script>
    <script src="../../../_static/sphinx_highlight.js?v=6ffebe34"></script>
    <script src="../../../_static/design-tabs.js?v=f930bc37"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/radiation/synchrotron/SEDs';</script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../../../index.html">
  
  
  
  
  
  
    <p class="title logo__title">Triceratops  documentation</p>
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../api.html">
    API
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../reference/user_guide.html">
    Triceratops User Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../auto_examples/index.html">
    Triceratops Example Gallery
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../getting_started.html">
    Quickstart Guide
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../api.html">
    API
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../reference/user_guide.html">
    Triceratops User Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../auto_examples/index.html">
    Triceratops Example Gallery
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../getting_started.html">
    Quickstart Guide
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../../index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">radiation.synchrotron.SEDs</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for radiation.synchrotron.SEDs</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Synchrotron Spectral Energy Distributions (SEDs).</span>

<span class="sd">This module implements a comprehensive library of **phenomenological synchrotron</span>
<span class="sd">spectral energy distributions (SEDs)** for power-law electron populations, following</span>
<span class="sd">the standard theoretical framework developed in the literature (e.g. :footcite:t:`GranotSari2002SpectralBreaks`)</span>

<span class="sd">The core design philosophy is to construct SEDs via **log-space SED surgery**:</span>
<span class="sd">complex spectra are assembled by multiplying (adding in log-space) a sequence of</span>
<span class="sd">*scale-free, smoothed broken power-law* factors. Each factor introduces a controlled</span>
<span class="sd">change in spectral slope at a characteristic frequency without altering the overall</span>
<span class="sd">normalization. This approach ensures:</span>

<span class="sd">- numerical stability over many decades in frequency,</span>
<span class="sd">- clean separation of spectral segments,</span>
<span class="sd">- correct asymptotic slopes,</span>
<span class="sd">- and composability of multiple spectral breaks.</span>

<span class="sd">The module supports:</span>

<span class="sd">- non-cooling, slow-cooling, and fast-cooling synchrotron regimes,</span>
<span class="sd">- synchrotron self-absorption (SSA), including stratified SSA cases,</span>
<span class="sd">- hidden or absorbed cooling breaks,</span>
<span class="sd">- smooth or sharp spectral transitions,</span>
<span class="sd">- automatic regime determination from physical parameters,</span>
<span class="sd">- and analytic closure relations linking phenomenological SED parameters to</span>
<span class="sd">  physical quantities (e.g. magnetic field strength, radius).</span>

<span class="sd">.. note::</span>

<span class="sd">    A complete theoretical discussion of SED construction, including derivations</span>
<span class="sd">    and physical interpretations, is provided in the :ref:`synch_sed_theory`. A</span>
<span class="sd">    user-guide description of this module can be found in :ref:`synchrotron_seds`, including</span>
<span class="sd">    usage examples.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Callable</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">enum</span><span class="w"> </span><span class="kn">import</span> <span class="n">Enum</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">TYPE_CHECKING</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">astropy</span><span class="w"> </span><span class="kn">import</span> <span class="n">units</span> <span class="k">as</span> <span class="n">u</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">triceratops.radiation.constants</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">electron_rest_energy_cgs</span><span class="p">,</span>
    <span class="n">electron_rest_mass_cgs</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">triceratops.utils.log</span><span class="w"> </span><span class="kn">import</span> <span class="n">triceratops_logger</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">triceratops.utils.misc_utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">ensure_in_units</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.core</span><span class="w"> </span><span class="kn">import</span> <span class="n">_opt_compute_log_synch_frequency</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.microphysics</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">_opt_normalize_BPL_from_magnetic_field</span><span class="p">,</span>
    <span class="n">_opt_normalize_PL_from_magnetic_field</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.utils</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">_log_chi_cgs</span><span class="p">,</span>
    <span class="n">_log_chi_cgs_iso</span><span class="p">,</span>
    <span class="n">c_1_cgs</span><span class="p">,</span>
    <span class="n">compute_c5_parameter</span><span class="p">,</span>
    <span class="n">compute_c6_parameter</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># Type checking imports</span>
<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">triceratops._typing</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
        <span class="n">_ArrayLike</span><span class="p">,</span>
        <span class="n">_UnitBearingArrayLike</span><span class="p">,</span>
        <span class="n">_UnitBearingScalarLike</span><span class="p">,</span>
    <span class="p">)</span>


<span class="c1"># ============================================================= #</span>
<span class="c1"># SED Functions                                                 #</span>
<span class="c1"># ============================================================= #</span>
<span class="c1"># This is where we implement all of the low-level SED functions that</span>
<span class="c1"># can be used to draw the correct SED. These functions should all be</span>
<span class="c1"># implemented in log-space for numerical stability.</span>
<span class="c1">#</span>
<span class="c1"># These can be used directly, but are typically wrapped in the corresponding</span>
<span class="c1"># SED class. PLEASE DOCUMENT ALL OF THESE FUNCTIONS THOROUGHLY. The corresponding</span>
<span class="c1"># theory is complex.</span>
<div class="viewcode-block" id="log_smoothed_SFBPL">
<a class="viewcode-back" href="../../../_as_gen/radiation.synchrotron.SEDs.log_smoothed_SFBPL.html#radiation.synchrotron.SEDs.log_smoothed_SFBPL">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">log_smoothed_SFBPL</span><span class="p">(</span>
    <span class="n">log_x</span><span class="p">:</span> <span class="s2">&quot;_ArrayLike&quot;</span><span class="p">,</span>
    <span class="n">a1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">a2</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">smoothing</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Logarithm of a scale-free smoothed broken power law (SFBPL).</span>

<span class="sd">    This function returns the **logarithm** of a *scale-free*, multiplicative</span>
<span class="sd">    spectral break factor commonly used for constructing piecewise spectra via</span>
<span class="sd">    **log-space SED surgery** (i.e. multiplication in linear space, addition in</span>
<span class="sd">    log space).</span>

<span class="sd">    The factor is</span>

<span class="sd">    .. math::</span>

<span class="sd">        \tilde f(x)</span>
<span class="sd">        =</span>
<span class="sd">        \left[</span>
<span class="sd">            1 + x^{(a_2 - a_1)/s}</span>
<span class="sd">        \right]^s,</span>

<span class="sd">    where :math:`x` is a dimensionless ratio (e.g. :math:`x=\nu/\nu_{\rm brk}`),</span>
<span class="sd">    :math:`a_1` and :math:`a_2` are the asymptotic power-law indices on opposite</span>
<span class="sd">    sides of the break, and :math:`s` controls the smoothness.</span>

<span class="sd">    The returned quantity is</span>

<span class="sd">    .. math::</span>

<span class="sd">        \log \tilde f(x)</span>
<span class="sd">        =</span>
<span class="sd">        s \log\!\left(1 + x^{(a_2 - a_1)/s}\right).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    log_x : array-like</span>
<span class="sd">        Logarithm of the dimensionless ratio :math:`x`, typically</span>
<span class="sd">        :math:`\log(\nu/\nu_{\rm brk})`.</span>
<span class="sd">    a1 : float</span>
<span class="sd">        Reference spectral slope used in the definition of the break.</span>
<span class="sd">        In typical usage, this is the **baseline slope** you already have on one</span>
<span class="sd">        side of the break.</span>
<span class="sd">    a2 : float</span>
<span class="sd">        Target spectral slope after applying the break on the other side.</span>
<span class="sd">        The slope change across the break is :math:`\Delta a = a_2 - a_1`.</span>
<span class="sd">    smoothing : float</span>
<span class="sd">        Smoothness parameter :math:`s`. The magnitude :math:`|s|` sets the</span>
<span class="sd">        sharpness of the transition: smaller :math:`|s|` gives a sharper break.</span>
<span class="sd">        The **sign** of :math:`s` controls *which* side of the break receives the</span>
<span class="sd">        slope change (i.e. whether the modification acts primarily at</span>
<span class="sd">        :math:`x \ll 1` or :math:`x \gg 1`).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array-like</span>
<span class="sd">        :math:`\log \tilde f(x)` evaluated at ``log_x``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - **Scale-free:** :math:`\tilde f(1)=2^s` and no additional scale parameters</span>
<span class="sd">      are introduced besides the implicit break location in :math:`x`.</span>
<span class="sd">    - Intended to be **added** to an existing log-spectrum:</span>
<span class="sd">      if :math:`\log F(\nu)` is your baseline, then</span>
<span class="sd">      :math:`\log F&#39;(\nu) = \log F(\nu) + \log \tilde f(\nu/\nu_{\rm brk})`.</span>
<span class="sd">    - Multiple factors may be composed, but you should ensure each break is</span>
<span class="sd">      applied with the correct baseline slopes and does not unintentionally</span>
<span class="sd">      re-modify the same frequency range.</span>

<span class="sd">    .. rubric:: Asymptotic behavior and slope surgery</span>

<span class="sd">    Let :math:`k=(a_2-a_1)/s`. Then:</span>

<span class="sd">    - If :math:`k&gt;0` (the common case for &quot;low side → a1, high side → a2&quot;):</span>

<span class="sd">      - For :math:`x \ll 1`: :math:`\tilde f(x) \to 1`</span>
<span class="sd">      - For :math:`x \gg 1`: :math:`\tilde f(x) \propto x^{\,a_2-a_1}`</span>

<span class="sd">      Adding :math:`\log\tilde f` to a baseline power law with slope :math:`a_1`</span>
<span class="sd">      produces slope :math:`a_1` below the break and slope :math:`a_2` above it.</span>

<span class="sd">    - If :math:`k&lt;0`, the roles of :math:`x\ll 1` and :math:`x\gg 1` swap:</span>
<span class="sd">      the slope modification acts on the **low-**:math:`x` side instead of the</span>
<span class="sd">      high-:math:`x` side.</span>

<span class="sd">    In all cases, the multiplicative factor produces a net slope change of</span>
<span class="sd">    :math:`\Delta a = a_2-a_1` across the transition.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">smoothing</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">logaddexp</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">((</span><span class="n">a2</span> <span class="o">-</span> <span class="n">a1</span><span class="p">)</span> <span class="o">/</span> <span class="n">smoothing</span><span class="p">)</span> <span class="o">*</span> <span class="n">log_x</span><span class="p">)</span></div>



<div class="viewcode-block" id="log_exp_cutoff_sed">
<a class="viewcode-back" href="../../../_as_gen/radiation.synchrotron.SEDs.log_exp_cutoff_sed.html#radiation.synchrotron.SEDs.log_exp_cutoff_sed">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">log_exp_cutoff_sed</span><span class="p">(</span>
    <span class="n">log_x</span><span class="p">:</span> <span class="s2">&quot;_ArrayLike&quot;</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Logarithm of a smooth high-frequency exponential cutoff.</span>

<span class="sd">    This function implements a *scale-free*, phenomenological cutoff factor</span>

<span class="sd">    .. math::</span>

<span class="sd">        \Phi(x)</span>
<span class="sd">        =</span>
<span class="sd">        x^{1/2}\,\exp(1 - x),</span>

<span class="sd">    where :math:`x \equiv \nu / \nu_{\max}`. The logarithm of this factor is</span>

<span class="sd">    .. math::</span>

<span class="sd">        \log \Phi(x)</span>
<span class="sd">        =</span>
<span class="sd">        \frac{1}{2}\log x + (1 - x).</span>

<span class="sd">    The cutoff is normalized such that :math:`\Phi(1) = 1`, allowing it to be</span>
<span class="sd">    applied multiplicatively to an existing SED without altering its</span>
<span class="sd">    normalization below the cutoff frequency.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    log_x : array-like</span>
<span class="sd">        Logarithm of the dimensionless frequency ratio</span>
<span class="sd">        :math:`\log(\nu / \nu_{\max})`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array-like</span>
<span class="sd">        Logarithm of the exponential cutoff factor.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - For :math:`\nu \ll \nu_{\max}`, the cutoff approaches unity.</span>
<span class="sd">    - For :math:`\nu &gt; \nu_{\max}`, the spectrum is exponentially suppressed.</span>
<span class="sd">    - The conditional expression ensures that the cutoff contributes only</span>
<span class="sd">      above :math:`\nu_{\max}`, preserving exact scale-freeness below the</span>
<span class="sd">      cutoff.</span>
<span class="sd">    - Implemented entirely in log-space for numerical stability.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">log_x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">log_x</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_x</span><span class="p">)),</span> <span class="mf">0.0</span><span class="p">)</span></div>



<div class="viewcode-block" id="smoothed_BPL">
<a class="viewcode-back" href="../../../_as_gen/radiation.synchrotron.SEDs.smoothed_BPL.html#radiation.synchrotron.SEDs.smoothed_BPL">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">smoothed_BPL</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">F_nu</span><span class="p">,</span> <span class="n">nu_brk</span><span class="p">,</span> <span class="n">alpha_1</span><span class="p">,</span> <span class="n">alpha_2</span><span class="p">,</span> <span class="n">smoothing</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Smoothed broken power-law (BPL) SED.</span>

<span class="sd">    This function constructs a smoothed broken power-law SED by combining</span>
<span class="sd">    two power-law segments with a smooth transition at a specified break</span>
<span class="sd">    frequency.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nu : array-like</span>
<span class="sd">        Frequencies at which to evaluate the SED.</span>
<span class="sd">    F_nu : float</span>
<span class="sd">        Normalization of the SED at the break frequency.</span>
<span class="sd">    nu_brk : float</span>
<span class="sd">        Break frequency where the spectral slope changes.</span>
<span class="sd">    alpha_1 : float</span>
<span class="sd">        Spectral slope for frequencies below the break.</span>
<span class="sd">    alpha_2 : float</span>
<span class="sd">        Spectral slope for frequencies above the break.</span>
<span class="sd">    smoothing : float</span>
<span class="sd">        Smoothness parameter controlling the width of the transition.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array-like</span>
<span class="sd">        The smoothed broken power-law SED evaluated at ``nu``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The SED is normalized such that :math:`F_\nu(\nu_{\rm brk}) = F_{\nu}`.</span>
<span class="sd">    - The smoothness parameter controls how gradual the transition is between</span>
<span class="sd">      the two power-law segments.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">F_nu</span> <span class="o">*</span> <span class="p">((</span><span class="n">nu</span> <span class="o">/</span> <span class="n">nu_brk</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">alpha_1</span> <span class="o">/</span> <span class="n">smoothing</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">nu</span> <span class="o">/</span> <span class="n">nu_brk</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">alpha_2</span> <span class="o">/</span> <span class="n">smoothing</span><span class="p">))</span> <span class="o">**</span> <span class="n">smoothing</span></div>



<span class="c1"># --- Power-Law No-Cooling No-SSA SEDs --- #</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_log_powerlaw_sbpl_sed</span><span class="p">(</span>
    <span class="n">log_nu</span><span class="p">:</span> <span class="s2">&quot;_ArrayLike&quot;</span><span class="p">,</span>
    <span class="n">log_nu_m</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">log_nu_max</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">p</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">s</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Logarithm of the synchrotron SED for a non-cooling power-law electron population.</span>

<span class="sd">    This function implements the **non-cooling**, optically thin synchrotron</span>
<span class="sd">    spectrum for a power-law electron distribution, with no synchrotron</span>
<span class="sd">    self-absorption (SSA) and including a high-frequency exponential cutoff.</span>

<span class="sd">    The optically thin spectral slopes are:</span>

<span class="sd">    - :math:`F_\nu \propto \nu^{1/3}` for :math:`\nu &lt; \nu_m`,</span>
<span class="sd">    - :math:`F_\nu \propto \nu^{-(p-1)/2}` for :math:`\nu &gt; \nu_m`.</span>

<span class="sd">    The spectrum is constructed using *scale-free smoothed broken power laws*</span>
<span class="sd">    (SFBPLs) via log-space SED surgery and is **normalized at the injection</span>
<span class="sd">    frequency** :math:`\nu_m`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    log_nu : array-like</span>
<span class="sd">        Logarithm of the frequencies at which to evaluate the SED.</span>
<span class="sd">    log_nu_m : float</span>
<span class="sd">        Logarithm of the injection (minimum electron) frequency :math:`\nu_m`.</span>
<span class="sd">    log_nu_max : float</span>
<span class="sd">        Logarithm of the maximum synchrotron frequency :math:`\nu_{\max}`.</span>
<span class="sd">    p : float</span>
<span class="sd">        Power-law index of the electron energy distribution.</span>
<span class="sd">    s : float</span>
<span class="sd">        Smoothness parameter for the SFBPL transition. The magnitude controls</span>
<span class="sd">        the sharpness of the break, while the sign controls the direction of</span>
<span class="sd">        the slope change.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array-like</span>
<span class="sd">        Logarithm of the synchrotron SED evaluated at ``log_nu``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - No synchrotron self-absorption (SSA) is included.</span>
<span class="sd">    - The high-frequency exponential cutoff is applied multiplicatively.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x_m</span> <span class="o">=</span> <span class="n">log_nu</span> <span class="o">-</span> <span class="n">log_nu_m</span>
    <span class="n">x_max</span> <span class="o">=</span> <span class="n">log_nu</span> <span class="o">-</span> <span class="n">log_nu_max</span>

    <span class="c1"># Normalize at the injection frequency ν_m</span>
    <span class="n">log_sed</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">x_m</span>

    <span class="c1"># Injection break</span>
    <span class="n">log_sed</span> <span class="o">+=</span> <span class="n">log_smoothed_SFBPL</span><span class="p">(</span><span class="n">x_m</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

    <span class="c1"># High-frequency cutoff</span>
    <span class="n">log_sed</span> <span class="o">+=</span> <span class="n">log_exp_cutoff_sed</span><span class="p">(</span><span class="n">x_max</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">log_sed</span>


<span class="c1"># --- Power-Law Cooling SEDs --- #</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_log_powerlaw_sbpl_sed_cool_1</span><span class="p">(</span>
    <span class="n">log_nu</span><span class="p">:</span> <span class="s2">&quot;_ArrayLike&quot;</span><span class="p">,</span>
    <span class="n">log_nu_m</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">log_nu_c</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">log_nu_max</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">p</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">s</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Logarithm of the synchrotron SED in the **fast-cooling** regime.</span>

<span class="sd">    This function implements the fast-cooling synchrotron spectrum for a</span>
<span class="sd">    power-law electron distribution, assuming the frequency ordering</span>

<span class="sd">    .. math::</span>

<span class="sd">        \nu_c &lt; \nu_m.</span>

<span class="sd">    The optically thin spectral slopes are:</span>

<span class="sd">    - :math:`F_\nu \propto \nu^{1/3}` for :math:`\nu &lt; \nu_c`,</span>
<span class="sd">    - :math:`F_\nu \propto \nu^{-1/2}` for :math:`\nu_c &lt; \nu &lt; \nu_m`,</span>
<span class="sd">    - :math:`F_\nu \propto \nu^{-p/2}` for :math:`\nu &gt; \nu_m`.</span>

<span class="sd">    The spectrum is constructed via log-space SED surgery using SFBPL kernels</span>
<span class="sd">    and is **normalized at the cooling frequency** :math:`\nu_c`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    log_nu : array-like</span>
<span class="sd">        Logarithm of the frequencies at which to evaluate the SED.</span>
<span class="sd">    log_nu_m : float</span>
<span class="sd">        Logarithm of the injection frequency :math:`\nu_m`.</span>
<span class="sd">    log_nu_c : float</span>
<span class="sd">        Logarithm of the cooling frequency :math:`\nu_c`.</span>
<span class="sd">    log_nu_max : float</span>
<span class="sd">        Logarithm of the maximum synchrotron frequency :math:`\nu_{\max}`.</span>
<span class="sd">    p : float</span>
<span class="sd">        Power-law index of the electron energy distribution.</span>
<span class="sd">    s : float</span>
<span class="sd">        Smoothness parameter for the SFBPL transitions.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array-like</span>
<span class="sd">        Logarithm of the synchrotron SED evaluated at ``log_nu``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Assumes :math:`\nu_c &lt; \nu_m`; no internal validation is performed.</span>
<span class="sd">    - No synchrotron self-absorption (SSA) is included.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x_c</span> <span class="o">=</span> <span class="n">log_nu</span> <span class="o">-</span> <span class="n">log_nu_c</span>
    <span class="n">x_m</span> <span class="o">=</span> <span class="n">log_nu</span> <span class="o">-</span> <span class="n">log_nu_m</span>
    <span class="n">x_max</span> <span class="o">=</span> <span class="n">log_nu</span> <span class="o">-</span> <span class="n">log_nu_max</span>

    <span class="c1"># Normalize at the cooling frequency ν_c</span>
    <span class="n">log_sed</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">x_c</span>

    <span class="c1"># Cooling break</span>
    <span class="n">log_sed</span> <span class="o">+=</span> <span class="n">log_smoothed_SFBPL</span><span class="p">(</span><span class="n">x_c</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

    <span class="c1"># Injection break</span>
    <span class="n">log_sed</span> <span class="o">+=</span> <span class="n">log_smoothed_SFBPL</span><span class="p">(</span><span class="n">x_m</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="o">-</span><span class="n">p</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

    <span class="c1"># High-frequency cutoff</span>
    <span class="n">log_sed</span> <span class="o">+=</span> <span class="n">log_exp_cutoff_sed</span><span class="p">(</span><span class="n">x_max</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">log_sed</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_log_powerlaw_sbpl_sed_cool_2</span><span class="p">(</span>
    <span class="n">log_nu</span><span class="p">:</span> <span class="s2">&quot;_ArrayLike&quot;</span><span class="p">,</span>
    <span class="n">log_nu_m</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">log_nu_c</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">log_nu_max</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">p</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">s</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Logarithm of the synchrotron SED in the **slow-cooling** regime.</span>

<span class="sd">    This function implements the slow-cooling synchrotron spectrum for a</span>
<span class="sd">    power-law electron distribution, assuming the frequency ordering</span>

<span class="sd">    .. math::</span>

<span class="sd">        \nu_m &lt; \nu_c.</span>

<span class="sd">    The optically thin spectral slopes are:</span>

<span class="sd">    - :math:`F_\nu \propto \nu^{1/3}` for :math:`\nu &lt; \nu_m`,</span>
<span class="sd">    - :math:`F_\nu \propto \nu^{-(p-1)/2}` for</span>
<span class="sd">      :math:`\nu_m &lt; \nu &lt; \nu_c`,</span>
<span class="sd">    - :math:`F_\nu \propto \nu^{-p/2}` for :math:`\nu &gt; \nu_c`.</span>

<span class="sd">    The spectrum is constructed via log-space SED surgery using SFBPL kernels</span>
<span class="sd">    and is **normalized at the injection frequency** :math:`\nu_m`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    log_nu : array-like</span>
<span class="sd">        Logarithm of the frequencies at which to evaluate the SED.</span>
<span class="sd">    log_nu_m : float</span>
<span class="sd">        Logarithm of the injection frequency :math:`\nu_m`.</span>
<span class="sd">    log_nu_c : float</span>
<span class="sd">        Logarithm of the cooling frequency :math:`\nu_c`.</span>
<span class="sd">    log_nu_max : float</span>
<span class="sd">        Logarithm of the maximum synchrotron frequency :math:`\nu_{\max}`.</span>
<span class="sd">    p : float</span>
<span class="sd">        Power-law index of the electron energy distribution.</span>
<span class="sd">    s : float</span>
<span class="sd">        Smoothness parameter for the SFBPL transitions.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array-like</span>
<span class="sd">        Logarithm of the synchrotron SED evaluated at ``log_nu``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Assumes :math:`\nu_m &lt; \nu_c`; no internal validation is performed.</span>
<span class="sd">    - No synchrotron self-absorption (SSA) is included.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x_m</span> <span class="o">=</span> <span class="n">log_nu</span> <span class="o">-</span> <span class="n">log_nu_m</span>
    <span class="n">x_c</span> <span class="o">=</span> <span class="n">log_nu</span> <span class="o">-</span> <span class="n">log_nu_c</span>
    <span class="n">x_max</span> <span class="o">=</span> <span class="n">log_nu</span> <span class="o">-</span> <span class="n">log_nu_max</span>

    <span class="c1"># Normalize at the injection frequency ν_m</span>
    <span class="n">log_sed</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">x_m</span>

    <span class="c1"># Injection break</span>
    <span class="n">log_sed</span> <span class="o">+=</span> <span class="n">log_smoothed_SFBPL</span><span class="p">(</span><span class="n">x_m</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

    <span class="c1"># Cooling break</span>
    <span class="n">log_sed</span> <span class="o">+=</span> <span class="n">log_smoothed_SFBPL</span><span class="p">(</span><span class="n">x_c</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="o">-</span><span class="n">p</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

    <span class="c1"># High-frequency cutoff</span>
    <span class="n">log_sed</span> <span class="o">+=</span> <span class="n">log_exp_cutoff_sed</span><span class="p">(</span><span class="n">x_max</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">log_sed</span>


<span class="k">class</span><span class="w"> </span><span class="nc">_SynchrotronCoolingSEDFunctions</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="n">SPECTRUM_1</span> <span class="o">=</span> <span class="n">_log_powerlaw_sbpl_sed_cool_1</span>  <span class="c1"># fast-cooling</span>
    <span class="n">SPECTRUM_2</span> <span class="o">=</span> <span class="n">_log_powerlaw_sbpl_sed_cool_2</span>  <span class="c1"># slow-cooling</span>
    <span class="n">SPECTRUM_3</span> <span class="o">=</span> <span class="n">_log_powerlaw_sbpl_sed</span>  <span class="c1"># non-cooling</span>


<span class="c1"># --- Power-Law SSA SEDs --- #</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_log_powerlaw_sbpl_sed_ssa_1</span><span class="p">(</span>
    <span class="n">log_nu</span><span class="p">:</span> <span class="s2">&quot;_ArrayLike&quot;</span><span class="p">,</span>
    <span class="n">log_nu_m</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">log_nu_a</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">log_nu_max</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">p</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">s</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Logarithm of the synchrotron SED with SSA, assuming the ordering :math:`\nu &lt; \nu_a &lt; \nu_m`.</span>

<span class="sd">    The resulting spectral segments are:</span>

<span class="sd">    - :math:`F_\nu \propto \nu^2` for :math:`\nu &lt; \nu_a`,</span>
<span class="sd">    - :math:`F_\nu \propto \nu^{1/3}` for :math:`\nu_a &lt; \nu &lt; \nu_m`,</span>
<span class="sd">    - :math:`F_\nu \propto \nu^{-(p-1)/2}` for :math:`\nu &gt; \nu_m`.</span>

<span class="sd">    In this configuration, the SSA break lies below the injection frequency.</span>
<span class="sd">    The spectrum is therefore **normalized at the injection break**</span>
<span class="sd">    :math:`\nu_m`, where the optically thin synchrotron slope is well defined.</span>
<span class="sd">    The SSA turnover is introduced at lower frequencies using a scale-free</span>
<span class="sd">    smoothed broken power-law (SFBPL) factor.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    log_nu : array-like</span>
<span class="sd">        Logarithm of the frequencies at which to evaluate the SED.</span>
<span class="sd">    log_nu_m : float</span>
<span class="sd">        Logarithm of the injection (minimum electron) frequency</span>
<span class="sd">        :math:`\nu_m`.</span>
<span class="sd">    log_nu_a : float</span>
<span class="sd">        Logarithm of the synchrotron self-absorption frequency</span>
<span class="sd">        :math:`\nu_a`.</span>
<span class="sd">    log_nu_max : float</span>
<span class="sd">        Logarithm of the maximum synchrotron frequency</span>
<span class="sd">        :math:`\nu_{\max}`.</span>
<span class="sd">    p : float</span>
<span class="sd">        Power-law index of the electron energy distribution.</span>
<span class="sd">    s : float</span>
<span class="sd">        Smoothness parameter for the SFBPL transitions.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array-like</span>
<span class="sd">        Logarithm of the synchrotron SED evaluated at ``log_nu``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Assumes :math:`\nu &lt; \nu_a &lt; \nu_m`; no internal validation is performed.</span>
<span class="sd">    - The spectrum is constructed via log-space SED surgery using scale-free</span>
<span class="sd">      SFBPL kernels.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x_a</span> <span class="o">=</span> <span class="n">log_nu</span> <span class="o">-</span> <span class="n">log_nu_a</span>
    <span class="n">x_m</span> <span class="o">=</span> <span class="n">log_nu</span> <span class="o">-</span> <span class="n">log_nu_m</span>
    <span class="n">x_max</span> <span class="o">=</span> <span class="n">log_nu</span> <span class="o">-</span> <span class="n">log_nu_max</span>

    <span class="c1"># Normalize at the injection frequency ν_m</span>
    <span class="n">log_sed</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">x_a</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">log_nu_a</span> <span class="o">-</span> <span class="n">log_nu_m</span><span class="p">)</span>

    <span class="c1"># SSA break (optically thick → optically thin)</span>
    <span class="n">log_sed</span> <span class="o">+=</span> <span class="n">log_smoothed_SFBPL</span><span class="p">(</span><span class="n">x_a</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

    <span class="c1"># Injection break</span>
    <span class="n">log_sed</span> <span class="o">+=</span> <span class="n">log_smoothed_SFBPL</span><span class="p">(</span><span class="n">x_m</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

    <span class="c1"># High-frequency cutoff</span>
    <span class="n">log_sed</span> <span class="o">+=</span> <span class="n">log_exp_cutoff_sed</span><span class="p">(</span><span class="n">x_max</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">log_sed</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_log_powerlaw_sbpl_sed_ssa_2</span><span class="p">(</span>
    <span class="n">log_nu</span><span class="p">:</span> <span class="s2">&quot;_ArrayLike&quot;</span><span class="p">,</span>
    <span class="n">log_nu_m</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">log_nu_a</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">log_nu_max</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">p</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">s</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Logarithm of the synchrotron SED with SSA, assuming the ordering :math:`\nu &lt; \nu_m &lt; \nu_a`.</span>

<span class="sd">    The resulting spectral segments are:</span>

<span class="sd">    - :math:`F_\nu \propto \nu^2` for :math:`\nu &lt; \nu_a`,</span>
<span class="sd">    - :math:`F_\nu \propto \nu^{5/2}` for :math:`\nu_a &lt; \nu &lt; \nu_m`,</span>
<span class="sd">    - :math:`F_\nu \propto \nu^{-(p-1)/2}` for :math:`\nu &gt; \nu_a`.</span>

<span class="sd">    In this case, the SSA break lies above the injection frequency and the</span>
<span class="sd">    intermediate :math:`\nu^{1/3}` segment is absent. The spectrum is therefore</span>
<span class="sd">    **normalized at the injection frequency** :math:`\nu_m` and propagated</span>
<span class="sd">    downward to the SSA break using the appropriate optically thick slope.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    log_nu : array-like</span>
<span class="sd">        Logarithm of the frequencies at which to evaluate the SED.</span>
<span class="sd">    log_nu_m : float</span>
<span class="sd">        Logarithm of the injection frequency :math:`\nu_m`.</span>
<span class="sd">    log_nu_a : float</span>
<span class="sd">        Logarithm of the synchrotron self-absorption frequency</span>
<span class="sd">        :math:`\nu_a`.</span>
<span class="sd">    log_nu_max : float</span>
<span class="sd">        Logarithm of the maximum synchrotron frequency</span>
<span class="sd">        :math:`\nu_{\max}`.</span>
<span class="sd">    p : float</span>
<span class="sd">        Power-law index of the electron energy distribution.</span>
<span class="sd">    s : float</span>
<span class="sd">        Smoothness parameter for the SFBPL transitions.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array-like</span>
<span class="sd">        Logarithm of the synchrotron SED evaluated at ``log_nu``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Assumes :math:`\nu &lt; \nu_m &lt; \nu_a`; no internal validation is performed.</span>
<span class="sd">    - The increase in slope from :math:`\nu^2` to :math:`\nu^{5/2}` requires</span>
<span class="sd">      flipping the sign of the smoothing parameter due to the adopted SFBPL</span>
<span class="sd">      convention.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x_m</span> <span class="o">=</span> <span class="n">log_nu</span> <span class="o">-</span> <span class="n">log_nu_m</span>
    <span class="n">x_a</span> <span class="o">=</span> <span class="n">log_nu</span> <span class="o">-</span> <span class="n">log_nu_a</span>
    <span class="n">x_max</span> <span class="o">=</span> <span class="n">log_nu</span> <span class="o">-</span> <span class="n">log_nu_max</span>

    <span class="c1"># Normalize at the injection frequency ν_m</span>
    <span class="n">log_sed</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">x_m</span> <span class="o">+</span> <span class="p">(</span><span class="mf">5.0</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">log_nu_m</span> <span class="o">-</span> <span class="n">log_nu_a</span><span class="p">)</span>

    <span class="c1"># SSA break (slope increase requires -s in this convention)</span>
    <span class="n">log_sed</span> <span class="o">+=</span> <span class="n">log_smoothed_SFBPL</span><span class="p">(</span><span class="n">x_m</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">5.0</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="o">-</span><span class="n">s</span><span class="p">)</span>

    <span class="c1"># Injection break</span>
    <span class="n">log_sed</span> <span class="o">+=</span> <span class="n">log_smoothed_SFBPL</span><span class="p">(</span><span class="n">x_a</span><span class="p">,</span> <span class="mf">5.0</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

    <span class="c1"># High-frequency cutoff</span>
    <span class="n">log_sed</span> <span class="o">+=</span> <span class="n">log_exp_cutoff_sed</span><span class="p">(</span><span class="n">x_max</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">log_sed</span>


<span class="k">class</span><span class="w"> </span><span class="nc">_SynchrotronSSASEDFunctions</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="n">SPECTRUM_1</span> <span class="o">=</span> <span class="n">_log_powerlaw_sbpl_sed_ssa_1</span>
    <span class="n">SPECTRUM_2</span> <span class="o">=</span> <span class="n">_log_powerlaw_sbpl_sed_ssa_2</span>


<span class="c1"># --- Power-Law SSA + Cooling SEDs --- #</span>
<span class="c1"># NOTE: Spectra 1 and 2 are identical to the non-cooling SSA cases because</span>
<span class="c1"># the cooling break lies above the maximum synchrotron frequency.</span>
<span class="c1"># They are therefore not implemented separately here.</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_log_powerlaw_sbpl_sed_ssa_cool_3</span><span class="p">(</span>
    <span class="n">log_nu</span><span class="p">:</span> <span class="s2">&quot;_ArrayLike&quot;</span><span class="p">,</span>
    <span class="n">log_nu_m</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">log_nu_c</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">log_nu_a</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">log_nu_max</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">p</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">s</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Synchrotron SED with SSA in the **slow-cooling** regime, assuming the ordering :math:`\nu &lt; \nu_a &lt; \nu_m &lt; \nu_c`.</span>

<span class="sd">    The resulting spectral segments are:</span>

<span class="sd">    - :math:`F_\nu \propto \nu^2` for :math:`\nu &lt; \nu_a`,</span>
<span class="sd">    - :math:`F_\nu \propto \nu^{1/3}` for :math:`\nu_a &lt; \nu &lt; \nu_m`,</span>
<span class="sd">    - :math:`F_\nu \propto \nu^{-(p-1)/2}` for</span>
<span class="sd">      :math:`\nu_m &lt; \nu &lt; \nu_c`,</span>
<span class="sd">    - :math:`F_\nu \propto \nu^{-p/2}` for :math:`\nu &gt; \nu_c`.</span>

<span class="sd">    The spectrum is **normalized at the injection frequency** :math:`\nu_m`,</span>
<span class="sd">    which is the dominant optically thin break in the slow-cooling regime.</span>
<span class="sd">    Synchrotron self-absorption and cooling breaks are then applied via</span>
<span class="sd">    scale-free smoothed broken power-law (SFBPL) factors.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    log_nu : array-like</span>
<span class="sd">        Logarithm of the frequencies at which to evaluate the SED.</span>
<span class="sd">    log_nu_m : float</span>
<span class="sd">        Logarithm of the injection frequency :math:`\nu_m`.</span>
<span class="sd">    log_nu_c : float</span>
<span class="sd">        Logarithm of the cooling frequency :math:`\nu_c`.</span>
<span class="sd">    log_nu_a : float</span>
<span class="sd">        Logarithm of the synchrotron self-absorption frequency :math:`\nu_a`.</span>
<span class="sd">    log_nu_max : float</span>
<span class="sd">        Logarithm of the maximum synchrotron frequency.</span>
<span class="sd">    p : float</span>
<span class="sd">        Electron energy distribution index.</span>
<span class="sd">    s : float</span>
<span class="sd">        Smoothness parameter for SFBPL transitions.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array-like</span>
<span class="sd">        Logarithm of the synchrotron SED.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x_a</span> <span class="o">=</span> <span class="n">log_nu</span> <span class="o">-</span> <span class="n">log_nu_a</span>
    <span class="n">x_m</span> <span class="o">=</span> <span class="n">log_nu</span> <span class="o">-</span> <span class="n">log_nu_m</span>
    <span class="n">x_c</span> <span class="o">=</span> <span class="n">log_nu</span> <span class="o">-</span> <span class="n">log_nu_c</span>
    <span class="n">x_max</span> <span class="o">=</span> <span class="n">log_nu</span> <span class="o">-</span> <span class="n">log_nu_max</span>

    <span class="c1"># Normalize at ν_m</span>
    <span class="n">log_sed</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">x_a</span>  <span class="c1"># +(1.0 / 3.0) * (log_nu_a - log_nu_m)</span>

    <span class="c1"># SSA break</span>
    <span class="n">log_sed</span> <span class="o">+=</span> <span class="n">log_smoothed_SFBPL</span><span class="p">(</span><span class="n">x_a</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

    <span class="c1"># Injection break</span>
    <span class="n">log_sed</span> <span class="o">+=</span> <span class="n">log_smoothed_SFBPL</span><span class="p">(</span><span class="n">x_m</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

    <span class="c1"># Cooling break</span>
    <span class="n">log_sed</span> <span class="o">+=</span> <span class="n">log_smoothed_SFBPL</span><span class="p">(</span><span class="n">x_c</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="o">-</span><span class="n">p</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

    <span class="n">log_sed</span> <span class="o">+=</span> <span class="n">log_exp_cutoff_sed</span><span class="p">(</span><span class="n">x_max</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">log_sed</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_log_powerlaw_sbpl_sed_ssa_cool_4</span><span class="p">(</span>
    <span class="n">log_nu</span><span class="p">:</span> <span class="s2">&quot;_ArrayLike&quot;</span><span class="p">,</span>
    <span class="n">log_nu_m</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">log_nu_c</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">log_nu_a</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">log_nu_max</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">p</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">s</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Synchrotron SED with SSA in the **slow-cooling** regime, assuming the ordering :math:`\nu &lt; \nu_m &lt; \nu_a &lt; \nu_c`.</span>

<span class="sd">    The spectral segments are:</span>

<span class="sd">    - :math:`F_\nu \propto \nu^2` for :math:`\nu &lt; \nu_m`,</span>
<span class="sd">    - :math:`F_\nu \propto \nu^{5/2}` for :math:`\nu_m &lt; \nu &lt; \nu_a`,</span>
<span class="sd">    - :math:`F_\nu \propto \nu^{-(p-1)/2}` for</span>
<span class="sd">      :math:`\nu_a &lt; \nu &lt; \nu_c`,</span>
<span class="sd">    - :math:`F_\nu \propto \nu^{-p/2}` for :math:`\nu &gt; \nu_c`.</span>

<span class="sd">    The spectrum is **normalized at the injection frequency** :math:`\nu_m`.</span>
<span class="sd">    The increase in slope from :math:`\nu^2` to :math:`\nu^{5/2}` requires</span>
<span class="sd">    flipping the sign of the smoothing parameter due to the adopted SFBPL</span>
<span class="sd">    convention.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array-like</span>
<span class="sd">        Logarithm of the synchrotron SED.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x_m</span> <span class="o">=</span> <span class="n">log_nu</span> <span class="o">-</span> <span class="n">log_nu_m</span>
    <span class="n">x_a</span> <span class="o">=</span> <span class="n">log_nu</span> <span class="o">-</span> <span class="n">log_nu_a</span>
    <span class="n">x_c</span> <span class="o">=</span> <span class="n">log_nu</span> <span class="o">-</span> <span class="n">log_nu_c</span>
    <span class="n">x_max</span> <span class="o">=</span> <span class="n">log_nu</span> <span class="o">-</span> <span class="n">log_nu_max</span>

    <span class="n">log_sed</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">x_m</span>

    <span class="c1"># RJ → optically thick SSA (slope increase)</span>
    <span class="n">log_sed</span> <span class="o">+=</span> <span class="n">log_smoothed_SFBPL</span><span class="p">(</span><span class="n">x_m</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">5.0</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="o">-</span><span class="n">s</span><span class="p">)</span>

    <span class="c1"># SSA → optically thin uncooled</span>
    <span class="n">log_sed</span> <span class="o">+=</span> <span class="n">log_smoothed_SFBPL</span><span class="p">(</span><span class="n">x_a</span><span class="p">,</span> <span class="mf">5.0</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
    <span class="n">log_sed</span> <span class="o">-=</span> <span class="p">(</span><span class="mf">5.0</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">log_nu_a</span> <span class="o">-</span> <span class="n">log_nu_m</span><span class="p">)</span>

    <span class="c1"># Cooling break</span>
    <span class="n">log_sed</span> <span class="o">+=</span> <span class="n">log_smoothed_SFBPL</span><span class="p">(</span><span class="n">x_c</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="o">-</span><span class="n">p</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

    <span class="n">log_sed</span> <span class="o">+=</span> <span class="n">log_exp_cutoff_sed</span><span class="p">(</span><span class="n">x_max</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">log_sed</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_log_powerlaw_sbpl_sed_ssa_cool_5</span><span class="p">(</span>
    <span class="n">log_nu</span><span class="p">:</span> <span class="s2">&quot;_ArrayLike&quot;</span><span class="p">,</span>
    <span class="n">log_nu_m</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">log_nu_c</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">log_nu_a</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">log_nu_ac</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">log_nu_max</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">p</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">s</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Synchrotron SED with synchrotron self-absorption (SSA) in the **fast-cooling** regime.</span>

<span class="sd">    Includes stratified absorption, assuming the ordering</span>

<span class="sd">    .. math::</span>

<span class="sd">        \nu &lt; \nu_{ac} &lt; \nu_a &lt; \nu_c &lt; \nu_m.</span>

<span class="sd">    In this regime, electrons cool efficiently below the injection energy, and</span>
<span class="sd">    synchrotron self-absorption occurs within a stratified, cooling electron</span>
<span class="sd">    population behind the shock. This produces an additional low-frequency break</span>
<span class="sd">    at :math:`\nu_{ac}`, separating optically thick emission from uncooled and</span>
<span class="sd">    cooled electron layers.</span>

<span class="sd">    The resulting spectral segments are:</span>

<span class="sd">    - :math:`F_\nu \propto \nu^2` for :math:`\nu &lt; \nu_{ac}`,</span>
<span class="sd">    - :math:`F_\nu \propto \nu^{11/8}` for :math:`\nu_{ac} &lt; \nu &lt; \nu_a`,</span>
<span class="sd">    - :math:`F_\nu \propto \nu^{1/3}` for :math:`\nu_a &lt; \nu &lt; \nu_c`,</span>
<span class="sd">    - :math:`F_\nu \propto \nu^{-1/2}` for :math:`\nu_c &lt; \nu &lt; \nu_m`,</span>
<span class="sd">    - :math:`F_\nu \propto \nu^{-p/2}` for :math:`\nu &gt; \nu_m`.</span>

<span class="sd">    The spectrum is **anchored at the cooling frequency** :math:`\nu_c`, which is</span>
<span class="sd">    the dominant physical break in the fast-cooling regime. Lower-frequency</span>
<span class="sd">    structure is constructed via scale-free smoothed broken power laws (SFBPLs)</span>
<span class="sd">    to ensure continuity and correct asymptotic behavior.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    log_nu : array-like</span>
<span class="sd">        Logarithm of the frequencies at which to evaluate the SED.</span>
<span class="sd">    log_nu_m : float</span>
<span class="sd">        Logarithm of the injection frequency :math:`\nu_m`.</span>
<span class="sd">    log_nu_c : float</span>
<span class="sd">        Logarithm of the cooling frequency :math:`\nu_c`.</span>
<span class="sd">    log_nu_a : float</span>
<span class="sd">        Logarithm of the synchrotron self-absorption frequency :math:`\nu_a`.</span>
<span class="sd">    log_nu_ac : float</span>
<span class="sd">        Logarithm of the stratified absorption break frequency :math:`\nu_{ac}`.</span>
<span class="sd">    log_nu_max : float</span>
<span class="sd">        Logarithm of the maximum synchrotron frequency.</span>
<span class="sd">    p : float</span>
<span class="sd">        Electron energy distribution index.</span>
<span class="sd">    s : float</span>
<span class="sd">        Smoothness parameter for SFBPL transitions.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array-like</span>
<span class="sd">        Logarithm of the synchrotron SED.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Assumes fast cooling (:math:`\nu_c \ll \nu_m`) and the stated frequency</span>
<span class="sd">      ordering; no internal validation is performed.</span>
<span class="sd">    - The :math:`11/8` slope arises from stratified synchrotron self-absorption in</span>
<span class="sd">      a cooling electron population.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Determine the nu/nu_a, nu/nu_m, and nu/nu_c ratios</span>
    <span class="n">x_a</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">x_m</span><span class="p">,</span> <span class="n">x_ac</span><span class="p">,</span> <span class="n">x_max</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">log_nu</span> <span class="o">-</span> <span class="n">log_nu_a</span><span class="p">,</span>
        <span class="n">log_nu</span> <span class="o">-</span> <span class="n">log_nu_c</span><span class="p">,</span>
        <span class="n">log_nu</span> <span class="o">-</span> <span class="n">log_nu_m</span><span class="p">,</span>
        <span class="n">log_nu</span> <span class="o">-</span> <span class="n">log_nu_ac</span><span class="p">,</span>
        <span class="n">log_nu</span> <span class="o">-</span> <span class="n">log_nu_max</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># This is a fast-cooled spectrum, so the dominant break is at nu_c and that</span>
    <span class="c1"># is where we anchor the spectrum. The transition at the cooling break is from SPL</span>
    <span class="c1"># E to SPL F (1/3 to -1/2) corresponding from the transition from the uncooled RJ tail to</span>
    <span class="c1"># the cooled population.</span>
    <span class="n">log_sed</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x_ac</span> <span class="o">+</span> <span class="p">(</span><span class="mi">11</span> <span class="o">/</span> <span class="mi">8</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">log_nu_ac</span> <span class="o">-</span> <span class="n">log_nu_a</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">log_nu_a</span> <span class="o">-</span> <span class="n">log_nu_c</span><span class="p">)</span>

    <span class="c1"># We now add the nu_ac break which corresponds to the transition from SPL B to SPL C</span>
    <span class="c1"># (2 to 11/8). This is the transition from the RJ tail to the cooled SSA segment.</span>
    <span class="n">log_sed</span> <span class="o">+=</span> <span class="n">log_smoothed_SFBPL</span><span class="p">(</span><span class="n">x_ac</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mi">11</span> <span class="o">/</span> <span class="mi">8</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

    <span class="c1"># Add the transition from the 11/8 nu_ac stratified segment to the RJ tail at the</span>
    <span class="c1"># absorption break nu_a (11/8 to 1/3; SPL C to SPL E).</span>
    <span class="n">log_sed</span> <span class="o">+=</span> <span class="n">log_smoothed_SFBPL</span><span class="p">(</span><span class="n">x_a</span><span class="p">,</span> <span class="mi">11</span> <span class="o">/</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

    <span class="c1"># Finally, we need to add in the injection break at nu_m. This is SPL F -&gt; SPL H</span>
    <span class="c1"># (-1/2 to -p/2)</span>
    <span class="n">log_sed</span> <span class="o">+=</span> <span class="n">log_smoothed_SFBPL</span><span class="p">(</span><span class="n">x_m</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">p</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
    <span class="c1"># Truncate</span>
    <span class="n">log_sed</span> <span class="o">+=</span> <span class="n">log_exp_cutoff_sed</span><span class="p">(</span><span class="n">x_max</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">log_sed</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_log_powerlaw_sbpl_sed_ssa_cool_6</span><span class="p">(</span>
    <span class="n">log_nu</span><span class="p">:</span> <span class="s2">&quot;_ArrayLike&quot;</span><span class="p">,</span>
    <span class="n">log_nu_m</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">log_nu_a</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">log_nu_ac</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">log_nu_max</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">p</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">s</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Synchrotron SED with SSA assuming the ordering :math:`\nu &lt; \nu_{ac} &lt; \nu_a &lt; \nu_m`.</span>

<span class="sd">    In this configuration, the cooling break lies *above* the self-absorption</span>
<span class="sd">    photosphere and is therefore not directly visible in the emergent spectrum.</span>
<span class="sd">    The observed emission is dominated by optically thick and marginally thin</span>
<span class="sd">    synchrotron radiation from a cooling electron population.</span>

<span class="sd">    The resulting spectral segments are:</span>

<span class="sd">    - :math:`F_\nu \propto \nu^2` for :math:`\nu &lt; \nu_{ac}`,</span>
<span class="sd">    - :math:`F_\nu \propto \nu^{11/8}` for :math:`\nu_{ac} &lt; \nu &lt; \nu_a`,</span>
<span class="sd">    - :math:`F_\nu \propto \nu^{-1/2}` for :math:`\nu_a &lt; \nu &lt; \nu_m`,</span>
<span class="sd">    - :math:`F_\nu \propto \nu^{-p/2}` for :math:`\nu &gt; \nu_m`.</span>

<span class="sd">    Although the system is fast cooling, the cooling break itself does not appear</span>
<span class="sd">    explicitly because it is obscured by synchrotron self-absorption. The spectrum</span>
<span class="sd">    is therefore constructed by anchoring at the absorption break and propagating</span>
<span class="sd">    to higher frequencies using the fast-cooling optically thin slopes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    log_nu : array-like</span>
<span class="sd">        Logarithm of the frequencies at which to evaluate the SED.</span>
<span class="sd">    log_nu_m : float</span>
<span class="sd">        Logarithm of the injection frequency :math:`\nu_m`.</span>
<span class="sd">    log_nu_a : float</span>
<span class="sd">        Logarithm of the synchrotron self-absorption frequency :math:`\nu_a`.</span>
<span class="sd">    log_nu_ac : float</span>
<span class="sd">        Logarithm of the stratified absorption break frequency :math:`\nu_{ac}`.</span>
<span class="sd">    log_nu_max : float</span>
<span class="sd">        Logarithm of the maximum synchrotron frequency.</span>
<span class="sd">    p : float</span>
<span class="sd">        Electron energy distribution index.</span>
<span class="sd">    s : float</span>
<span class="sd">        Smoothness parameter for SFBPL transitions.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array-like</span>
<span class="sd">        Logarithm of the synchrotron SED.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Assumes fast cooling with the cooling break hidden by SSA.</span>
<span class="sd">    - The :math:`11/8` segment reflects stratified absorption in a cooling flow.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Determine the nu/nu_a, nu/nu_m, and nu/nu_c ratios.</span>
    <span class="n">x_a</span><span class="p">,</span> <span class="n">x_m</span><span class="p">,</span> <span class="n">x_ac</span><span class="p">,</span> <span class="n">x_max</span> <span class="o">=</span> <span class="n">log_nu</span> <span class="o">-</span> <span class="n">log_nu_a</span><span class="p">,</span> <span class="n">log_nu</span> <span class="o">-</span> <span class="n">log_nu_m</span><span class="p">,</span> <span class="n">log_nu</span> <span class="o">-</span> <span class="n">log_nu_ac</span><span class="p">,</span> <span class="n">log_nu</span> <span class="o">-</span> <span class="n">log_nu_max</span>

    <span class="c1"># This is a fast-cooling spectrum, so we normalize at the cooling break, but use</span>
    <span class="c1"># the power-law propagation technique to actually place the anchor point at nu_a instead.</span>
    <span class="c1"># This is SPL C to SPL F (11/8 to -1/2).</span>
    <span class="n">log_sed</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x_ac</span> <span class="o">+</span> <span class="p">(</span><span class="mi">11</span> <span class="o">/</span> <span class="mi">8</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">log_nu_ac</span> <span class="o">-</span> <span class="n">log_nu_a</span><span class="p">)</span>

    <span class="c1"># We now add the nu_ac break which corresponds to the transition from SPL B to SPL C</span>
    <span class="c1"># (2 to 11/8). This is the transition from the RJ tail to the cooled SSA segment.</span>
    <span class="n">log_sed</span> <span class="o">+=</span> <span class="n">log_smoothed_SFBPL</span><span class="p">(</span><span class="n">x_ac</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mi">11</span> <span class="o">/</span> <span class="mi">8</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

    <span class="c1"># Add the transition from 11/8 to -1/2 at the absorption break nu_a (SPL C to SPL F).</span>
    <span class="n">log_sed</span> <span class="o">+=</span> <span class="n">log_smoothed_SFBPL</span><span class="p">(</span><span class="n">x_a</span><span class="p">,</span> <span class="mi">11</span> <span class="o">/</span> <span class="mi">8</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

    <span class="c1"># Now add on the injection break at nu_m. This is SPL F -&gt; SPL H. Because we are</span>
    <span class="c1"># fast cooling, the high frequency slope is -p/2.</span>
    <span class="n">log_sed</span> <span class="o">+=</span> <span class="n">log_smoothed_SFBPL</span><span class="p">(</span><span class="n">x_m</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">p</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
    <span class="c1"># Truncate</span>
    <span class="n">log_sed</span> <span class="o">+=</span> <span class="n">log_exp_cutoff_sed</span><span class="p">(</span><span class="n">x_max</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">log_sed</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_log_powerlaw_sbpl_sed_ssa_cool_7</span><span class="p">(</span>
    <span class="n">log_nu</span><span class="p">:</span> <span class="s2">&quot;_ArrayLike&quot;</span><span class="p">,</span>
    <span class="n">log_nu_m</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">log_nu_a</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">log_nu_max</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">p</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">s</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Synchrotron SED with SSA in the **fast-cooling** regime, assuming the ordering :math:`\nu &lt; \nu_m &lt; \nu_a`.</span>

<span class="sd">    In this case, both the cooling break and any stratified absorption structure</span>
<span class="sd">    are hidden beneath the synchrotron self-absorption photosphere. The observed</span>
<span class="sd">    spectrum transitions directly from optically thick emission to optically thin</span>
<span class="sd">    fast-cooled synchrotron radiation.</span>

<span class="sd">    The resulting spectral segments are:</span>

<span class="sd">    - :math:`F_\nu \propto \nu^2` for :math:`\nu &lt; \nu_m`,</span>
<span class="sd">    - :math:`F_\nu \propto \nu^{5/2}` for :math:`\nu_m &lt; \nu &lt; \nu_a`,</span>
<span class="sd">    - :math:`F_\nu \propto \nu^{-p/2}` for :math:`\nu &gt; \nu_a`.</span>

<span class="sd">    The spectrum is **anchored at the injection frequency** :math:`\nu_m`, since</span>
<span class="sd">    all cooling-related breaks occur at higher frequencies and do not affect the</span>
<span class="sd">    low-frequency emission. The SSA break at :math:`\nu_a` directly connects the</span>
<span class="sd">    optically thick synchrotron emission to the fast-cooled optically thin regime.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    log_nu : array-like</span>
<span class="sd">        Logarithm of the frequencies at which to evaluate the SED.</span>
<span class="sd">    log_nu_m : float</span>
<span class="sd">        Logarithm of the injection frequency :math:`\nu_m`.</span>
<span class="sd">    log_nu_a : float</span>
<span class="sd">        Logarithm of the synchrotron self-absorption frequency :math:`\nu_a`.</span>
<span class="sd">    log_nu_max : float</span>
<span class="sd">        Logarithm of the maximum synchrotron frequency.</span>
<span class="sd">    p : float</span>
<span class="sd">        Electron energy distribution index.</span>
<span class="sd">    s : float</span>
<span class="sd">        Smoothness parameter for SFBPL transitions.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array-like</span>
<span class="sd">        Logarithm of the synchrotron SED.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - This regime corresponds to extreme self-absorption in a fast-cooling system.</span>
<span class="sd">    - No explicit cooling break appears in the observable spectrum.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Determine the nu/nu_a and nu/nu_m ratios</span>
    <span class="n">x_a</span><span class="p">,</span> <span class="n">x_m</span><span class="p">,</span> <span class="n">x_max</span> <span class="o">=</span> <span class="n">log_nu</span> <span class="o">-</span> <span class="n">log_nu_a</span><span class="p">,</span> <span class="n">log_nu</span> <span class="o">-</span> <span class="n">log_nu_m</span><span class="p">,</span> <span class="n">log_nu</span> <span class="o">-</span> <span class="n">log_nu_max</span>

    <span class="c1"># We anchor at the injection break because the cooling break (if present) is not visible behind the</span>
    <span class="c1"># absorption photosphere at the shock. We therefore start with the SPL B -&gt; SPL A transition (2 to 5/2).</span>
    <span class="n">log_sed</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x_m</span> <span class="o">+</span> <span class="p">(</span><span class="mi">5</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">log_nu_m</span> <span class="o">-</span> <span class="n">log_nu_a</span><span class="p">)</span>

    <span class="c1"># Now add the SSA break at nu_a which correspond to the transition from optically</span>
    <span class="c1"># thick SSA (A) to optically thin cooled (H) (5/2 to -p/2).</span>
    <span class="n">log_sed</span> <span class="o">+=</span> <span class="n">log_smoothed_SFBPL</span><span class="p">(</span><span class="n">x_a</span><span class="p">,</span> <span class="mi">5</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">p</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

    <span class="c1"># Now we need to add in the injection break at nu_m.</span>
    <span class="n">log_sed</span> <span class="o">+=</span> <span class="n">log_smoothed_SFBPL</span><span class="p">(</span><span class="n">x_m</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">s</span><span class="p">)</span>

    <span class="c1"># Truncate</span>
    <span class="n">log_sed</span> <span class="o">+=</span> <span class="n">log_exp_cutoff_sed</span><span class="p">(</span><span class="n">x_max</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">log_sed</span>


<span class="k">class</span><span class="w"> </span><span class="nc">_SynchrotronSSACoolingSEDFunctions</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="n">SPECTRUM_1</span> <span class="o">=</span> <span class="n">_log_powerlaw_sbpl_sed_ssa_1</span>
    <span class="n">SPECTRUM_2</span> <span class="o">=</span> <span class="n">_log_powerlaw_sbpl_sed_ssa_2</span>
    <span class="n">SPECTRUM_3</span> <span class="o">=</span> <span class="n">_log_powerlaw_sbpl_sed_ssa_cool_3</span>
    <span class="n">SPECTRUM_4</span> <span class="o">=</span> <span class="n">_log_powerlaw_sbpl_sed_ssa_cool_4</span>
    <span class="n">SPECTRUM_5</span> <span class="o">=</span> <span class="n">_log_powerlaw_sbpl_sed_ssa_cool_5</span>
    <span class="n">SPECTRUM_6</span> <span class="o">=</span> <span class="n">_log_powerlaw_sbpl_sed_ssa_cool_6</span>
    <span class="n">SPECTRUM_7</span> <span class="o">=</span> <span class="n">_log_powerlaw_sbpl_sed_ssa_cool_7</span>


<span class="c1"># =============================================================</span>
<span class="c1"># SED Base Class</span>
<span class="c1"># =============================================================</span>
<span class="c1"># To help compartmentalize the name space and prevent any issues</span>
<span class="c1"># with clarity, we provide a small base class for SEDs to serve as a</span>
<span class="c1"># guide both for SED implementation and for documentation.</span>
<div class="viewcode-block" id="SynchrotronSED">
<a class="viewcode-back" href="../../../_as_gen/radiation.synchrotron.SEDs.SynchrotronSED.html#radiation.synchrotron.SEDs.SynchrotronSED">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SynchrotronSED</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for synchrotron SED implementation.</span>

<span class="sd">    The :class:`SynchrotronSED` is a simple compartment for defining the</span>
<span class="sd">    structure of a specific spectral energy distribution. For each SED,</span>
<span class="sd">    one needs to provide</span>

<span class="sd">    1. The :meth:`sed` method (vis-a-vis the low-level ``_log_opt_sed`` method), which</span>
<span class="sd">       simply provides the phenomenological SED shape as a function of frequency and parameters. For example</span>
<span class="sd">       a broken power-law SED would implement the appropriate power-law segments and breaks in this method.</span>

<span class="sd">    2. The :meth:`from_params_to_physics` (vis-a-vis the low-level ``_opt_from_params_to_physics`` method), which</span>
<span class="sd">       provides the mapping from phenomenological SED parameters (e.g., break frequencies, flux normalizations, etc.)</span>
<span class="sd">       to physical parameters (e.g., magnetic field strength, radius, etc.) based on closure relations.</span>
<span class="sd">    3. The :meth:`from_physics_to_params` (vis-a-vis the low-level ``_opt_from_physics_to_params`` method), which</span>
<span class="sd">       provides the mapping from physical parameters (e.g., magnetic field strength, radius, etc.) to phenomenological</span>
<span class="sd">       SED parameters (e.g., break frequencies, flux normalizations, etc.) based on closure relations.</span>

<span class="sd">    Components (2) and (3) are **NOT REQUIRED** for an SED to be functional; however, they are generally necessary</span>
<span class="sd">    for inference. The necessary extent of the infrastructure is left to the implementer.</span>

<span class="sd">    .. hint::</span>

<span class="sd">        All of the existing SEDs are implemented using this base class as a guide. If you&#39;re</span>
<span class="sd">        in need of check out the other classes in this module.</span>

<span class="sd">    Instantiation</span>
<span class="sd">    --------------</span>
<span class="sd">    Instantiation of the SED class may be used to pre-compute class-wide constants, evaluate or construct kernels,</span>
<span class="sd">    etc; however, it should **NOT** be used to store SED-specific parameters. All SED-specific parameters</span>
<span class="sd">    should be passed directly to the relevant methods. This ensures that, during high-load inference tasks,</span>
<span class="sd">    no unnecessary re-instantiation of SED objects is required.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ============================================================ #</span>
    <span class="c1"># Instantiation and basic structure                            #</span>
    <span class="c1"># ============================================================ #</span>
<div class="viewcode-block" id="SynchrotronSED.__init__">
<a class="viewcode-back" href="../../../_as_gen/radiation.synchrotron.SEDs.SynchrotronSED.__init__.html#radiation.synchrotron.SEDs.SynchrotronSED.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Instantiate the SED object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        args:</span>
<span class="sd">            Positional arguments for SED instantiation.</span>
<span class="sd">        kwargs:</span>
<span class="sd">            Keyword arguments for SED instantiation.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The SED instantiation should NOT be used to store SED-specific parameters. All SED-specific parameters</span>
<span class="sd">        should be passed directly to the relevant methods. This ensures that, during high-load inference tasks,</span>
<span class="sd">        no unnecessary re-instantiation of SED objects is required.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nu</span><span class="p">,</span> <span class="o">**</span><span class="n">parameters</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the SED at the given frequency.</span>

<span class="sd">        This is a thin wrapper around :meth:`sed` and exists purely for</span>
<span class="sd">        convenience, allowing SED objects to be used as callables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sed</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="o">**</span><span class="n">parameters</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&lt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">()&gt;&quot;</span>

    <span class="c1"># ============================================================ #</span>
    <span class="c1"># SED Function Implementation                                  #</span>
    <span class="c1"># ============================================================ #</span>
    <span class="c1"># Here should be the implementation of the SED function itself,</span>
    <span class="c1"># which is a function of nu and some set of additional parameters.</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_log_opt_sed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nu</span><span class="p">:</span> <span class="s2">&quot;_ArrayLike&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">parameters</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Low-level optimized log-space SED evaluation.</span>

<span class="sd">        This method implements the core numerical kernel for the synchrotron</span>
<span class="sd">        spectral energy distribution (SED) in **logarithmic space**. It is intended</span>
<span class="sd">        for performance-critical use and therefore assumes that all inputs are</span>
<span class="sd">        already provided in a validated, unit-consistent form.</span>

<span class="sd">        No unit handling, type checking, or safety checks are performed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nu : float or array-like</span>
<span class="sd">            Natural logarithm of the frequency at which to evaluate the SED,</span>

<span class="sd">            .. math::</span>

<span class="sd">                \nu \equiv \ln\!\left(\frac{\nu_{\rm phys}}{\mathrm{Hz}}\right),</span>

<span class="sd">            where :math:`\nu_{\rm phys}` is the physical frequency expressed in</span>
<span class="sd">            Hz-equivalent CGS units.</span>
<span class="sd">        **parameters</span>
<span class="sd">            Additional dimensionless or CGS-valued parameters required for the</span>
<span class="sd">            SED calculation. The exact set of required parameters is</span>
<span class="sd">            implementation-specific.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float or array-like</span>
<span class="sd">            Natural logarithm of the synchrotron SED evaluated at the specified</span>
<span class="sd">            frequency.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

<div class="viewcode-block" id="SynchrotronSED.sed">
<a class="viewcode-back" href="../../../_as_gen/radiation.synchrotron.SEDs.SynchrotronSED.sed.html#radiation.synchrotron.SEDs.SynchrotronSED.sed">[docs]</a>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nu</span><span class="p">:</span> <span class="s2">&quot;_UnitBearingArrayLike&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">parameters</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        User-facing synchrotron SED evaluation.</span>

<span class="sd">        This method provides a high-level, user-friendly interface for computing</span>
<span class="sd">        the synchrotron spectral energy distribution (SED). It is responsible for</span>
<span class="sd">        handling unit validation and coercion, basic shape checking, and any other</span>
<span class="sd">        user-facing conveniences before dispatching to the low-level optimized</span>
<span class="sd">        backend.</span>

<span class="sd">        Internally, this method should convert inputs into the dimensionless,</span>
<span class="sd">        log-space form expected by the optimized implementation</span>
<span class="sd">        (:meth:`_log_opt_sed`).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nu : float, array-like, or astropy.units.Quantity</span>
<span class="sd">            Frequency at which to evaluate the SED. If provided without units,</span>
<span class="sd">            frequencies are assumed to be in Hz. If provided as an</span>
<span class="sd">            :class:`astropy.units.Quantity`, the value will be converted to</span>
<span class="sd">            Hz-equivalent CGS units before evaluation.</span>

<span class="sd">            The frequency may be specified as a scalar (to evaluate a single</span>
<span class="sd">            spectrum) or as a one-dimensional array (to evaluate the SED over</span>
<span class="sd">            a frequency grid).</span>
<span class="sd">        **parameters</span>
<span class="sd">            Additional parameters required for the SED calculation. These may</span>
<span class="sd">            include phenomenological SED parameters (e.g. break frequencies,</span>
<span class="sd">            normalization constants) or physical model parameters, depending</span>
<span class="sd">            on the specific SED implementation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float, array-like, or astropy.units.Quantity</span>
<span class="sd">            The synchrotron SED evaluated at the specified frequency. Implementations</span>
<span class="sd">            may return either plain numerical values or</span>
<span class="sd">            :class:`astropy.units.Quantity` objects with appropriate physical units.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Subclasses must implement this method.</span>
<span class="sd">        - The returned SED should be consistent with the conventions and units</span>
<span class="sd">          adopted by the corresponding low-level implementation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>


    <span class="c1"># =========================================================== #</span>
    <span class="c1"># Closure Relations Implementation                            #</span>
    <span class="c1"># =========================================================== #</span>
    <span class="c1"># Here we implement the closure relations to go forward and backward</span>
    <span class="c1"># between the physics parameters and the phenomenological SED parameters.</span>
<div class="viewcode-block" id="SynchrotronSED.from_params_to_physics">
<a class="viewcode-back" href="../../../_as_gen/radiation.synchrotron.SEDs.SynchrotronSED.from_params_to_physics.html#radiation.synchrotron.SEDs.SynchrotronSED.from_params_to_physics">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_params_to_physics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">parameters</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert phenomenological SED parameters into physical parameters.</span>

<span class="sd">        This method provides a **user-facing interface** for mapping phenomenological</span>
<span class="sd">        SED parameters—such as break frequencies, peak fluxes, or normalization</span>
<span class="sd">        constants—into underlying physical quantities like magnetic field strength,</span>
<span class="sd">        emitting radius, characteristic electron energies, or energy densities.</span>

<span class="sd">        The mapping implemented by this method is **model-dependent** and typically</span>
<span class="sd">        relies on analytic closure relations derived from synchrotron theory, often</span>
<span class="sd">        supplemented by additional microphysical assumptions. Examples include:</span>

<span class="sd">        - assumptions about particle acceleration efficiency,</span>
<span class="sd">        - equipartition or near-equipartition between fields and particles,</span>
<span class="sd">        - prescriptions for the minimum Lorentz factor :math:`\gamma_m`,</span>
<span class="sd">        - geometric assumptions encoded via solid angle or filling factor terms.</span>

<span class="sd">        As a result, the inferred physical parameters should be interpreted within</span>
<span class="sd">        the context of the specific microphysical model adopted by the implementing</span>
<span class="sd">        subclass.</span>

<span class="sd">        This method is optional: an SED implementation is fully functional without</span>
<span class="sd">        it. However, closure relations are generally required for inference workflows,</span>
<span class="sd">        parameter estimation, and for coupling SEDs to dynamical or microphysical</span>
<span class="sd">        models.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **parameters</span>
<span class="sd">            Keyword arguments specifying phenomenological SED parameters. The exact</span>
<span class="sd">            set of required parameters is model-dependent and determined by the</span>
<span class="sd">            implementing subclass.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary containing inferred physical parameters. The contents,</span>
<span class="sd">            naming conventions, and units are implementation-specific.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This method may perform unit validation, coercion, or shape checking</span>
<span class="sd">          before dispatching to the low-level optimized implementation</span>
<span class="sd">          :meth:`_opt_from_params_to_physics`.</span>
<span class="sd">        - The mapping is not guaranteed to be unique; degeneracies may be present</span>
<span class="sd">          depending on the assumed microphysics.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_opt_from_params_to_physics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">parameters</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Low-level optimized conversion from SED parameters to physical parameters.</span>

<span class="sd">        This method implements the same phenomenological-to-physical parameter</span>
<span class="sd">        mapping as :meth:`from_params_to_physics`, but assumes that all inputs are</span>
<span class="sd">        provided as dimensionless scalars or NumPy arrays in consistent CGS units.</span>

<span class="sd">        The mapping may encode analytic closure relations and microphysical</span>
<span class="sd">        assumptions specific to the SED model, but **no validation or safety checks**</span>
<span class="sd">        are performed at this level.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **parameters</span>
<span class="sd">            Keyword arguments specifying phenomenological SED parameters in CGS or</span>
<span class="sd">            dimensionless form. The exact set of required parameters is</span>
<span class="sd">            implementation-specific.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary containing inferred physical parameters in CGS units.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This method is intended for internal use in performance-critical contexts.</span>
<span class="sd">        - It should be called only after unit handling and basic validation have been</span>
<span class="sd">          performed by :meth:`from_params_to_physics`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_opt_from_physics_to_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">parameters</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Low-level optimized conversion from physical parameters to SED parameters.</span>

<span class="sd">        This method implements the inverse mapping of</span>
<span class="sd">        :meth:`_opt_from_params_to_physics`, converting physical quantities—such as</span>
<span class="sd">        magnetic field strength, system size, particle energy scales, or energy</span>
<span class="sd">        densities—into phenomenological SED parameters like break frequencies or</span>
<span class="sd">        peak fluxes.</span>

<span class="sd">        The mapping assumes a specific set of synchrotron closure relations and</span>
<span class="sd">        microphysical prescriptions adopted by the implementing subclass.</span>

<span class="sd">        All inputs are assumed to be provided in CGS units or as dimensionless</span>
<span class="sd">        scalars. No unit validation, consistency checks, or physical sanity checks</span>
<span class="sd">        are performed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **parameters</span>
<span class="sd">            Keyword arguments specifying physical parameters in CGS units. The exact</span>
<span class="sd">            set of required parameters is implementation-specific.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary containing phenomenological SED parameters in CGS or</span>
<span class="sd">            dimensionless form.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This method is intended for internal use in performance-critical contexts.</span>
<span class="sd">        - Inverse mappings may not exist or may not be unique for all SED models.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

<div class="viewcode-block" id="SynchrotronSED.from_physics_to_params">
<a class="viewcode-back" href="../../../_as_gen/radiation.synchrotron.SEDs.SynchrotronSED.from_physics_to_params.html#radiation.synchrotron.SEDs.SynchrotronSED.from_physics_to_params">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_physics_to_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">parameters</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert physical parameters into phenomenological SED parameters.</span>

<span class="sd">        This method provides a **user-facing interface** for mapping physical</span>
<span class="sd">        quantities—such as magnetic field strength, emitting radius, particle</span>
<span class="sd">        energy scales, or energy densities—into phenomenological SED parameters</span>
<span class="sd">        like break frequencies, normalization constants, or spectral amplitudes.</span>

<span class="sd">        The conversion is based on analytic closure relations from synchrotron</span>
<span class="sd">        theory and typically incorporates additional microphysical assumptions</span>
<span class="sd">        (e.g., acceleration efficiency, geometry, or equipartition conditions)</span>
<span class="sd">        defined by the implementing subclass.</span>

<span class="sd">        This functionality is primarily used in inference workflows, where</span>
<span class="sd">        physical model parameters are sampled and must be translated into</span>
<span class="sd">        observable SED quantities.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **parameters</span>
<span class="sd">            Keyword arguments specifying physical parameters. The exact set of</span>
<span class="sd">            required parameters is model-dependent and determined by the</span>
<span class="sd">            implementing subclass.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary containing phenomenological SED parameters.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This method may perform unit validation, coercion, or shape checking</span>
<span class="sd">          before dispatching to the low-level optimized implementation</span>
<span class="sd">          :meth:`_opt_from_physics_to_params`.</span>
<span class="sd">        - Subclasses that do not support inversion of closure relations may leave</span>
<span class="sd">          this method unimplemented.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>
</div>



<div class="viewcode-block" id="MultiSpectrumSynchrotronSED">
<a class="viewcode-back" href="../../../_as_gen/radiation.synchrotron.SEDs.MultiSpectrumSynchrotronSED.html#radiation.synchrotron.SEDs.MultiSpectrumSynchrotronSED">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MultiSpectrumSynchrotronSED</span><span class="p">(</span><span class="n">SynchrotronSED</span><span class="p">,</span> <span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for synchrotron SEDs with multiple discrete spectral regimes.</span>

<span class="sd">    Many synchrotron models admit multiple global spectral &quot;regimes&quot; defined by</span>
<span class="sd">    the ordering of characteristic frequencies (e.g. :math:`\nu_a, \nu_m, \nu_c`).</span>
<span class="sd">    This class provides a standard pattern:</span>

<span class="sd">    1. Determine a regime label from the (global) model parameters.</span>
<span class="sd">    2. Optionally compute *derived* parameters needed to evaluate that regime</span>
<span class="sd">       (e.g. :math:`\nu_a` inferred from :math:`F_{\nu,\mathrm{pk}}`, geometry, etc.).</span>
<span class="sd">    3. Dispatch to a regime-specific optimized kernel.</span>

<span class="sd">    Subclasses implement:</span>

<span class="sd">    - :meth:`_compute_sed_regime`</span>
<span class="sd">    - :meth:`determine_sed_regime`</span>
<span class="sd">    - :meth:`_log_opt_sed_from_regime`</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    All &quot;opt&quot; methods operate on **unitless CGS scalars / NumPy arrays** and</span>
<span class="sd">    should not perform validation. Concrete subclasses must define whether</span>
<span class="sd">    the optimized backend expects linear frequencies ``nu`` or log-frequencies</span>
<span class="sd">    ``log_nu`` (see :meth:`_expects_log_frequency`).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#: Optional mapping/enum describing available regime functions.</span>
    <span class="n">SPECTRUM_FUNCTIONS</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Optional registry of synchrotron spectral regime functions.</span>

<span class="sd">    This attribute, when defined, provides a mapping or enumeration that</span>
<span class="sd">    associates **spectral regime identifiers** with the corresponding</span>
<span class="sd">    callable objects responsible for evaluating or constructing the SED</span>
<span class="sd">    in that regime.</span>

<span class="sd">    Typical use cases include:</span>

<span class="sd">    - Mapping a regime enum (e.g. :class:`SynchrotronSEDRegime`) to a</span>
<span class="sd">      concrete SED implementation.</span>
<span class="sd">    - Providing a lookup table for regime-specific normalization or</span>
<span class="sd">      evaluation logic.</span>
<span class="sd">    - Enabling dynamic dispatch based on the ordering of characteristic</span>
<span class="sd">      frequencies (e.g. :math:`\nu_a`, :math:`\nu_m`, :math:`\nu_c`).</span>

<span class="sd">    If set to ``None``, the class is assumed to represent a **single,</span>
<span class="sd">    fixed spectral regime** and does not support internal regime dispatch.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Subclasses implementing multiple spectral regimes should override</span>
<span class="sd">      this attribute.</span>
<span class="sd">    - The objects stored in this registry are expected to be **callable**</span>
<span class="sd">      and to follow a consistent interface for SED evaluation or</span>
<span class="sd">      construction.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ============================================================ #</span>
    <span class="c1"># Regime Management                                            #</span>
    <span class="c1"># ============================================================ #</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_sed_regime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">parameters</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine the global SED regime and any derived parameters.</span>

<span class="sd">        This method encodes the logic used to classify the SED into a discrete</span>
<span class="sd">        physical regime based on the ordering of characteristic frequencies.</span>
<span class="sd">        It may additionally compute *derived* parameters required to evaluate</span>
<span class="sd">        the spectrum (e.g. an inferred SSA frequency :math:`\nu_a`).</span>

<span class="sd">        The returned regime applies **globally** and does not depend on the</span>
<span class="sd">        sampling frequency grid.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **parameters</span>
<span class="sd">            Model parameters required to determine the regime. Typical examples</span>
<span class="sd">            include characteristic frequencies (or their log-values), peak flux</span>
<span class="sd">            normalizations, geometric factors, and microphysical parameters.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        (regime, derived)</span>
<span class="sd">            regime : int or Enum-like</span>
<span class="sd">                Regime identifier. The interpretation is defined by the subclass.</span>
<span class="sd">            derived : dict</span>
<span class="sd">                Derived parameters needed for evaluation in the selected regime.</span>
<span class="sd">                This may include values such as ``log_nu_a`` or other cached</span>
<span class="sd">                quantities used by the regime-specific kernel.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This method should be *fast* and free of allocations when possible.</span>
<span class="sd">        - No unit checking or validation should occur here.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

<div class="viewcode-block" id="MultiSpectrumSynchrotronSED.determine_sed_regime">
<a class="viewcode-back" href="../../../_as_gen/radiation.synchrotron.SEDs.MultiSpectrumSynchrotronSED.determine_sed_regime.html#radiation.synchrotron.SEDs.MultiSpectrumSynchrotronSED.determine_sed_regime">[docs]</a>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">determine_sed_regime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">parameters</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine the physical synchrotron spectral regime (public API).</span>

<span class="sd">        This method is intended for diagnostic and introspection use. It should</span>
<span class="sd">        perform any necessary unit handling and validation, then delegate to the</span>
<span class="sd">        optimized implementation (:meth:`_compute_sed_regime`).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **parameters</span>
<span class="sd">            User-facing model parameters. Typical examples include quantities</span>
<span class="sd">            such as :math:`\nu_m`, :math:`\nu_c`, :math:`F_{\nu,\mathrm{pk}}`, etc.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        regime : int or Enum-like</span>
<span class="sd">            Regime identifier defined by the subclass.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The regime does not depend on the frequency grid used for evaluation.</span>
<span class="sd">        - Subclasses should ensure that the regime returned here is consistent</span>
<span class="sd">          with the behavior of :meth:`sed`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>


    <span class="c1"># ============================================================ #</span>
    <span class="c1"># Regime-Specific SED Kernel                                   #</span>
    <span class="c1"># ============================================================ #</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_log_opt_sed_from_regime</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">nu</span><span class="p">:</span> <span class="s2">&quot;_ArrayLike&quot;</span><span class="p">,</span>
        <span class="n">regime</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
        <span class="o">**</span><span class="n">parameters</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the log-space SED for a pre-determined regime.</span>

<span class="sd">        This method computes the logarithm of the SED for a single regime.</span>
<span class="sd">        All branching on ``regime`` should occur here (or above), and this</span>
<span class="sd">        method should assume that any derived parameters required for the regime</span>
<span class="sd">        have already been computed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nu : float or array-like</span>
<span class="sd">            Frequency grid in optimized form. If :meth:`_expects_log_frequency`</span>
<span class="sd">            returns True, this is ``log_nu = log(ν)``. Otherwise it is linear ν.</span>
<span class="sd">        regime : int or Enum-like</span>
<span class="sd">            Regime identifier returned by :meth:`_compute_sed_regime`.</span>
<span class="sd">        **parameters</span>
<span class="sd">            Parameters required by the kernel, including any derived values</span>
<span class="sd">            produced by :meth:`_compute_sed_regime`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float or array-like</span>
<span class="sd">            Logarithm of the SED evaluated at the given frequencies.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is the performance-critical kernel. Implementations should avoid</span>
<span class="sd">        allocations and unnecessary branching when possible.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="c1"># ============================================================ #</span>
    <span class="c1"># Log-Space Orchestration                                      #</span>
    <span class="c1"># ============================================================ #</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_log_opt_sed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nu</span><span class="p">:</span> <span class="s2">&quot;_ArrayLike&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">parameters</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Log-space optimized SED evaluation with regime dispatch.</span>

<span class="sd">        This method determines the appropriate SED regime from the input</span>
<span class="sd">        parameters and dispatches to the corresponding regime-specific kernel.</span>

<span class="sd">        Subclasses should generally **not override** this method. Instead,</span>
<span class="sd">        implement :meth:`_compute_sed_regime` and :meth:`_log_opt_sed_from_regime`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nu : float or array-like</span>
<span class="sd">            Frequency grid in optimized form. If :meth:`_expects_log_frequency`</span>
<span class="sd">            returns True, this is ``log_nu = log(ν)``. Otherwise it is linear ν.</span>
<span class="sd">        **parameters</span>
<span class="sd">            Parameters required for both regime determination and SED evaluation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float or array-like</span>
<span class="sd">            Logarithm of the SED evaluated at the given frequencies.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">regime</span><span class="p">,</span> <span class="n">derived</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_sed_regime</span><span class="p">(</span><span class="o">**</span><span class="n">parameters</span><span class="p">)</span>
        <span class="n">merged</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
        <span class="n">merged</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">derived</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_log_opt_sed_from_regime</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">regime</span><span class="p">,</span> <span class="o">**</span><span class="n">merged</span><span class="p">)</span></div>



<span class="c1"># ============================================================ #</span>
<span class="c1"># SED Implementations                                          #</span>
<span class="c1"># ============================================================ #</span>
<span class="c1"># Now we can include concrete implementations of various SEDs. Not</span>
<span class="c1"># all of the SEDs we plan to implement are currently implemented in the</span>
<span class="c1"># codebase, but we provide a few examples here to illustrate the structure.</span>
<div class="viewcode-block" id="PowerLaw_SynchrotronSED">
<a class="viewcode-back" href="../../../_as_gen/radiation.synchrotron.SEDs.PowerLaw_SynchrotronSED.html#radiation.synchrotron.SEDs.PowerLaw_SynchrotronSED">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">PowerLaw_SynchrotronSED</span><span class="p">(</span><span class="n">SynchrotronSED</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Canonical optically thin power-law synchrotron SED.</span>

<span class="sd">    This class implements the standard synchrotron spectral energy distribution</span>
<span class="sd">    for an **uncooled, optically thin** population of relativistic electrons with</span>
<span class="sd">    a power-law energy distribution. See :ref:`synchrotron_theory` for a discussion</span>
<span class="sd">    of the relevant background physics and :ref:`synch_sed_theory` for a detailed</span>
<span class="sd">    derivation of this and related SEDs.</span>

<span class="sd">    This SED is applicable only in the simplest regimes where both radiative</span>
<span class="sd">    cooling and synchrotron self-absorption can be neglected. Typical examples</span>
<span class="sd">    include young systems whose cooling timescales are long compared to the</span>
<span class="sd">    dynamical time, or low-density environments where the emission remains</span>
<span class="sd">    optically thin across the observed band.</span>

<span class="sd">    .. rubric:: Spectral Structure</span>

<span class="sd">    This SED consists of a single optically thin synchrotron spectrum with one</span>
<span class="sd">    physical spectral break at the injection frequency :math:`\nu_m`, and an</span>
<span class="sd">    optional high-frequency exponential cutoff at :math:`\nu_{\max}`:</span>

<span class="sd">    - :math:`F_\nu \propto \nu^{1/3}` for :math:`\nu &lt; \nu_m`, corresponding to the</span>
<span class="sd">      low-frequency optically thin synchrotron tail.</span>
<span class="sd">    - :math:`F_\nu \propto \nu^{-(p-1)/2}` for :math:`\nu_m &lt; \nu &lt; \nu_{\max}`,</span>
<span class="sd">      corresponding to emission from the accelerated power-law electron population.</span>
<span class="sd">    - An exponential suppression above :math:`\nu_{\max}`.</span>

<span class="sd">    .. hint::</span>

<span class="sd">        For a detailed derivation and discussion of this spectrum, see</span>
<span class="sd">        :ref:`synch_sed_theory`.</span>

<span class="sd">    .. rubric:: SED Parameters</span>

<span class="sd">    The parameters entering this SED fall into three conceptual categories.</span>

<span class="sd">    .. tab-set::</span>

<span class="sd">        .. tab-item:: Free parameters (phenomenological)</span>

<span class="sd">            These parameters define the observable structure of the SED and are</span>
<span class="sd">            typically inferred directly from broadband data.</span>

<span class="sd">            .. list-table::</span>
<span class="sd">                :widths: 25 15 60</span>
<span class="sd">                :header-rows: 1</span>

<span class="sd">                * - Parameter</span>
<span class="sd">                  - Symbol</span>
<span class="sd">                  - Description</span>
<span class="sd">                * - Normalization flux density</span>
<span class="sd">                  - :math:`F_{\nu,\mathrm{norm}}`</span>
<span class="sd">                  - Flux density of the **dominant optically thin emitting</span>
<span class="sd">                    population** used to normalize the SED.</span>
<span class="sd">                    For this SED, the dominant optically thin emission occurs at</span>
<span class="sd">                    the injection frequency :math:`\nu_m`, so</span>
<span class="sd">                    :math:`F_{\nu,\mathrm{norm}} = F_\nu(\nu_m)`.</span>
<span class="sd">                * - Injection frequency</span>
<span class="sd">                  - :math:`\nu_m`</span>
<span class="sd">                  - Synchrotron characteristic frequency of the minimum-energy</span>
<span class="sd">                    electrons.</span>
<span class="sd">                * - Maximum frequency</span>
<span class="sd">                  - :math:`\nu_{\max}`</span>
<span class="sd">                  - High-frequency exponential cutoff.</span>

<span class="sd">        .. tab-item:: Hyper-parameters</span>

<span class="sd">            These parameters control the *shape* of the spectrum but are not</span>
<span class="sd">            usually directly constrained by broadband observations.</span>

<span class="sd">            .. list-table::</span>
<span class="sd">                :widths: 25 15 60</span>
<span class="sd">                :header-rows: 1</span>

<span class="sd">                * - Parameter</span>
<span class="sd">                  - Symbol</span>
<span class="sd">                  - Description</span>
<span class="sd">                * - Electron power-law index</span>
<span class="sd">                  - :math:`p`</span>
<span class="sd">                  - Index of the injected electron energy distribution,</span>
<span class="sd">                    :math:`N(\gamma) \propto \gamma^{-p}`.</span>
<span class="sd">                * - Smoothing parameter</span>
<span class="sd">                  - :math:`s`</span>
<span class="sd">                  - Controls the sharpness of the spectral transition at</span>
<span class="sd">                    :math:`\nu_m`.</span>

<span class="sd">    .. rubric:: Normalization and Closure</span>

<span class="sd">    The SED is **always normalized using** :math:`F_{\nu,\mathrm{norm}}`, defined</span>
<span class="sd">    as the flux density of the dominant optically thin emitting electron</span>
<span class="sd">    population. The location of this normalization frequency depends on the</span>
<span class="sd">    physical regime.</span>

<span class="sd">    In the present optically thin, uncooled case, the dominant emission occurs</span>
<span class="sd">    at :math:`\nu_m`, so the normalization coincides with the injection break.</span>
<span class="sd">    In more complex SEDs (e.g. with cooling or self-absorption), the normalization</span>
<span class="sd">    may instead correspond to a different characteristic frequency.</span>

<span class="sd">    Optional closure relations are provided to map physical model parameters</span>
<span class="sd">    (e.g. magnetic field strength, emitting volume, electron energy fractions)</span>
<span class="sd">    onto the phenomenological SED parameters under assumed microphysical</span>
<span class="sd">    conditions such as equipartition.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :class:`SynchrotronSED`</span>
<span class="sd">        Base class for synchrotron SED implementations.</span>
<span class="sd">    :class:`MultiSpectrumSynchrotronSED`</span>
<span class="sd">        Base class for multi-regime synchrotron SEDs.</span>
<span class="sd">    :class:`PowerLaw_Cooling_SynchrotronSED`</span>
<span class="sd">        Synchrotron SED including a radiative cooling break.</span>
<span class="sd">    :class:`PowerLaw_SSA_SynchrotronSED`</span>
<span class="sd">        Synchrotron SED including synchrotron self-absorption.</span>
<span class="sd">    :class:`PowerLaw_Cooling_SSA_SynchrotronSED`</span>
<span class="sd">        Synchrotron SED including both cooling and self-absorption.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The simplest use case is to evaluate the SED directly from phenomenological</span>
<span class="sd">    parameters inferred from data.</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import numpy as np</span>
<span class="sd">        import astropy.units as u</span>
<span class="sd">        from triceratops.radiation.synchrotron import (</span>
<span class="sd">            PowerLaw_SynchrotronSED,</span>
<span class="sd">        )</span>

<span class="sd">        sed = PowerLaw_SynchrotronSED()</span>

<span class="sd">        nu = np.logspace(8, 18, 300) * u.Hz</span>

<span class="sd">        F_nu = sed.sed(</span>
<span class="sd">            nu=nu,</span>
<span class="sd">            F_norm=1e-26 * u.erg / (u.cm**2 * u.s * u.Hz),</span>
<span class="sd">            nu_m=1e12 * u.Hz,</span>
<span class="sd">            nu_max=1e18 * u.Hz,</span>
<span class="sd">            p=2.4,</span>
<span class="sd">        )</span>

<span class="sd">    This evaluates the optically thin synchrotron spectrum with a normalization</span>
<span class="sd">    at :math:`\nu_m = 10^{12}\,\mathrm{Hz}` and an electron index :math:`p=2.4`.</span>

<span class="sd">    More commonly, the SED may be constructed from physical model parameters</span>
<span class="sd">    using the equipartition-based closure relation.</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        params = sed.from_physics_to_params(</span>
<span class="sd">            B=0.1 * u.G,</span>
<span class="sd">            V=1e48 * u.cm**3,</span>
<span class="sd">            D_L=100 * u.Mpc,</span>
<span class="sd">            gamma_min=100.0,</span>
<span class="sd">            gamma_max=1e6,</span>
<span class="sd">            p=2.3,</span>
<span class="sd">            epsilon_E=0.1,</span>
<span class="sd">            epsilon_B=0.1,</span>
<span class="sd">            pitch_average=True,</span>
<span class="sd">        )</span>

<span class="sd">        F_nu = sed.sed(</span>
<span class="sd">            nu=nu,</span>
<span class="sd">            **params,</span>
<span class="sd">            p=2.3,</span>
<span class="sd">        )</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ============================================================ #</span>
    <span class="c1"># SED Function Implementation                                  #</span>
    <span class="c1"># ============================================================ #</span>
    <span class="c1"># Here should be the implementation of the SED function itself,</span>
    <span class="c1"># which is a function of nu and some set of additional parameters.</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_log_opt_sed</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">log_nu</span><span class="p">:</span> <span class="s2">&quot;_ArrayLike&quot;</span><span class="p">,</span>
        <span class="n">log_F_norm</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_nu_m</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_nu_max</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
        <span class="n">p</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.5</span><span class="p">,</span>
        <span class="n">s</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">5.0</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the logarithm of the optically thin power-law synchrotron SED.</span>

<span class="sd">        This method implements the **core spectral shape** of the canonical,</span>
<span class="sd">        optically thin, uncooled synchrotron SED entirely in log-space. It is the</span>
<span class="sd">        lowest-level representation of the SED used internally by this class and</span>
<span class="sd">        by inference routines.</span>

<span class="sd">        The spectrum is constructed as a smoothed broken power law with a single</span>
<span class="sd">        physical break at the injection frequency :math:`\nu_m` and an exponential</span>
<span class="sd">        cutoff at :math:`\nu_{\max}`. The overall normalization is applied</span>
<span class="sd">        multiplicatively via the peak flux density.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        log_nu : array-like</span>
<span class="sd">            Natural logarithm of the observing frequency (in Hz).</span>
<span class="sd">            This may be a scalar or an array and is assumed to be dimensionless.</span>
<span class="sd">        log_F_norm : float</span>
<span class="sd">            The natural logarithm of the normalization flux density, corresponding to the</span>
<span class="sd">            corresponding flux density at the dominant optically thin frequency (in this case, :math:`\nu_m`).</span>
<span class="sd">            Because this SED is optically thin at peak, this is also the flux density at the injection break.</span>
<span class="sd">        log_nu_m : float</span>
<span class="sd">            Natural logarithm of the injection (peak) frequency</span>
<span class="sd">            :math:`\nu_m`.</span>
<span class="sd">        log_nu_max : float, optional</span>
<span class="sd">            Natural logarithm of the maximum synchrotron frequency</span>
<span class="sd">            :math:`\nu_{\max}`. Above this frequency, the spectrum is exponentially</span>
<span class="sd">            suppressed. The default is :math:`+\infty`, corresponding to no cutoff.</span>
<span class="sd">        p : float, optional</span>
<span class="sd">            Power-law index of the injected electron energy distribution,</span>
<span class="sd">            :math:`N(\gamma) \propto \gamma^{-p}`.</span>
<span class="sd">        s : float, optional</span>
<span class="sd">            Smoothing parameter controlling the sharpness of the spectral break</span>
<span class="sd">            at :math:`\nu_m`. Larger values correspond to sharper transitions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        log_F_nu : array-like</span>
<span class="sd">            Natural logarithm of the flux density :math:`F_\nu` evaluated at</span>
<span class="sd">            ``log_nu``.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This method performs **no unit handling** and assumes all inputs are</span>
<span class="sd">          dimensionless and expressed in CGS-consistent logarithmic form.</span>
<span class="sd">        - This method does **not** perform any physical normalization; it merely</span>
<span class="sd">          applies the spectral shape and multiplies by the supplied peak flux.</span>
<span class="sd">        - All higher-level interfaces (e.g. :meth:`sed`) are thin wrappers around</span>
<span class="sd">          this method.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        _log_powerlaw_sbpl_sed :</span>
<span class="sd">            Low-level implementation of the smoothed broken power-law shape.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">_log_powerlaw_sbpl_sed</span><span class="p">(</span>
                <span class="n">log_nu</span><span class="p">,</span>
                <span class="n">log_nu_m</span><span class="p">,</span>
                <span class="n">log_nu_max</span><span class="p">,</span>
                <span class="n">p</span><span class="p">,</span>
                <span class="n">s</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="o">+</span> <span class="n">log_F_norm</span>
        <span class="p">)</span>

<div class="viewcode-block" id="PowerLaw_SynchrotronSED.sed">
<a class="viewcode-back" href="../../../_as_gen/radiation.synchrotron.SEDs.PowerLaw_SynchrotronSED.sed.html#radiation.synchrotron.SEDs.PowerLaw_SynchrotronSED.sed">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">sed</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">nu</span><span class="p">:</span> <span class="s2">&quot;_UnitBearingArrayLike&quot;</span><span class="p">,</span>
        <span class="n">F_norm</span><span class="p">:</span> <span class="s2">&quot;_UnitBearingScalarLike&quot;</span><span class="p">,</span>
        <span class="n">nu_m</span><span class="p">:</span> <span class="s2">&quot;_UnitBearingScalarLike&quot;</span><span class="p">,</span>
        <span class="n">nu_max</span><span class="p">:</span> <span class="s2">&quot;_UnitBearingScalarLike&quot;</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">Hz</span><span class="p">,</span>
        <span class="n">p</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.5</span><span class="p">,</span>
        <span class="n">s</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">5.0</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the optically thin power-law synchrotron SED.</span>

<span class="sd">        This is the **public, unit-aware interface** for evaluating the canonical</span>
<span class="sd">        power-law synchrotron SED. It performs unit validation and conversion,</span>
<span class="sd">        dispatches to the internal log-space implementation, and returns the</span>
<span class="sd">        flux density with appropriate physical units.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nu : array-like or quantity</span>
<span class="sd">            Observing frequencies at which to evaluate the SED. If unit-bearing,</span>
<span class="sd">            must be convertible to Hz.</span>
<span class="sd">        F_norm : scalar or quantity</span>
<span class="sd">            The normalization flux density, corresponding to the</span>
<span class="sd">            corresponding flux density at the dominant optically thin frequency (in this case, :math:`\nu_m`).</span>
<span class="sd">            Because this SED is optically thin at peak, this is also the flux density at the injection break.</span>
<span class="sd">        nu_m : scalar or quantity</span>
<span class="sd">            Injection (peak) frequency :math:`\nu_m`. If unit-bearing, must be</span>
<span class="sd">            convertible to Hz.</span>
<span class="sd">        nu_max : scalar or quantity, optional</span>
<span class="sd">            Maximum synchrotron frequency :math:`\nu_{\max}`. Frequencies above</span>
<span class="sd">            this value are exponentially suppressed. The default corresponds to</span>
<span class="sd">            no cutoff.</span>
<span class="sd">        p : float, optional</span>
<span class="sd">            Electron power-law index.</span>
<span class="sd">        s : float, optional</span>
<span class="sd">            Smoothing parameter controlling the sharpness of the spectral break.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        F_nu : array-like or quantity</span>
<span class="sd">            Flux density evaluated at ``nu``, returned with units of</span>
<span class="sd">            ``erg cm^-2 s^-1 Hz^-1``.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This method is a thin wrapper around the internal log-space method</span>
<span class="sd">          :meth:`_log_opt_sed`.</span>
<span class="sd">        - All numerical evaluation is performed in logarithmic space for</span>
<span class="sd">          numerical stability.</span>
<span class="sd">        - This method does not enforce any physical closure; the parameters</span>
<span class="sd">          ``F_norm``, ``nu_m``, and ``nu_max`` are treated as phenomenological</span>
<span class="sd">          inputs.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Evaluate a simple power-law synchrotron SED:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            sed = PowerLaw_SynchrotronSED()</span>
<span class="sd">            nu = np.logspace(8, 18, 200) * u.Hz</span>
<span class="sd">            F_nu = sed.sed(</span>
<span class="sd">                nu=nu,</span>
<span class="sd">                F_norm=1e-26 * u.erg / (u.cm**2 * u.s * u.Hz),</span>
<span class="sd">                nu_m=1e12 * u.Hz,</span>
<span class="sd">                p=2.4,</span>
<span class="sd">            )</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Handle units</span>
        <span class="n">nu</span> <span class="o">=</span> <span class="n">ensure_in_units</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="s2">&quot;Hz&quot;</span><span class="p">)</span>
        <span class="n">nu_m</span> <span class="o">=</span> <span class="n">ensure_in_units</span><span class="p">(</span><span class="n">nu_m</span><span class="p">,</span> <span class="s2">&quot;Hz&quot;</span><span class="p">)</span>
        <span class="n">nu_max</span> <span class="o">=</span> <span class="n">ensure_in_units</span><span class="p">(</span><span class="n">nu_max</span><span class="p">,</span> <span class="s2">&quot;Hz&quot;</span><span class="p">)</span>
        <span class="n">F_norm</span> <span class="o">=</span> <span class="n">ensure_in_units</span><span class="p">(</span><span class="n">F_norm</span><span class="p">,</span> <span class="s2">&quot;erg cm^-2 s^-1 Hz^-1&quot;</span><span class="p">)</span>

        <span class="c1"># Convert to log-space dimensionless CGS</span>
        <span class="n">log_nu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">nu</span><span class="p">)</span>
        <span class="n">log_nu_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">nu_m</span><span class="p">)</span>
        <span class="n">log_nu_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">nu_max</span><span class="p">)</span>
        <span class="n">log_F_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">F_norm</span><span class="p">)</span>

        <span class="c1"># Dispatch to optimized implementation</span>
        <span class="n">log_sed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_log_opt_sed</span><span class="p">(</span>
            <span class="n">log_nu</span><span class="o">=</span><span class="n">log_nu</span><span class="p">,</span>
            <span class="n">log_F_norm</span><span class="o">=</span><span class="n">log_F_norm</span><span class="p">,</span>
            <span class="n">log_nu_m</span><span class="o">=</span><span class="n">log_nu_m</span><span class="p">,</span>
            <span class="n">log_nu_max</span><span class="o">=</span><span class="n">log_nu_max</span><span class="p">,</span>
            <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span>
            <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_sed</span><span class="p">)</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">erg</span> <span class="o">/</span> <span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">cm</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">s</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">Hz</span><span class="p">)</span></div>


    <span class="c1"># =========================================================== #</span>
    <span class="c1"># Closure Relations Implementation                            #</span>
    <span class="c1"># =========================================================== #</span>
    <span class="c1"># Here we implement the closure relations to go forward and backward</span>
    <span class="c1"># between the physics parameters and the phenomenological SED parameters.</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_opt_from_physics_to_params</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">log_B</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_V</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_D_L</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_gamma_min</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_gamma_max</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
        <span class="n">p</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.5</span><span class="p">,</span>
        <span class="n">epsilon_E</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">epsilon_B</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">pitch_average</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Map physical parameters to phenomenological SED parameters.</span>

<span class="sd">        This method implements a deterministic **closure relation** that connects</span>
<span class="sd">        physical model parameters (e.g. magnetic field strength, emitting volume,</span>
<span class="sd">        electron energy fractions) to the phenomenological parameters defining the</span>
<span class="sd">        canonical power-law synchrotron SED.</span>

<span class="sd">        The mapping is performed under the assumption of **equipartition** between</span>
<span class="sd">        relativistic electrons and magnetic fields and follows the normalization</span>
<span class="sd">        scheme described in :ref:`synch_sed_theory`.</span>

<span class="sd">        All computations are carried out in log-space to ensure numerical stability</span>
<span class="sd">        and compatibility with inference workflows.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        log_B : float</span>
<span class="sd">            Natural logarithm of the magnetic field strength (Gauss).</span>
<span class="sd">        log_V : float</span>
<span class="sd">            Natural logarithm of the effective emitting volume (cm^3). This is often</span>
<span class="sd">            parameterized in terms of a filling factor :math:`f`.</span>
<span class="sd">        log_D_L : float</span>
<span class="sd">            Natural logarithm of the luminosity distance (cm).</span>
<span class="sd">        log_gamma_min : float</span>
<span class="sd">            Natural logarithm of the minimum electron Lorentz factor</span>
<span class="sd">            :math:`\gamma_{\min}`.</span>
<span class="sd">        log_gamma_max : float, optional</span>
<span class="sd">            Natural logarithm of the maximum electron Lorentz factor</span>
<span class="sd">            :math:`\gamma_{\max}`. The default corresponds to no upper cutoff.</span>
<span class="sd">        p : float, optional</span>
<span class="sd">            Power-law index of the injected electron distribution.</span>
<span class="sd">        epsilon_E : float, optional</span>
<span class="sd">            Fraction of post-shock internal energy carried by relativistic electrons.</span>
<span class="sd">        epsilon_B : float, optional</span>
<span class="sd">            Fraction of post-shock internal energy stored in magnetic fields.</span>
<span class="sd">        alpha : float, optional</span>
<span class="sd">            Electron pitch angle in radians. This parameter is ignored if</span>
<span class="sd">            ``pitch_average=True``.</span>
<span class="sd">        pitch_average : bool, optional</span>
<span class="sd">            If ``True``, use pitch-angle averaged synchrotron emissivity.</span>
<span class="sd">            Otherwise, a fixed pitch angle specified by ``alpha`` is used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        params : dict</span>
<span class="sd">            Dictionary containing the phenomenological SED parameters:</span>

<span class="sd">            - ``log_F_norm`` : Natural logarithm of the peak flux density</span>
<span class="sd">              :math:`F_{\nu,\mathrm{pk}}`.</span>
<span class="sd">            - ``log_nu_m`` : Natural logarithm of the injection (peak) frequency</span>
<span class="sd">              :math:`\nu_m`.</span>
<span class="sd">            - ``log_nu_max`` : Natural logarithm of the maximum synchrotron</span>
<span class="sd">              frequency :math:`\nu_{\max}`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This closure assumes a **single-zone**, homogeneous emitting region.</span>
<span class="sd">        - Equipartition is an **assumption**, not a physical requirement; alternative</span>
<span class="sd">          closures may be implemented by overriding this method.</span>
<span class="sd">        - This method does not perform any consistency checks on the resulting SED</span>
<span class="sd">          (e.g. cooling or self-absorption); such checks are handled by more</span>
<span class="sd">          specialized SED subclasses.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Handle pitch angle details and the relevant values of</span>
        <span class="c1"># the log_chi parameter in each case. This allows us to</span>
        <span class="c1"># permit both a fixed pitch angle and pitch-angle averaging.</span>
        <span class="n">sin_alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">log_sin_alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">sin_alpha</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">pitch_average</span> <span class="k">else</span> <span class="mf">0.0</span>
        <span class="n">log_chi</span> <span class="o">=</span> <span class="n">_log_chi_cgs_iso</span> <span class="k">if</span> <span class="n">pitch_average</span> <span class="k">else</span> <span class="n">_log_chi_cgs</span>

        <span class="c1"># Characteristic synchrotron frequencies</span>
        <span class="n">log_nu_m</span> <span class="o">=</span> <span class="n">_opt_compute_log_synch_frequency</span><span class="p">(</span>
            <span class="n">log_gamma_min</span><span class="p">,</span>
            <span class="n">log_B</span><span class="p">,</span>
            <span class="n">sin_alpha</span><span class="o">=</span><span class="n">sin_alpha</span><span class="p">,</span>
            <span class="n">pitch_average</span><span class="o">=</span><span class="n">pitch_average</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">log_nu_max</span> <span class="o">=</span> <span class="n">_opt_compute_log_synch_frequency</span><span class="p">(</span>
            <span class="n">log_gamma_max</span><span class="p">,</span>
            <span class="n">log_B</span><span class="p">,</span>
            <span class="n">sin_alpha</span><span class="o">=</span><span class="n">sin_alpha</span><span class="p">,</span>
            <span class="n">pitch_average</span><span class="o">=</span><span class="n">pitch_average</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Electron distribution normalization via equipartition</span>
        <span class="n">log_N0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
            <span class="n">_opt_normalize_PL_from_magnetic_field</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_B</span><span class="p">),</span>
                <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span>
                <span class="n">epsilon_E</span><span class="o">=</span><span class="n">epsilon_E</span><span class="p">,</span>
                <span class="n">epsilon_B</span><span class="o">=</span><span class="n">epsilon_B</span><span class="p">,</span>
                <span class="n">gamma_min</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_gamma_min</span><span class="p">),</span>
                <span class="n">gamma_max</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_gamma_max</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Peak flux normalization</span>
        <span class="n">log_F_norm</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">log_chi</span>
            <span class="o">+</span> <span class="n">log_B</span>
            <span class="o">+</span> <span class="n">log_sin_alpha</span>  <span class="c1"># Will be zero if pitch-averaged</span>
            <span class="o">+</span> <span class="n">log_N0</span>
            <span class="o">+</span> <span class="n">log_V</span>
            <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">log_D_L</span>
            <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="n">log_gamma_min</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;log_F_norm&quot;</span><span class="p">:</span> <span class="n">log_F_norm</span><span class="p">,</span>
            <span class="s2">&quot;log_nu_m&quot;</span><span class="p">:</span> <span class="n">log_nu_m</span><span class="p">,</span>
            <span class="s2">&quot;log_nu_max&quot;</span><span class="p">:</span> <span class="n">log_nu_max</span><span class="p">,</span>
        <span class="p">}</span>

<div class="viewcode-block" id="PowerLaw_SynchrotronSED.from_physics_to_params">
<a class="viewcode-back" href="../../../_as_gen/radiation.synchrotron.SEDs.PowerLaw_SynchrotronSED.from_physics_to_params.html#radiation.synchrotron.SEDs.PowerLaw_SynchrotronSED.from_physics_to_params">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_physics_to_params</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">B</span><span class="p">:</span> <span class="s2">&quot;_UnitBearingScalarLike&quot;</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="s2">&quot;_UnitBearingScalarLike&quot;</span><span class="p">,</span>
        <span class="n">D_L</span><span class="p">:</span> <span class="s2">&quot;_UnitBearingScalarLike&quot;</span><span class="p">,</span>
        <span class="n">gamma_min</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">gamma_max</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
        <span class="n">p</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.5</span><span class="p">,</span>
        <span class="n">epsilon_E</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">epsilon_B</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">pitch_average</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct phenomenological SED parameters from physical model parameters.</span>

<span class="sd">        This is the **public, unit-aware interface** to the equipartition-based</span>
<span class="sd">        closure relation implemented by</span>
<span class="sd">        :meth:`_opt_from_physics_to_params`. It maps physical quantities describing</span>
<span class="sd">        the emitting region and electron population onto the parameters defining</span>
<span class="sd">        the canonical power-law synchrotron SED.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        B : scalar or quantity</span>
<span class="sd">            Magnetic field strength in the emitting region. Must be convertible</span>
<span class="sd">            to Gauss.</span>
<span class="sd">        V : scalar or quantity</span>
<span class="sd">            Effective emitting volume. Must be convertible to cm³.</span>
<span class="sd">            This is often parameterized in terms of a filling factor.</span>
<span class="sd">        D_L : scalar or quantity</span>
<span class="sd">            Luminosity distance to the source. Must be convertible to cm.</span>
<span class="sd">        gamma_min : float</span>
<span class="sd">            Minimum electron Lorentz factor :math:`\gamma_{\min}`.</span>
<span class="sd">        gamma_max : float, optional</span>
<span class="sd">            Maximum electron Lorentz factor :math:`\gamma_{\max}`.</span>
<span class="sd">            The default corresponds to no upper cutoff.</span>
<span class="sd">        p : float, optional</span>
<span class="sd">            Power-law index of the injected electron energy distribution.</span>
<span class="sd">        epsilon_E : float, optional</span>
<span class="sd">            Fraction of post-shock internal energy carried by relativistic electrons.</span>
<span class="sd">        epsilon_B : float, optional</span>
<span class="sd">            Fraction of post-shock internal energy stored in magnetic fields.</span>
<span class="sd">        alpha : float, optional</span>
<span class="sd">            Electron pitch angle in radians. Ignored if ``pitch_average=True``.</span>
<span class="sd">        pitch_average : bool, optional</span>
<span class="sd">            If ``True``, use pitch-angle averaged synchrotron emissivity.</span>
<span class="sd">            Otherwise, use a fixed pitch angle specified by ``alpha``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        params : dict</span>
<span class="sd">            Dictionary containing the phenomenological SED parameters:</span>

<span class="sd">            - ``F_norm`` : Peak flux density :math:`F_{\nu,\mathrm{pk}}`</span>
<span class="sd">              with units of ``erg cm^-2 s^-1 Hz^-1``.</span>
<span class="sd">            - ``nu_m`` : Injection (peak) frequency :math:`\nu_m` with units of Hz.</span>
<span class="sd">            - ``nu_max`` : Maximum synchrotron frequency :math:`\nu_{\max}` with</span>
<span class="sd">              units of Hz.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This method assumes a single-zone, homogeneous emitting region.</span>
<span class="sd">        - Equipartition is an **assumption**, not a physical necessity.</span>
<span class="sd">        - This method does not check for radiative cooling or synchrotron</span>
<span class="sd">          self-absorption; those effects are handled by specialized SED subclasses.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        _opt_from_physics_to_params :</span>
<span class="sd">            Log-space implementation of the closure relation.</span>
<span class="sd">        sed :</span>
<span class="sd">            Evaluate the synchrotron SED using the returned parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Enforce units</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">ensure_in_units</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="s2">&quot;G&quot;</span><span class="p">)</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">ensure_in_units</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="s2">&quot;cm^3&quot;</span><span class="p">)</span>
        <span class="n">D_L</span> <span class="o">=</span> <span class="n">ensure_in_units</span><span class="p">(</span><span class="n">D_L</span><span class="p">,</span> <span class="s2">&quot;cm&quot;</span><span class="p">)</span>

        <span class="c1"># Convert to log-space</span>
        <span class="n">log_B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
        <span class="n">log_V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
        <span class="n">log_D_L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">D_L</span><span class="p">)</span>
        <span class="n">log_gamma_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">gamma_min</span><span class="p">)</span>
        <span class="n">log_gamma_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">gamma_max</span><span class="p">)</span>

        <span class="c1"># Dispatch to optimized log-space closure</span>
        <span class="n">params_log</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_opt_from_physics_to_params</span><span class="p">(</span>
            <span class="n">log_B</span><span class="o">=</span><span class="n">log_B</span><span class="p">,</span>
            <span class="n">log_V</span><span class="o">=</span><span class="n">log_V</span><span class="p">,</span>
            <span class="n">log_D_L</span><span class="o">=</span><span class="n">log_D_L</span><span class="p">,</span>
            <span class="n">log_gamma_min</span><span class="o">=</span><span class="n">log_gamma_min</span><span class="p">,</span>
            <span class="n">log_gamma_max</span><span class="o">=</span><span class="n">log_gamma_max</span><span class="p">,</span>
            <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span>
            <span class="n">epsilon_E</span><span class="o">=</span><span class="n">epsilon_E</span><span class="p">,</span>
            <span class="n">epsilon_B</span><span class="o">=</span><span class="n">epsilon_B</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
            <span class="n">pitch_average</span><span class="o">=</span><span class="n">pitch_average</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Convert back to physical units</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;F_norm&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">params_log</span><span class="p">[</span><span class="s2">&quot;log_F_norm&quot;</span><span class="p">])</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">erg</span> <span class="o">/</span> <span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">cm</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">s</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">Hz</span><span class="p">),</span>
            <span class="s2">&quot;nu_m&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">params_log</span><span class="p">[</span><span class="s2">&quot;log_nu_m&quot;</span><span class="p">])</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">Hz</span><span class="p">,</span>
            <span class="s2">&quot;nu_max&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">params_log</span><span class="p">[</span><span class="s2">&quot;log_nu_max&quot;</span><span class="p">])</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">Hz</span><span class="p">,</span>
        <span class="p">}</span></div>
</div>



<div class="viewcode-block" id="PowerLaw_Cooling_SSA_SynchrotronSED">
<a class="viewcode-back" href="../../../_as_gen/radiation.synchrotron.SEDs.PowerLaw_Cooling_SSA_SynchrotronSED.html#radiation.synchrotron.SEDs.PowerLaw_Cooling_SSA_SynchrotronSED">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">PowerLaw_Cooling_SSA_SynchrotronSED</span><span class="p">(</span><span class="n">MultiSpectrumSynchrotronSED</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Synchrotron spectral energy distribution with cooling and self-absorption.</span>

<span class="sd">    This class implements the **full piecewise synchrotron spectrum** for a</span>
<span class="sd">    power-law electron population, including:</span>

<span class="sd">    - Radiative cooling (fast, slow, and non-cooling regimes),</span>
<span class="sd">    - Synchrotron self-absorption (SSA),</span>
<span class="sd">    - Stratified SSA corrections where applicable,</span>
<span class="sd">    - A high-frequency exponential cutoff.</span>

<span class="sd">    The implementation follows the standard GRB / supernova afterglow</span>
<span class="sd">    formalism (e.g. :footcite:t:`GranotSari2002SpectralBreaks`, :footcite:t:`2020MNRAS.493.3521B`,</span>
<span class="sd">    :footcite:t:`duran2013radius`, :footcite:t:`2025ApJ...992L..18S`, :footcite:t:`GaoSynchrotronReview2013`,</span>
<span class="sd">    etc.)</span>

<span class="sd">    Specifically we implement spectra using **log-space SED surgery** with scale-free smoothed broken</span>
<span class="sd">    power laws (SFBPLs). The spectrum is assembled by:</span>

<span class="sd">    1. Determining the **global spectral regime** from characteristic frequencies,</span>
<span class="sd">    2. Computing any **derived break frequencies** required by that regime,</span>
<span class="sd">    3. Dispatching to a **regime-specific optimized kernel**,</span>
<span class="sd">    4. Applying an overall normalization via the peak flux density.</span>

<span class="sd">    .. hint::</span>

<span class="sd">        For a detailed derivation of the spectral segments and break orderings, see</span>
<span class="sd">        :ref:`synchrotron_theory` and :ref:`synch_sed_theory`.</span>

<span class="sd">    .. rubric:: Spectral Structure</span>

<span class="sd">    The SED is globally classified into one of several discrete regimes based on</span>
<span class="sd">    the ordering of the characteristic frequencies:</span>

<span class="sd">    - Injection frequency :math:`\nu_m`,</span>
<span class="sd">    - Cooling frequency :math:`\nu_c`,</span>
<span class="sd">    - Self-absorption frequency :math:`\nu_a` (computed internally),</span>
<span class="sd">    - Maximum synchrotron frequency :math:`\nu_{\max}`.</span>

<span class="sd">    Each regime corresponds to a specific ordering (e.g.</span>
<span class="sd">    :math:`\nu_a &lt; \nu_c &lt; \nu_m &lt; \nu_{\max}`) and therefore to a unique set of</span>
<span class="sd">    spectral slopes. The regime selection is **global** and does not depend on the</span>
<span class="sd">    frequency grid used for evaluation. As such, when the SED is called, the parameters</span>
<span class="sd">    are used once to determine the regime and then to evaluate the SED at all requested frequencies.</span>

<span class="sd">    .. rubric:: SED Parameters</span>

<span class="sd">    The parameters entering this SED fall into three conceptual categories.</span>

<span class="sd">    .. tab-set::</span>

<span class="sd">        .. tab-item:: Free parameters (phenomenological)</span>

<span class="sd">            These parameters define the observable structure of the SED and are</span>
<span class="sd">            typically inferred directly from data.</span>

<span class="sd">            .. list-table::</span>
<span class="sd">                :widths: 25 15 60</span>
<span class="sd">                :header-rows: 1</span>

<span class="sd">                * - Parameter</span>
<span class="sd">                  - Symbol</span>
<span class="sd">                  - Description</span>
<span class="sd">                * - Peak flux density</span>
<span class="sd">                  - :math:`F_{\nu,\mathrm{norm}}`</span>
<span class="sd">                  - The equivalent flux at the dominant electron frequency in</span>
<span class="sd">                    an optically thin medium. This sets the SED peak. :meth:`from_physics_to_params` maps</span>
<span class="sd">                    physical parameters onto this quantity.</span>
<span class="sd">                * - Injection frequency</span>
<span class="sd">                  - :math:`\nu_m`</span>
<span class="sd">                  - Synchrotron frequency of minimum-energy electrons</span>
<span class="sd">                * - Cooling frequency</span>
<span class="sd">                  - :math:`\nu_c`</span>
<span class="sd">                  - Frequency corresponding to the cooling Lorentz factor</span>
<span class="sd">                * - Maximum frequency</span>
<span class="sd">                  - :math:`\nu_{\max}`</span>
<span class="sd">                  - High-energy cutoff frequency</span>
<span class="sd">                * - (Optional) stratified SSA frequency</span>
<span class="sd">                  - :math:`\nu_{ac}`</span>
<span class="sd">                  - Transition frequency for stratified SSA regimes</span>

<span class="sd">        .. tab-item:: Hyper-parameters</span>

<span class="sd">            These parameters control the *shape* and smoothness of the spectrum</span>
<span class="sd">            but are not usually directly inferred from broadband data.</span>

<span class="sd">            .. list-table::</span>
<span class="sd">                :widths: 25 15 60</span>
<span class="sd">                :header-rows: 1</span>

<span class="sd">                * - Parameter</span>
<span class="sd">                  - Symbol</span>
<span class="sd">                  - Description</span>
<span class="sd">                * - Electron power-law index</span>
<span class="sd">                  - :math:`p`</span>
<span class="sd">                  - Index of the injected electron distribution</span>
<span class="sd">                * - Smoothing parameter</span>
<span class="sd">                  - :math:`s`</span>
<span class="sd">                  - Controls sharpness of spectral breaks</span>
<span class="sd">                * - Emission solid angle</span>
<span class="sd">                  - :math:`\Omega`</span>
<span class="sd">                  - Effective emitting area divided by distance squared</span>
<span class="sd">                * - Minimum Lorentz factor</span>
<span class="sd">                  - :math:`\gamma_m`</span>
<span class="sd">                  - Minimum electron Lorentz factor</span>

<span class="sd">        .. tab-item:: Derived parameters (internal)</span>

<span class="sd">            These quantities are **not user inputs**, but are computed internally</span>
<span class="sd">            from the free parameters and microphysical assumptions.</span>

<span class="sd">            .. list-table::</span>
<span class="sd">                :widths: 25 15 60</span>
<span class="sd">                :header-rows: 1</span>

<span class="sd">                * - Parameter</span>
<span class="sd">                  - Symbol</span>
<span class="sd">                  - Description</span>
<span class="sd">                * - SSA frequency</span>
<span class="sd">                  - :math:`\nu_a`</span>
<span class="sd">                  - Self-absorption break frequency</span>
<span class="sd">                * - Cooling regime</span>
<span class="sd">                  - —</span>
<span class="sd">                  - Fast, slow, or non-cooling classification</span>
<span class="sd">                * - Regime identifier</span>
<span class="sd">                  - —</span>
<span class="sd">                  - Discrete index selecting the SED kernel</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :class:`SynchrotronSED` : Base class for synchrotron SED implementations.</span>
<span class="sd">    :class:`MultiSpectrumSynchrotronSED` : Base class for multi-regime synchrotron SEDs.</span>
<span class="sd">    :class:`PowerLaw_Cooling_SynchrotronSED` : Synchrotron SED with cooling break.</span>
<span class="sd">    :class:`PowerLaw_SSA_SynchrotronSED` : Synchrotron SED with synchrotron self-absorption.</span>
<span class="sd">    :class:`PowerLaw_SynchrotronSED` : Canonical optically-thin power-law synchrotron SED.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. footbibliography::</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ============================================================ #</span>
    <span class="c1"># Declare the spectrum functions mapping                       #</span>
    <span class="c1"># ============================================================ #</span>
    <span class="c1"># These are the synchrotron SED functions with SSA and cooling. We use</span>
    <span class="c1"># this enum class to trace through the runtime which regime we&#39;re in.</span>
    <span class="n">SPECTRUM_FUNCTIONS</span> <span class="o">=</span> <span class="n">_SynchrotronSSACoolingSEDFunctions</span>

    <span class="c1"># ============================================================ #</span>
    <span class="c1"># Regime Management                                            #</span>
    <span class="c1"># ============================================================ #</span>
    <span class="c1"># Regime management in this class is non-trivial as the SSA frequency</span>
    <span class="c1"># must be self-consistently computed from the other parameters for each</span>
    <span class="c1"># regime. This requires some careful bookkeeping. We implement this in the</span>
    <span class="c1"># _compute_sed_regime method below.</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_ssa_frequencies_from_F_norm</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">log_F_norm</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_nu_m</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_nu_c</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_nu_max</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_omega</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_gamma_m</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">p</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">3.0</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="n">_SynchrotronSSACoolingSEDFunctions</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute candidate self-absorption frequencies using anchored spectral normalizations.</span>

<span class="sd">        This method evaluates analytic expressions for the synchrotron self-absorption</span>
<span class="sd">        frequency :math:`\nu_a` for all spectral regimes compatible with the system’s</span>
<span class="sd">        cooling state, **using explicit spectral normalizations** rather than a single</span>
<span class="sd">        peak flux density.</span>

<span class="sd">        Unlike :meth:`_compute_ssa_frequencies_from_F_peak`, which assumes the supplied</span>
<span class="sd">        flux normalization corresponds to the *true spectral peak*, this method allows</span>
<span class="sd">        the spectrum to be anchored at a **specific characteristic frequency**, typically:</span>

<span class="sd">        - :math:`\nu_m` (slow-cooling or non-cooling regimes), or</span>
<span class="sd">        - :math:`\nu_c` (fast-cooling regimes).</span>

<span class="sd">        This distinction is essential when the dominant emitting electron population</span>
<span class="sd">        does *not* coincide with the observed spectral peak, such as in fast-cooling</span>
<span class="sd">        or heavily self-absorbed scenarios.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        log_F_norm : float</span>
<span class="sd">            Natural logarithm of the flux normalization.</span>
<span class="sd">        log_nu_m : float</span>
<span class="sd">            Natural logarithm of the injection frequency :math:`\nu_m`.</span>
<span class="sd">        log_nu_c : float</span>
<span class="sd">            Natural logarithm of the cooling frequency :math:`\nu_c`.</span>
<span class="sd">        log_nu_max : float</span>
<span class="sd">            Natural logarithm of the maximum synchrotron frequency</span>
<span class="sd">            :math:`\nu_{\max}`.</span>
<span class="sd">        log_omega : float</span>
<span class="sd">            Natural logarithm of the effective emission solid angle</span>
<span class="sd">            :math:`\log \Omega`.</span>
<span class="sd">        log_gamma_m : float</span>
<span class="sd">            Natural logarithm of the minimum electron Lorentz factor</span>
<span class="sd">            :math:`\log \gamma_m`.</span>
<span class="sd">        p : float, optional</span>
<span class="sd">            Power-law index of the injected electron distribution.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            A tuple ``(log_nu_a_dict, cooling_regime)`` where:</span>

<span class="sd">            - ``log_nu_a_dict`` maps each candidate spectral regime to its corresponding</span>
<span class="sd">              self-absorption frequency :math:`\log \nu_a`, computed under the assumption</span>
<span class="sd">              that *that regime applies*.</span>
<span class="sd">            - ``cooling_regime`` is an integer flag indicating the cooling state:</span>
<span class="sd">              ``0`` = fast cooling,</span>
<span class="sd">              ``1`` = slow cooling,</span>
<span class="sd">              ``2`` = no cooling.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This method is required for **physically correct normalization** in regimes</span>
<span class="sd">          where the spectral peak does not coincide with :math:`\nu_m`.</span>
<span class="sd">        - Only regimes compatible with the inferred cooling state are included.</span>
<span class="sd">        - The returned self-absorption frequencies are **candidates**; the final regime</span>
<span class="sd">          selection and consistency check are performed by</span>
<span class="sd">          :meth:`_compute_sed_regime`.</span>
<span class="sd">        - All calculations are performed in **logarithmic CGS units** and assume</span>
<span class="sd">          isotropic pitch-angle distributions.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        _compute_ssa_frequencies_from_F_peak :</span>
<span class="sd">            Simplified SSA computation assuming the supplied normalization corresponds</span>
<span class="sd">            to the true spectral peak.</span>
<span class="sd">        _compute_sed_regime :</span>
<span class="sd">            Final regime selection and SSA consistency enforcement.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Pre-compute the common factor so that we do not need to recompute it.</span>
        <span class="n">log_Q</span> <span class="o">=</span> <span class="n">log_F_norm</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">electron_rest_mass_cgs</span><span class="p">)</span> <span class="o">-</span> <span class="n">log_omega</span> <span class="o">-</span> <span class="n">log_gamma_m</span>
        <span class="n">log_Q_c</span> <span class="o">=</span> <span class="n">log_Q</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">log_nu_m</span> <span class="o">-</span> <span class="n">log_nu_c</span><span class="p">)</span>

        <span class="c1"># We&#39;ll want to quickly check if we are fast, slow, or non-cooling. This will</span>
        <span class="c1"># narrow down the scenarios we need to consider and the corresponding construction</span>
        <span class="c1"># of the relevant SSA frequencies.</span>
        <span class="k">if</span> <span class="n">log_nu_c</span> <span class="o">&lt;</span> <span class="n">log_nu_m</span><span class="p">:</span>
            <span class="c1"># This is fast cooling. We have access to S5, S6, and S7 only.</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_5</span><span class="p">:</span> <span class="p">(</span><span class="mi">6</span> <span class="o">*</span> <span class="n">log_Q_c</span> <span class="o">/</span> <span class="mi">13</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">log_nu_m</span> <span class="o">/</span> <span class="mi">13</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">log_nu_c</span> <span class="o">/</span> <span class="mi">13</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_6</span><span class="p">:</span> <span class="p">(</span><span class="n">log_Q_c</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">log_nu_m</span> <span class="o">/</span> <span class="mi">6</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">log_nu_c</span> <span class="o">/</span> <span class="mi">6</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_7</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">log_Q</span> <span class="o">/</span> <span class="p">(</span><span class="mi">5</span> <span class="o">+</span> <span class="n">p</span><span class="p">))</span>
                <span class="o">+</span> <span class="p">(</span><span class="n">log_nu_c</span> <span class="o">/</span> <span class="p">(</span><span class="mi">5</span> <span class="o">+</span> <span class="n">p</span><span class="p">))</span>
                <span class="o">+</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="n">log_nu_m</span> <span class="o">/</span> <span class="p">(</span><span class="mi">5</span> <span class="o">+</span> <span class="n">p</span><span class="p">)),</span>
            <span class="p">},</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">log_nu_m</span> <span class="o">&lt;</span> <span class="n">log_nu_c</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">log_nu_c</span> <span class="o">&lt;</span> <span class="n">log_nu_max</span><span class="p">):</span>
            <span class="c1"># This is slow cooling with nu_c &lt; nu_max. We have access to S3 and S4 and S7 only.</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_3</span><span class="p">:</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">log_Q</span> <span class="o">/</span> <span class="mi">5</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">log_nu_m</span> <span class="o">/</span> <span class="mi">5</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_4</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">log_Q</span> <span class="o">/</span> <span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">4</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="n">log_nu_m</span> <span class="o">/</span> <span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_7</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">log_Q</span> <span class="o">/</span> <span class="p">(</span><span class="mi">5</span> <span class="o">+</span> <span class="n">p</span><span class="p">))</span>
                <span class="o">+</span> <span class="p">(</span><span class="n">log_nu_c</span> <span class="o">/</span> <span class="p">(</span><span class="mi">5</span> <span class="o">+</span> <span class="n">p</span><span class="p">))</span>
                <span class="o">+</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="n">log_nu_m</span> <span class="o">/</span> <span class="p">(</span><span class="mi">5</span> <span class="o">+</span> <span class="n">p</span><span class="p">)),</span>
            <span class="p">},</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># This is the NO COOLING case. We have access to S1 and S2 only.</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_1</span><span class="p">:</span> <span class="p">(</span><span class="mi">6</span> <span class="o">*</span> <span class="n">log_Q</span> <span class="o">/</span> <span class="mi">13</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">log_nu_m</span> <span class="o">/</span> <span class="mi">13</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_2</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">log_Q</span> <span class="o">/</span> <span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">4</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="n">log_nu_m</span> <span class="o">/</span> <span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)),</span>
            <span class="p">},</span> <span class="mi">2</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_sed_regime_from_nu_a_dict</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">log_nu_ssa</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">_SynchrotronSSACoolingSEDFunctions</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
        <span class="n">cooling_regime</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">log_nu_m</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_nu_c</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_nu_max</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select the unique synchrotron spectral regime from candidate SSA frequencies.</span>

<span class="sd">        This method determines the **single, globally applicable synchrotron spectral</span>
<span class="sd">        regime** by comparing candidate self-absorption frequencies against the</span>
<span class="sd">        characteristic synchrotron break frequencies.</span>

<span class="sd">        The input ``log_nu_ssa`` contains **candidate self-absorption frequencies**</span>
<span class="sd">        appropriate to each allowed spectral regime, computed analytically under the</span>
<span class="sd">        assumption that *that regime applies*. This method resolves that ambiguity by</span>
<span class="sd">        enforcing the correct ordering of frequencies.</span>

<span class="sd">        The selection logic depends on the cooling state:</span>

<span class="sd">        - **Fast cooling** (:math:`\nu_c &lt; \nu_m`): choose among spectra S5, S6, S7</span>
<span class="sd">        - **Slow cooling** (:math:`\nu_m &lt; \nu_c &lt; \nu_{\max}`): choose among S3, S4, S7</span>
<span class="sd">        - **No cooling** (:math:`\nu_c &gt; \nu_{\max}`): choose among S1, S2</span>

<span class="sd">        We implement this so that we do not need to replicate the entire regime determination</span>
<span class="sd">        workflow in each SED evaluation. Instead, we compute all candidate SSA frequencies</span>
<span class="sd">        once, then use this method to select the correct one based on the physical</span>
<span class="sd">        parameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        log_nu_ssa : dict</span>
<span class="sd">            Dictionary mapping candidate spectral regimes to their corresponding</span>
<span class="sd">            self-absorption frequencies :math:`\log \nu_a`, computed under the</span>
<span class="sd">            assumption that each regime applies.</span>
<span class="sd">        cooling_regime : int</span>
<span class="sd">            Cooling classification flag:</span>
<span class="sd">            ``0`` = fast cooling,</span>
<span class="sd">            ``1`` = slow cooling,</span>
<span class="sd">            ``2`` = no cooling.</span>
<span class="sd">        log_nu_m : float</span>
<span class="sd">            Natural logarithm of the injection frequency :math:`\nu_m`.</span>
<span class="sd">        log_nu_c : float</span>
<span class="sd">            Natural logarithm of the cooling frequency :math:`\nu_c`.</span>
<span class="sd">        log_nu_max : float</span>
<span class="sd">            Natural logarithm of the maximum synchrotron frequency :math:`\nu_{\max}`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            ``(regime, log_nu_a)`` where:</span>

<span class="sd">            - ``regime`` is a member of</span>
<span class="sd">              :class:`~_SynchrotronSSACoolingSEDFunctions` identifying the selected</span>
<span class="sd">              spectral configuration.</span>
<span class="sd">            - ``log_nu_a`` is the self-absorption frequency consistent with that regime.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        RuntimeError</span>
<span class="sd">            If no candidate regime satisfies the required frequency ordering.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Exactly **one** regime must satisfy the ordering constraints.</span>
<span class="sd">        - This method performs no numerical approximations—only logical selection.</span>
<span class="sd">        - The selected regime applies **globally** to the SED.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># For debugging, we take a minute here to log some detailed information</span>
        <span class="c1"># about the candidate SSA frequencies and the characteristic frequencies. This can be</span>
        <span class="c1"># helpful for diagnosing regime selection issues and ensuring that the logic is working as intended.</span>
        <span class="c1">#</span>
        <span class="c1"># This should not interfere with performance in production as it is gated behind a debug-level log check,</span>
        <span class="c1"># but it provides a valuable window into the internal decision-making process when enabled.</span>
        <span class="k">if</span> <span class="n">triceratops_logger</span><span class="o">.</span><span class="n">isEnabledFor</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">):</span>
            <span class="n">triceratops_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;PowerLaw_Cooling_SSA_SynchrotronSED: performing regime determination step:&quot;</span><span class="p">,</span>
                <span class="n">extra</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;cooling_regime&quot;</span><span class="p">:</span> <span class="n">cooling_regime</span><span class="p">,</span>
                    <span class="s2">&quot;log_nu_m&quot;</span><span class="p">:</span> <span class="n">log_nu_m</span><span class="p">,</span>
                    <span class="s2">&quot;log_nu_c&quot;</span><span class="p">:</span> <span class="n">log_nu_c</span><span class="p">,</span>
                    <span class="s2">&quot;log_nu_max&quot;</span><span class="p">:</span> <span class="n">log_nu_max</span><span class="p">,</span>
                    <span class="s2">&quot;log_nu_ssa&quot;</span><span class="p">:</span> <span class="n">log_nu_ssa</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">cooling_regime</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Fast cooling: S5, S6, or S7</span>
            <span class="k">if</span> <span class="n">log_nu_ssa</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_5</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">log_nu_c</span><span class="p">:</span>
                <span class="c1"># We get the 2, 11/8, 1/3, -1/2, -p/2 spectrum.</span>
                <span class="n">regime</span><span class="p">,</span> <span class="n">log_nu_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_5</span><span class="p">,</span> <span class="n">log_nu_ssa</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_5</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">log_nu_ssa</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_7</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">log_nu_m</span><span class="p">:</span>
                <span class="c1"># This is the moderate fast cooling case with extreme absorption nu_c &lt; nu_m &lt; nu_a &lt; nu_max.</span>
                <span class="n">regime</span><span class="p">,</span> <span class="n">log_nu_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_7</span><span class="p">,</span> <span class="n">log_nu_ssa</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_7</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">log_nu_ssa</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_6</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">log_nu_m</span><span class="p">:</span>
                <span class="c1"># This is the intermediate fast cooling case with nu_c &lt; nu_a &lt; nu_m &lt; nu_max.</span>
                <span class="c1"># NOTE: the catch on nu_c above allows us to avoid ambiguity with the extreme fast cooling case.</span>
                <span class="n">regime</span><span class="p">,</span> <span class="n">log_nu_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_6</span><span class="p">,</span> <span class="n">log_nu_ssa</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_6</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;Could not determine regime in fast cooling scenario:</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;  log_nu_c          = </span><span class="si">{</span><span class="n">log_nu_c</span><span class="si">:</span><span class="s2">0.3f</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;  log_nu_m          = </span><span class="si">{</span><span class="n">log_nu_m</span><span class="si">:</span><span class="s2">0.3f</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;  log_nu_max        = </span><span class="si">{</span><span class="n">log_nu_max</span><span class="si">:</span><span class="s2">0.3f</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;  log_nu_a (S5)     = </span><span class="si">{</span><span class="n">log_nu_ssa</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_5</span><span class="p">]</span><span class="si">:</span><span class="s2">0.3f</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;  log_nu_a (S6)     = </span><span class="si">{</span><span class="n">log_nu_ssa</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_6</span><span class="p">]</span><span class="si">:</span><span class="s2">0.3f</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;  log_nu_a (S7)     = </span><span class="si">{</span><span class="n">log_nu_ssa</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_7</span><span class="p">]</span><span class="si">:</span><span class="s2">0.3f</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Slow cooling: S3 or S4</span>
        <span class="k">elif</span> <span class="n">cooling_regime</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">log_nu_ssa</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_3</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">log_nu_m</span><span class="p">:</span>
                <span class="c1"># This is the optically thin at peak slow cooling case with nu_a &lt; nu_m &lt; nu_c &lt; nu_max.</span>
                <span class="n">regime</span><span class="p">,</span> <span class="n">log_nu_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_3</span><span class="p">,</span> <span class="n">log_nu_ssa</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_3</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">log_nu_ssa</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_4</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">log_nu_c</span><span class="p">:</span>
                <span class="c1"># This is the case where nu_m &lt; nu_a &lt; nu_c &lt; nu_max. Note that we catch nu_a &lt; nu_m above.</span>
                <span class="n">regime</span><span class="p">,</span> <span class="n">log_nu_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_4</span><span class="p">,</span> <span class="n">log_nu_ssa</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_4</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">log_nu_ssa</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_7</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">log_nu_c</span><span class="p">:</span>
                <span class="c1"># This is the extreme case where nu_m &lt; nu_c &lt; nu_a &lt; nu_max and the cooling break is hidden.</span>
                <span class="n">regime</span><span class="p">,</span> <span class="n">log_nu_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_7</span><span class="p">,</span> <span class="n">log_nu_ssa</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_7</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;Could not determine regime in slow cooling scenario:</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;  log_nu_c          = </span><span class="si">{</span><span class="n">log_nu_c</span><span class="si">:</span><span class="s2">0.3f</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;  log_nu_m          = </span><span class="si">{</span><span class="n">log_nu_m</span><span class="si">:</span><span class="s2">0.3f</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;  log_nu_max        = </span><span class="si">{</span><span class="n">log_nu_max</span><span class="si">:</span><span class="s2">0.3f</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;  log_nu_a (S3)     = </span><span class="si">{</span><span class="n">log_nu_ssa</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_3</span><span class="p">]</span><span class="si">:</span><span class="s2">0.3f</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;  log_nu_a (S4)     = </span><span class="si">{</span><span class="n">log_nu_ssa</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_4</span><span class="p">]</span><span class="si">:</span><span class="s2">0.3f</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;  log_nu_a (S7)     = </span><span class="si">{</span><span class="n">log_nu_ssa</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_7</span><span class="p">]</span><span class="si">:</span><span class="s2">0.3f</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="c1"># No cooling: S1 or S2</span>
        <span class="k">elif</span> <span class="n">cooling_regime</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">log_nu_ssa</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">log_nu_m</span><span class="p">:</span>
                <span class="c1"># This is the optically thin at peak no cooling case with nu_a &lt; nu_m &lt; nu_max.</span>
                <span class="n">regime</span><span class="p">,</span> <span class="n">log_nu_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_1</span><span class="p">,</span> <span class="n">log_nu_ssa</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">log_nu_ssa</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">log_nu_m</span><span class="p">:</span>
                <span class="c1"># This is the extreme case where nu_m &lt; nu_a &lt; nu_max.</span>
                <span class="n">regime</span><span class="p">,</span> <span class="n">log_nu_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_2</span><span class="p">,</span> <span class="n">log_nu_ssa</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_2</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;Could not determine regime in no cooling scenario:</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;  log_nu_m          = </span><span class="si">{</span><span class="n">log_nu_m</span><span class="si">:</span><span class="s2">0.3f</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;  log_nu_max        = </span><span class="si">{</span><span class="n">log_nu_max</span><span class="si">:</span><span class="s2">0.3f</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;  log_nu_c          = </span><span class="si">{</span><span class="n">log_nu_c</span><span class="si">:</span><span class="s2">0.3f</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;  log_nu_a (S1)     = </span><span class="si">{</span><span class="n">log_nu_ssa</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_1</span><span class="p">]</span><span class="si">:</span><span class="s2">0.3f</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;  log_nu_a (S2)     = </span><span class="si">{</span><span class="n">log_nu_ssa</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_2</span><span class="p">]</span><span class="si">:</span><span class="s2">0.3f</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Unable to determine SSA spectrum regime: unrecognized cooling regime.&quot;</span><span class="p">)</span>

        <span class="c1"># Now complete, log that we have completed the step, and return.</span>
        <span class="k">if</span> <span class="n">triceratops_logger</span><span class="o">.</span><span class="n">isEnabledFor</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">):</span>
            <span class="n">triceratops_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;PowerLaw_Cooling_SSA_SynchrotronSED: selected regime.&quot;</span><span class="p">,</span>
                <span class="n">extra</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;cooling_regime&quot;</span><span class="p">:</span> <span class="n">cooling_regime</span><span class="p">,</span>
                    <span class="s2">&quot;log_nu_m&quot;</span><span class="p">:</span> <span class="n">log_nu_m</span><span class="p">,</span>
                    <span class="s2">&quot;log_nu_c&quot;</span><span class="p">:</span> <span class="n">log_nu_c</span><span class="p">,</span>
                    <span class="s2">&quot;log_nu_max&quot;</span><span class="p">:</span> <span class="n">log_nu_max</span><span class="p">,</span>
                    <span class="s2">&quot;log_nu_ssa&quot;</span><span class="p">:</span> <span class="n">log_nu_a</span><span class="p">,</span>
                    <span class="s2">&quot;regime&quot;</span><span class="p">:</span> <span class="n">regime</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">regime</span><span class="p">,</span> <span class="n">log_nu_a</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_sed_regime</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">log_F_norm</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_nu_m</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_nu_c</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_nu_max</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_omega</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_gamma_m</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">p</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">3.0</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine the synchrotron spectral regime and SSA frequency.</span>

<span class="sd">        This low-level method classifies the synchrotron spectrum into a **single,</span>
<span class="sd">        global spectral regime** based on the ordering of the characteristic</span>
<span class="sd">        frequencies and returns both:</span>

<span class="sd">        1. A discrete **regime identifier**, and</span>
<span class="sd">        2. The corresponding **self-absorption frequency** :math:`\nu_a`</span>
<span class="sd">           appropriate to that regime.</span>

<span class="sd">        The classification proceeds in two stages:</span>

<span class="sd">        1. Determine whether the system is **fast-cooling**, **slow-cooling**, or</span>
<span class="sd">           **non-cooling** by comparing :math:`\nu_c` and :math:`\nu_m`.</span>
<span class="sd">        2. Within that cooling class, select the specific SSA spectrum by comparing</span>
<span class="sd">           the candidate self-absorption frequencies to :math:`\nu_m` and</span>
<span class="sd">           :math:`\nu_c`.</span>

<span class="sd">        All inputs and outputs are assumed to be in **natural logarithmic space**.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        log_F_norm : float</span>
<span class="sd">            Natural logarithm of the normalization flux density corresponding to the *optically thin* equivalent</span>
<span class="sd">            emission at the dominant electron frequency. See</span>
<span class="sd">            :ref:`sed_normalization` for details on how to determine the appropriate normalization.</span>
<span class="sd">        log_nu_m : float</span>
<span class="sd">            Natural logarithm of the injection frequency</span>
<span class="sd">            :math:`\log \nu_m`.</span>
<span class="sd">        log_nu_c : float</span>
<span class="sd">            Natural logarithm of the cooling frequency</span>
<span class="sd">            :math:`\log \nu_c`.</span>
<span class="sd">        log_nu_max : float</span>
<span class="sd">            Natural logarithm of the maximum synchrotron frequency</span>
<span class="sd">            :math:`\log \nu_{\max}`.</span>
<span class="sd">        log_omega : float</span>
<span class="sd">            Natural logarithm of the effective emission solid angle</span>
<span class="sd">            :math:`\log \Omega`.</span>
<span class="sd">        log_gamma_m : float</span>
<span class="sd">            Natural logarithm of the minimum electron Lorentz factor</span>
<span class="sd">            :math:`\log \gamma_m`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            A two-element tuple ``(regime, log_nu_a)`` where:</span>

<span class="sd">            - ``regime`` is a member of</span>
<span class="sd">              :class:`~_SynchrotronSSACoolingSEDFunctions` identifying the spectral</span>
<span class="sd">              branch to evaluate.</span>
<span class="sd">            - ``log_nu_a`` is the natural logarithm of the self-absorption frequency</span>
<span class="sd">              appropriate to that regime.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This method performs **no unit checking** and assumes all inputs are valid.</span>
<span class="sd">        - The returned regime applies **globally** to the spectrum.</span>
<span class="sd">        - Errors are raised if the frequency ordering is inconsistent with any</span>
<span class="sd">          supported spectral configuration.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Begin by calculating the SSA frequency from the other parameters. This also</span>
        <span class="c1"># tells some regime information. 0=Fast cooling, 1=Slow cooling, 2=No cooling.</span>
        <span class="n">log_nu_ssa</span><span class="p">,</span> <span class="n">cooling_regime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_ssa_frequencies_from_F_norm</span><span class="p">(</span>
            <span class="n">log_F_norm</span><span class="p">,</span> <span class="n">log_nu_m</span><span class="p">,</span> <span class="n">log_nu_c</span><span class="p">,</span> <span class="n">log_nu_max</span><span class="p">,</span> <span class="n">log_omega</span><span class="p">,</span> <span class="n">log_gamma_m</span><span class="p">,</span> <span class="n">p</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_sed_regime_from_nu_a_dict</span><span class="p">(</span>
            <span class="n">log_nu_ssa</span><span class="p">,</span>
            <span class="n">cooling_regime</span><span class="p">,</span>
            <span class="n">log_nu_m</span><span class="p">,</span>
            <span class="n">log_nu_c</span><span class="p">,</span>
            <span class="n">log_nu_max</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="PowerLaw_Cooling_SSA_SynchrotronSED.determine_sed_regime">
<a class="viewcode-back" href="../../../_as_gen/radiation.synchrotron.SEDs.PowerLaw_Cooling_SSA_SynchrotronSED.determine_sed_regime.html#radiation.synchrotron.SEDs.PowerLaw_Cooling_SSA_SynchrotronSED.determine_sed_regime">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">determine_sed_regime</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">F_norm</span><span class="p">:</span> <span class="s2">&quot;_UnitBearingScalarLike&quot;</span><span class="p">,</span>
        <span class="n">nu_m</span><span class="p">:</span> <span class="s2">&quot;_UnitBearingScalarLike&quot;</span><span class="p">,</span>
        <span class="n">nu_c</span><span class="p">:</span> <span class="s2">&quot;_UnitBearingScalarLike&quot;</span><span class="p">,</span>
        <span class="n">nu_max</span><span class="p">:</span> <span class="s2">&quot;_UnitBearingScalarLike&quot;</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
        <span class="n">omega</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">gamma_m</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine the synchrotron spectral regime from physical parameters.</span>

<span class="sd">        This is the **user-facing interface** for regime determination. It performs</span>
<span class="sd">        unit validation and coercion, converts all inputs to logarithmic CGS form,</span>
<span class="sd">        and dispatches to the optimized internal routine</span>
<span class="sd">        :meth:`_compute_sed_regime`.</span>

<span class="sd">        This method is intended for **diagnostic and introspection purposes** and</span>
<span class="sd">        does not compute the SED itself.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        F_norm : ~astropy.units.Quantity or float</span>
<span class="sd">            Normalization flux density corresponding to the *optically thin* equivalent</span>
<span class="sd">            emission at the dominant electron frequency. This should be a :class:`~astropy.units.Quantity`</span>
<span class="sd">            with units convertible to :math:`\mathrm{erg} \, \mathrm{cm}^{-2} \, \mathrm{s}^{-1} \, \mathrm{Hz}^{-1}`</span>
<span class="sd">            or a float in CGS units. See :ref:`sed_normalization` for details on how to determine the appropriate</span>
<span class="sd">            normalization.</span>
<span class="sd">        nu_m : ~astropy.units.Quantity or float</span>
<span class="sd">            Injection frequency :math:`\nu_m`. May be either a :class:`~astropy.units.Quantity`</span>
<span class="sd">            with units convertible to Hz or a float in CGS units.</span>
<span class="sd">        nu_c : ~astropy.units.Quantity or float</span>
<span class="sd">            Cooling frequency :math:`\nu_c`. May be either a :class:`~astropy.units.Quantity`</span>
<span class="sd">            with units convertible to Hz or a float in CGS units.</span>
<span class="sd">        nu_max : ~astropy.units.Quantity or float</span>
<span class="sd">            Maximum synchrotron frequency :math:`\nu_{\max}`. May be either a :class:`~astropy.units.Quantity`</span>
<span class="sd">            with units convertible to Hz or a float in CGS units. The default (``np.inf``) corresponds to no cutoff.</span>
<span class="sd">        omega : float</span>
<span class="sd">            Effective emission solid angle. This should be a floating-point number</span>
<span class="sd">            representing the ratio of the emitting area to the square of the distance</span>
<span class="sd">            to the observer (i.e. :math:`\Omega = A / D^2`).</span>
<span class="sd">        gamma_m : float</span>
<span class="sd">            Minimum electron Lorentz factor. This should be a dimensionless floating-point number.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        regime : callable</span>
<span class="sd">            A member of the :attr:`~PowerLaw_Cooling_SSA_SynchrotronSED.SPECTRUM_FUNCTIONS` enumeration identifying the</span>
<span class="sd">            applicable synchrotron spectral regime.</span>

<span class="sd">            Each enum member encodes a specific ordering of the characteristic</span>
<span class="sd">            synchrotron frequencies (e.g. :math:`\nu_a`, :math:`\nu_m`, :math:`\nu_c`,</span>
<span class="sd">            :math:`\nu_{\max}`) and uniquely determines the corresponding spectral</span>
<span class="sd">            structure.</span>

<span class="sd">            Enum members are **callable** and may be invoked to construct or dispatch</span>
<span class="sd">            the appropriate SED implementation, or to access regime-specific metadata</span>
<span class="sd">            such as break ordering and spectral slopes.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The returned regime applies **globally** to the SED.</span>
<span class="sd">        - This method does not depend on the frequency array ``nu``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Handle units and then coerce to log space</span>
        <span class="n">F_norm</span> <span class="o">=</span> <span class="n">ensure_in_units</span><span class="p">(</span><span class="n">F_norm</span><span class="p">,</span> <span class="s2">&quot;erg / (cm**2 * s * Hz)&quot;</span><span class="p">)</span>
        <span class="n">nu_m</span> <span class="o">=</span> <span class="n">ensure_in_units</span><span class="p">(</span><span class="n">nu_m</span><span class="p">,</span> <span class="s2">&quot;Hz&quot;</span><span class="p">)</span>
        <span class="n">nu_c</span> <span class="o">=</span> <span class="n">ensure_in_units</span><span class="p">(</span><span class="n">nu_c</span><span class="p">,</span> <span class="s2">&quot;Hz&quot;</span><span class="p">)</span>
        <span class="n">nu_max</span> <span class="o">=</span> <span class="n">ensure_in_units</span><span class="p">(</span><span class="n">nu_max</span><span class="p">,</span> <span class="s2">&quot;Hz&quot;</span><span class="p">)</span>

        <span class="c1"># Coerce to log space</span>
        <span class="n">log_F_peak</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">F_norm</span><span class="p">)</span>
        <span class="n">log_nu_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">nu_m</span><span class="p">)</span>
        <span class="n">log_nu_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">nu_c</span><span class="p">)</span>
        <span class="n">log_nu_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">nu_max</span><span class="p">)</span>
        <span class="n">log_omega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">omega</span><span class="p">)</span>
        <span class="n">log_gamma_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">gamma_m</span><span class="p">)</span>

        <span class="c1"># Dispatch to the low-level regime computation</span>
        <span class="n">regime</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_sed_regime</span><span class="p">(</span>
            <span class="n">log_F_norm</span><span class="o">=</span><span class="n">log_F_peak</span><span class="p">,</span>
            <span class="n">log_nu_m</span><span class="o">=</span><span class="n">log_nu_m</span><span class="p">,</span>
            <span class="n">log_nu_c</span><span class="o">=</span><span class="n">log_nu_c</span><span class="p">,</span>
            <span class="n">log_nu_max</span><span class="o">=</span><span class="n">log_nu_max</span><span class="p">,</span>
            <span class="n">log_omega</span><span class="o">=</span><span class="n">log_omega</span><span class="p">,</span>
            <span class="n">log_gamma_m</span><span class="o">=</span><span class="n">log_gamma_m</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">regime</span></div>


    <span class="c1"># ============================================================ #</span>
    <span class="c1"># Regime-Specific SED Kernel                                   #</span>
    <span class="c1"># ============================================================ #</span>
    <span class="c1"># noinspection PyCallingNonCallable</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_log_opt_sed_from_regime</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">regime</span><span class="p">:</span> <span class="n">_SynchrotronSSACoolingSEDFunctions</span><span class="p">,</span>
        <span class="n">log_nu</span><span class="p">:</span> <span class="s2">&quot;_ArrayLike&quot;</span><span class="p">,</span>
        <span class="n">log_nu_m</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_nu_a</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_nu_c</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_nu_max</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_F_norm</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_nu_ac</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">p</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">3.0</span><span class="p">,</span>
        <span class="n">s</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the log-space SED for a fixed spectral regime.</span>

<span class="sd">        This method dispatches to the **regime-specific numerical kernel**</span>
<span class="sd">        corresponding to the supplied regime identifier and applies the overall</span>
<span class="sd">        flux normalization.</span>

<span class="sd">        All branching logic on spectral shape is confined to this method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        regime : enum</span>
<span class="sd">            Spectral regime identifier from</span>
<span class="sd">            :class:`~_SynchrotronSSACoolingSEDFunctions`.</span>
<span class="sd">        log_nu : array-like</span>
<span class="sd">            Natural logarithm of the evaluation frequencies.</span>
<span class="sd">        log_nu_m, log_nu_a, log_nu_c, log_nu_max : float</span>
<span class="sd">            Natural logarithms of the characteristic frequencies.</span>
<span class="sd">        log_F_norm : float</span>
<span class="sd">            Natural logarithm of the flux normalization corresponding to the *optically thin* equivalent</span>
<span class="sd">            emission at the dominant electron frequency. See</span>
<span class="sd">            :ref:`sed_normalization` for details on how to determine the appropriate normalization.</span>
<span class="sd">        log_nu_ac : float, optional</span>
<span class="sd">            Natural logarithm of the stratified SSA transition frequency.</span>
<span class="sd">        p : float</span>
<span class="sd">            Electron power-law index.</span>
<span class="sd">        s : float</span>
<span class="sd">            Smoothing parameter for spectral breaks.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array-like</span>
<span class="sd">            Natural logarithm of the SED evaluated at ``log_nu``.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This method assumes the regime is **already validated**.</span>
<span class="sd">        - All SED kernels are evaluated in log-space for numerical stability.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Given that we have the regime, we can dispatch to the appropriate function.</span>
        <span class="k">if</span> <span class="n">regime</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">regime</span><span class="p">(</span><span class="n">log_nu</span><span class="p">,</span> <span class="n">log_nu_m</span><span class="p">,</span> <span class="n">log_nu_a</span><span class="p">,</span> <span class="n">log_nu_max</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="o">+</span> <span class="n">log_F_norm</span>
        <span class="k">elif</span> <span class="n">regime</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_2</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="n">regime</span><span class="p">(</span><span class="n">log_nu</span><span class="p">,</span> <span class="n">log_nu_m</span><span class="p">,</span> <span class="n">log_nu_a</span><span class="p">,</span> <span class="n">log_nu_max</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
                <span class="o">+</span> <span class="n">log_F_norm</span>
                <span class="o">-</span> <span class="p">((</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">log_nu_a</span> <span class="o">-</span> <span class="n">log_nu_m</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">regime</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_3</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">regime</span><span class="p">(</span><span class="n">log_nu</span><span class="p">,</span> <span class="n">log_nu_m</span><span class="p">,</span> <span class="n">log_nu_c</span><span class="p">,</span> <span class="n">log_nu_a</span><span class="p">,</span> <span class="n">log_nu_max</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="o">+</span> <span class="n">log_F_norm</span>
        <span class="k">elif</span> <span class="n">regime</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_4</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="n">regime</span><span class="p">(</span><span class="n">log_nu</span><span class="p">,</span> <span class="n">log_nu_m</span><span class="p">,</span> <span class="n">log_nu_c</span><span class="p">,</span> <span class="n">log_nu_a</span><span class="p">,</span> <span class="n">log_nu_max</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
                <span class="o">+</span> <span class="n">log_F_norm</span>
                <span class="o">-</span> <span class="p">((</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">log_nu_a</span> <span class="o">-</span> <span class="n">log_nu_m</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">regime</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_5</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">regime</span><span class="p">(</span><span class="n">log_nu</span><span class="p">,</span> <span class="n">log_nu_m</span><span class="p">,</span> <span class="n">log_nu_c</span><span class="p">,</span> <span class="n">log_nu_a</span><span class="p">,</span> <span class="n">log_nu_ac</span> <span class="ow">or</span> <span class="n">log_nu_a</span><span class="p">,</span> <span class="n">log_nu_max</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="o">+</span> <span class="n">log_F_norm</span>
        <span class="k">elif</span> <span class="n">regime</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_6</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="n">regime</span><span class="p">(</span><span class="n">log_nu</span><span class="p">,</span> <span class="n">log_nu_m</span><span class="p">,</span> <span class="n">log_nu_a</span><span class="p">,</span> <span class="n">log_nu_ac</span> <span class="ow">or</span> <span class="n">log_nu_a</span><span class="p">,</span> <span class="n">log_nu_max</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
                <span class="o">+</span> <span class="n">log_F_norm</span>
                <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">log_nu_a</span> <span class="o">-</span> <span class="n">log_nu_c</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">regime</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_7</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="n">regime</span><span class="p">(</span><span class="n">log_nu</span><span class="p">,</span> <span class="n">log_nu_m</span><span class="p">,</span> <span class="n">log_nu_a</span><span class="p">,</span> <span class="n">log_nu_max</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
                <span class="o">+</span> <span class="n">log_F_norm</span>
                <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">log_nu_m</span> <span class="o">-</span> <span class="n">log_nu_c</span><span class="p">)</span>
                <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="n">p</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">log_nu_a</span> <span class="o">-</span> <span class="n">log_nu_m</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Unrecognized regime in _log_opt_sed_from_regime.&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_log_opt_sed</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">log_nu</span><span class="p">:</span> <span class="s2">&quot;_ArrayLike&quot;</span><span class="p">,</span>
        <span class="n">log_nu_m</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_nu_c</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_nu_max</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_F_norm</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_omega</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_gamma_m</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_nu_ac</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">p</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">3.0</span><span class="p">,</span>
        <span class="n">s</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Optimized log-space SED evaluation with regime determination.</span>

<span class="sd">        This method orchestrates the full SED evaluation by:</span>

<span class="sd">        1. Determining the global spectral regime,</span>
<span class="sd">        2. Computing the corresponding self-absorption frequency,</span>
<span class="sd">        3. Dispatching to the appropriate regime-specific kernel.</span>

<span class="sd">        All inputs are assumed to be in **natural logarithmic CGS units**.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array-like</span>
<span class="sd">            Natural logarithm of the synchrotron SED evaluated at ``log_nu``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Determine the regime</span>
        <span class="n">regime</span><span class="p">,</span> <span class="n">log_nu_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_sed_regime</span><span class="p">(</span>
            <span class="n">log_F_norm</span><span class="p">,</span>
            <span class="n">log_nu_m</span><span class="p">,</span>
            <span class="n">log_nu_c</span><span class="p">,</span>
            <span class="n">log_nu_max</span><span class="p">,</span>
            <span class="n">log_omega</span><span class="p">,</span>
            <span class="n">log_gamma_m</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Dispatch to the appropriate regime function</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_log_opt_sed_from_regime</span><span class="p">(</span>
            <span class="n">regime</span><span class="p">,</span>
            <span class="n">log_nu</span><span class="p">,</span>
            <span class="n">log_nu_m</span><span class="p">,</span>
            <span class="n">log_nu_a</span><span class="p">,</span>
            <span class="n">log_nu_c</span><span class="p">,</span>
            <span class="n">log_nu_max</span><span class="p">,</span>
            <span class="n">log_F_norm</span><span class="p">,</span>
            <span class="n">log_nu_ac</span><span class="p">,</span>
            <span class="n">p</span><span class="p">,</span>
            <span class="n">s</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="PowerLaw_Cooling_SSA_SynchrotronSED.sed">
<a class="viewcode-back" href="../../../_as_gen/radiation.synchrotron.SEDs.PowerLaw_Cooling_SSA_SynchrotronSED.sed.html#radiation.synchrotron.SEDs.PowerLaw_Cooling_SSA_SynchrotronSED.sed">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">sed</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">nu</span><span class="p">:</span> <span class="s2">&quot;_UnitBearingArrayLike&quot;</span><span class="p">,</span>
        <span class="n">nu_m</span><span class="p">:</span> <span class="s2">&quot;_UnitBearingScalarLike&quot;</span><span class="p">,</span>
        <span class="n">nu_c</span><span class="p">:</span> <span class="s2">&quot;_UnitBearingScalarLike&quot;</span><span class="p">,</span>
        <span class="n">F_norm</span><span class="p">:</span> <span class="s2">&quot;_UnitBearingScalarLike&quot;</span><span class="p">,</span>
        <span class="n">nu_max</span><span class="p">:</span> <span class="s2">&quot;_UnitBearingScalarLike&quot;</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
        <span class="n">nu_ac</span><span class="p">:</span> <span class="s2">&quot;_UnitBearingScalarLike&quot;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">omega</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span>
        <span class="n">gamma_m</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">p</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
        <span class="n">s</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the synchrotron spectral energy distribution.</span>

<span class="sd">        This is the **primary user-facing interface** for computing the synchrotron</span>
<span class="sd">        SED. It performs unit validation, converts inputs to logarithmic CGS form,</span>
<span class="sd">        and dispatches to the optimized internal implementation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nu : ~astropy.units.Quantity or float or array-like</span>
<span class="sd">            Frequencies at which to evaluate the SED.</span>
<span class="sd">        nu_m, nu_c, nu_max : ~astropy.units.Quantity or float</span>
<span class="sd">            Injection, cooling, and maximum synchrotron frequencies.</span>
<span class="sd">        F_norm : ~astropy.units.Quantity or float</span>
<span class="sd">            The normalization flux density corresponding to the *optically thin* equivalent</span>
<span class="sd">            emission at the dominant electron frequency. See :ref:`sed_normalization` for details on how</span>
<span class="sd">            to determine the appropriate normalization.</span>
<span class="sd">        nu_ac : ~astropy.units.Quantity or float, optional</span>
<span class="sd">            Stratified SSA transition frequency.</span>
<span class="sd">        omega : float</span>
<span class="sd">            Effective emission solid angle.</span>
<span class="sd">        gamma_m : float</span>
<span class="sd">            Minimum electron Lorentz factor.</span>
<span class="sd">        p : float</span>
<span class="sd">            Electron power-law index.</span>
<span class="sd">        s : float</span>
<span class="sd">            Spectral smoothing parameter.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        astropy.units.Quantity</span>
<span class="sd">            Flux density :math:`F_\nu` evaluated at ``nu``.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This is the **only method** that enforces units.</span>
<span class="sd">        - All internal calculations are performed in log-space.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Enforce units on each of the inputs</span>
        <span class="n">nu</span> <span class="o">=</span> <span class="n">ensure_in_units</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="s2">&quot;Hz&quot;</span><span class="p">)</span>
        <span class="n">nu_m</span> <span class="o">=</span> <span class="n">ensure_in_units</span><span class="p">(</span><span class="n">nu_m</span><span class="p">,</span> <span class="s2">&quot;Hz&quot;</span><span class="p">)</span>
        <span class="n">nu_c</span> <span class="o">=</span> <span class="n">ensure_in_units</span><span class="p">(</span><span class="n">nu_c</span><span class="p">,</span> <span class="s2">&quot;Hz&quot;</span><span class="p">)</span>
        <span class="n">F_norm</span> <span class="o">=</span> <span class="n">ensure_in_units</span><span class="p">(</span><span class="n">F_norm</span><span class="p">,</span> <span class="s2">&quot;erg s^-1 cm^-2 Hz^-1&quot;</span><span class="p">)</span>
        <span class="n">nu_max</span> <span class="o">=</span> <span class="n">ensure_in_units</span><span class="p">(</span><span class="n">nu_max</span><span class="p">,</span> <span class="s2">&quot;Hz&quot;</span><span class="p">)</span>
        <span class="n">nu_ac</span> <span class="o">=</span> <span class="n">ensure_in_units</span><span class="p">(</span><span class="n">nu_ac</span><span class="p">,</span> <span class="s2">&quot;Hz&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="n">nu_ac</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="c1"># Dispatch to the optimized log-space SED</span>
        <span class="n">log_sed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_log_opt_sed</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">nu</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">nu_m</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">nu_c</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">nu_max</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">F_norm</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">omega</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">gamma_m</span><span class="p">),</span>
            <span class="n">log_nu_ac</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">nu_ac</span><span class="p">)</span> <span class="k">if</span> <span class="n">nu_ac</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span>
            <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_sed</span><span class="p">)</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">erg</span> <span class="o">/</span> <span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">s</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">cm</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">Hz</span><span class="p">)</span></div>


    <span class="c1"># =========================================================== #</span>
    <span class="c1"># Closure Relations Implementation                            #</span>
    <span class="c1"># =========================================================== #</span>
    <span class="c1"># Here we implement the closure relations to go forward and backward</span>
    <span class="c1"># between the physics parameters and the phenomenological SED parameters.</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_opt_from_physics_to_params</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">log_B</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_V</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_D_L</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_Omega</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_gamma_min</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_gamma_c</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_gamma_max</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
        <span class="n">p</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.5</span><span class="p">,</span>
        <span class="n">epsilon_E</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">epsilon_B</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">pitch_average</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Low-level equipartition-based closure for synchrotron SED normalization.</span>

<span class="sd">        This method maps **physical model parameters** describing the emitting region</span>
<span class="sd">        and electron population to a **self-consistent set of phenomenological SED</span>
<span class="sd">        parameters** for synchrotron emission with cooling and self-absorption.</span>

<span class="sd">        It is the optimized, log-space implementation underlying</span>
<span class="sd">        :meth:`from_physics_to_params` and is intended **only for internal use**.</span>
<span class="sd">        All inputs and outputs are assumed to be expressed in **natural logarithmic</span>
<span class="sd">        CGS units**, and no unit validation is performed.</span>

<span class="sd">        The procedure implemented here follows a physically motivated decision tree:</span>

<span class="sd">        1. Compute characteristic synchrotron frequencies</span>
<span class="sd">           (:math:`\nu_m`, :math:`\nu_c`, :math:`\nu_{\max}`) from the supplied Lorentz</span>
<span class="sd">           factors and magnetic field.</span>
<span class="sd">        2. Determine whether the system is **fast-cooling** or **slow-/non-cooling**</span>
<span class="sd">           by comparing :math:`\gamma_c` and :math:`\gamma_m`.</span>
<span class="sd">        3. Select the appropriate electron energy distribution and normalization:</span>
<span class="sd">           - Fast cooling: broken power-law (BPL) anchored at :math:`\gamma_c`,</span>
<span class="sd">           - Slow / no cooling: power-law (PL) anchored at :math:`\gamma_m`.</span>
<span class="sd">        4. Compute a provisional spectral normalization via equipartition.</span>
<span class="sd">        5. Compute candidate self-absorption frequencies for all compatible spectral</span>
<span class="sd">           regimes.</span>
<span class="sd">        6. Select the unique, globally consistent synchrotron regime.</span>
<span class="sd">        7. Propagate the normalization to the **true spectral peak**, if required by</span>
<span class="sd">           the regime (i.e. optically thick cases).</span>

<span class="sd">        The output parameters are guaranteed to be **mutually consistent** with the</span>
<span class="sd">        selected synchrotron regime.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        log_B : float</span>
<span class="sd">            Natural logarithm of the magnetic field strength (Gauss).</span>
<span class="sd">        log_V : float</span>
<span class="sd">            Natural logarithm of the effective emitting volume (cm³).</span>
<span class="sd">        log_D_L : float</span>
<span class="sd">            Natural logarithm of the luminosity distance (cm).</span>
<span class="sd">        log_Omega : float</span>
<span class="sd">            Natural logarithm of the effective emission solid angle</span>
<span class="sd">            :math:`\Omega = A / D^2`.</span>
<span class="sd">        log_gamma_min : float</span>
<span class="sd">            Natural logarithm of the minimum electron Lorentz factor</span>
<span class="sd">            :math:`\gamma_m`.</span>
<span class="sd">        log_gamma_c : float</span>
<span class="sd">            Natural logarithm of the cooling Lorentz factor</span>
<span class="sd">            :math:`\gamma_c`.</span>
<span class="sd">        log_gamma_max : float, optional</span>
<span class="sd">            Natural logarithm of the maximum electron Lorentz factor.</span>
<span class="sd">            Defaults to :math:`+\infty`.</span>
<span class="sd">        p : float, optional</span>
<span class="sd">            Power-law index of the injected electron energy distribution.</span>
<span class="sd">        epsilon_E : float, optional</span>
<span class="sd">            Fraction of post-shock internal energy carried by relativistic electrons.</span>
<span class="sd">        epsilon_B : float, optional</span>
<span class="sd">            Fraction of post-shock internal energy stored in magnetic fields.</span>
<span class="sd">        alpha : float, optional</span>
<span class="sd">            Electron pitch angle in radians. Ignored if ``pitch_average=True``.</span>
<span class="sd">        pitch_average : bool, optional</span>
<span class="sd">            If ``True``, use pitch-angle averaged synchrotron emissivity.</span>
<span class="sd">            Otherwise, a fixed pitch angle is assumed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        params : dict</span>
<span class="sd">            Dictionary containing **logarithmic** phenomenological SED parameters:</span>

<span class="sd">            - ``F_peak`` : :math:`\log F_{\nu,\mathrm{pk}}`</span>
<span class="sd">            - ``nu_m`` : :math:`\log \nu_m`</span>
<span class="sd">            - ``nu_c`` : :math:`\log \nu_c`</span>
<span class="sd">            - ``nu_a`` : :math:`\log \nu_a`</span>
<span class="sd">            - ``nu_max`` : :math:`\log \nu_{\max}`</span>
<span class="sd">            - ``regime`` : Enum identifying the selected synchrotron spectral regime</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This method performs **no unit checking** and assumes all inputs are valid.</span>
<span class="sd">        - All calculations are performed in **log-space** for numerical stability.</span>
<span class="sd">        - Equipartition is an **assumption**, not a physical requirement.</span>
<span class="sd">        - This method enforces **global regime consistency**; mixed-regime solutions</span>
<span class="sd">          are not permitted.</span>
<span class="sd">        - The returned normalization corresponds to the **true spectral peak**, which</span>
<span class="sd">          may differ from the initial anchoring frequency.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        from_physics_to_params :</span>
<span class="sd">            Public, unit-aware interface to this closure relation.</span>
<span class="sd">        _compute_sed_regime :</span>
<span class="sd">            Global synchrotron regime determination logic.</span>
<span class="sd">        _compute_ssa_frequencies_from_F_norm :</span>
<span class="sd">            SSA frequency computation using anchored spectral normalizations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Handle pitch angle details and the relevant values of</span>
        <span class="c1"># the log_chi parameter in each case. This allows us to</span>
        <span class="c1"># permit both a fixed pitch angle and pitch-angle averaging.</span>
        <span class="n">sin_alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">log_sin_alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">sin_alpha</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">pitch_average</span> <span class="k">else</span> <span class="mf">0.0</span>
        <span class="n">log_chi</span> <span class="o">=</span> <span class="n">_log_chi_cgs_iso</span> <span class="k">if</span> <span class="n">pitch_average</span> <span class="k">else</span> <span class="n">_log_chi_cgs</span>

        <span class="c1"># --- Compute the Frequencies --- #</span>
        <span class="c1"># We need to use the electron Lorentz factors to compute</span>
        <span class="c1"># the relevant synchrotron frequencies. This should be done for</span>
        <span class="c1"># gamma_c, gamma_min, and gamma_max.</span>
        <span class="n">log_nu_m</span> <span class="o">=</span> <span class="n">_opt_compute_log_synch_frequency</span><span class="p">(</span>
            <span class="n">log_gamma_min</span><span class="p">,</span>
            <span class="n">log_B</span><span class="p">,</span>
            <span class="n">sin_alpha</span><span class="o">=</span><span class="n">sin_alpha</span><span class="p">,</span>
            <span class="n">pitch_average</span><span class="o">=</span><span class="n">pitch_average</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">log_nu_max</span> <span class="o">=</span> <span class="n">_opt_compute_log_synch_frequency</span><span class="p">(</span>
            <span class="n">log_gamma_max</span><span class="p">,</span>
            <span class="n">log_B</span><span class="p">,</span>
            <span class="n">sin_alpha</span><span class="o">=</span><span class="n">sin_alpha</span><span class="p">,</span>
            <span class="n">pitch_average</span><span class="o">=</span><span class="n">pitch_average</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">log_nu_c</span> <span class="o">=</span> <span class="n">_opt_compute_log_synch_frequency</span><span class="p">(</span>
            <span class="n">log_gamma_c</span><span class="p">,</span>
            <span class="n">log_B</span><span class="p">,</span>
            <span class="n">sin_alpha</span><span class="o">=</span><span class="n">sin_alpha</span><span class="p">,</span>
            <span class="n">pitch_average</span><span class="o">=</span><span class="n">pitch_average</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Determine if we are fast cooling or not.</span>
        <span class="n">_FAST_COOLING_FLAG</span> <span class="o">=</span> <span class="n">log_gamma_c</span> <span class="o">&lt;</span> <span class="n">log_gamma_min</span>

        <span class="c1"># Log that we have computed the frequencies, as this is a critical step in the closure.</span>
        <span class="k">if</span> <span class="n">triceratops_logger</span><span class="o">.</span><span class="n">isEnabledFor</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">):</span>
            <span class="n">triceratops_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;PowerLaw_Cooling_SSA_SynchrotronSED: computed characteristic frequencies.&quot;</span><span class="p">,</span>
                <span class="n">extra</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;log_gamma_min&quot;</span><span class="p">:</span> <span class="n">log_gamma_min</span><span class="p">,</span>
                    <span class="s2">&quot;log_gamma_c&quot;</span><span class="p">:</span> <span class="n">log_gamma_c</span><span class="p">,</span>
                    <span class="s2">&quot;log_gamma_max&quot;</span><span class="p">:</span> <span class="n">log_gamma_max</span><span class="p">,</span>
                    <span class="s2">&quot;log_nu_m&quot;</span><span class="p">:</span> <span class="n">log_nu_m</span><span class="p">,</span>
                    <span class="s2">&quot;log_nu_c&quot;</span><span class="p">:</span> <span class="n">log_nu_c</span><span class="p">,</span>
                    <span class="s2">&quot;log_nu_max&quot;</span><span class="p">:</span> <span class="n">log_nu_max</span><span class="p">,</span>
                    <span class="s2">&quot;fast_cooling&quot;</span><span class="p">:</span> <span class="n">_FAST_COOLING_FLAG</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="c1"># --- Determine the Normalizations for the Electrons --- #</span>
        <span class="c1">#  At this stage, we immediately know if we have fast or slow cooling and</span>
        <span class="c1">#  therefore which frequency we are going to anchor the electron distribution to.</span>
        <span class="k">if</span> <span class="n">_FAST_COOLING_FLAG</span><span class="p">:</span>
            <span class="c1"># The dominant electron population will occur at nu_c and require us to</span>
            <span class="c1"># normalize via equipartition over a BPL distribution at gamma_c.</span>
            <span class="n">log_electron_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="n">_opt_normalize_BPL_from_magnetic_field</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_B</span><span class="p">),</span>
                    <span class="o">-</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>  <span class="c1"># TODO: THIS NEEDS FIXING!</span>
                    <span class="o">-</span><span class="n">p</span><span class="p">,</span>
                    <span class="n">gamma_b</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_gamma_min</span><span class="p">),</span>
                    <span class="n">gamma_min</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_gamma_c</span><span class="p">),</span>
                    <span class="n">gamma_max</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_gamma_max</span><span class="p">),</span>
                    <span class="n">epsilon_E</span><span class="o">=</span><span class="n">epsilon_E</span><span class="p">,</span>
                    <span class="n">epsilon_B</span><span class="o">=</span><span class="n">epsilon_B</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>

            <span class="n">log_F_norm</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">log_chi</span>
                <span class="o">+</span> <span class="n">log_B</span>
                <span class="o">+</span> <span class="n">log_sin_alpha</span>  <span class="c1"># Zero if pitch averaged</span>
                <span class="o">+</span> <span class="n">log_electron_norm</span>
                <span class="o">+</span> <span class="n">log_nu_m</span>
                <span class="o">-</span> <span class="n">log_nu_c</span>
                <span class="o">+</span> <span class="n">log_gamma_c</span>
                <span class="o">+</span> <span class="n">log_V</span>
                <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">log_D_L</span>
            <span class="p">)</span>

            <span class="c1"># Compute the SSA frequencies.</span>
            <span class="n">regime</span><span class="p">,</span> <span class="n">log_nu_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_sed_regime</span><span class="p">(</span>
                <span class="n">log_F_norm</span><span class="p">,</span> <span class="n">log_nu_m</span><span class="p">,</span> <span class="n">log_nu_c</span><span class="p">,</span> <span class="n">log_nu_max</span><span class="p">,</span> <span class="n">log_Omega</span><span class="p">,</span> <span class="n">log_gamma_min</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># The dominant electron population will occur at nu_m and require us to</span>
            <span class="c1"># normalize via equipartition over a PL distribution at gamma_min.</span>
            <span class="n">log_electron_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="n">_opt_normalize_PL_from_magnetic_field</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_B</span><span class="p">),</span>
                    <span class="n">p</span><span class="p">,</span>
                    <span class="n">gamma_min</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_gamma_min</span><span class="p">),</span>
                    <span class="n">gamma_max</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_gamma_max</span><span class="p">),</span>
                    <span class="n">epsilon_E</span><span class="o">=</span><span class="n">epsilon_E</span><span class="p">,</span>
                    <span class="n">epsilon_B</span><span class="o">=</span><span class="n">epsilon_B</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">log_F_norm</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">log_chi</span>
                <span class="o">+</span> <span class="n">log_B</span>
                <span class="o">+</span> <span class="n">log_sin_alpha</span>  <span class="c1"># Zero if pitch averaged</span>
                <span class="o">+</span> <span class="n">log_electron_norm</span>
                <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="n">log_gamma_min</span>
                <span class="o">+</span> <span class="n">log_V</span>
                <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">log_D_L</span>
            <span class="p">)</span>

            <span class="n">regime</span><span class="p">,</span> <span class="n">log_nu_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_sed_regime</span><span class="p">(</span>
                <span class="n">log_F_norm</span><span class="p">,</span> <span class="n">log_nu_m</span><span class="p">,</span> <span class="n">log_nu_c</span><span class="p">,</span> <span class="n">log_nu_max</span><span class="p">,</span> <span class="n">log_Omega</span><span class="p">,</span> <span class="n">log_gamma_min</span>
            <span class="p">)</span>

        <span class="c1"># --- LOG AND RETURN --- #</span>
        <span class="k">if</span> <span class="n">triceratops_logger</span><span class="o">.</span><span class="n">isEnabledFor</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">):</span>
            <span class="n">triceratops_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;PowerLaw_Cooling_SSA_SynchrotronSED: completed normalization.&quot;</span><span class="p">,</span>
                <span class="n">extra</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;log_gamma_min&quot;</span><span class="p">:</span> <span class="n">log_gamma_min</span><span class="p">,</span>
                    <span class="s2">&quot;log_gamma_c&quot;</span><span class="p">:</span> <span class="n">log_gamma_c</span><span class="p">,</span>
                    <span class="s2">&quot;log_gamma_max&quot;</span><span class="p">:</span> <span class="n">log_gamma_max</span><span class="p">,</span>
                    <span class="s2">&quot;log_nu_m&quot;</span><span class="p">:</span> <span class="n">log_nu_m</span><span class="p">,</span>
                    <span class="s2">&quot;log_nu_c&quot;</span><span class="p">:</span> <span class="n">log_nu_c</span><span class="p">,</span>
                    <span class="s2">&quot;log_nu_max&quot;</span><span class="p">:</span> <span class="n">log_nu_max</span><span class="p">,</span>
                    <span class="s2">&quot;log_nu_a&quot;</span><span class="p">:</span> <span class="n">log_nu_a</span><span class="p">,</span>
                    <span class="s2">&quot;fast_cooling&quot;</span><span class="p">:</span> <span class="n">_FAST_COOLING_FLAG</span><span class="p">,</span>
                    <span class="s2">&quot;regime&quot;</span><span class="p">:</span> <span class="n">regime</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                    <span class="s2">&quot;log_electron_norm&quot;</span><span class="p">:</span> <span class="n">log_electron_norm</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;F_norm&quot;</span><span class="p">:</span> <span class="n">log_F_norm</span><span class="p">,</span>
            <span class="s2">&quot;nu_m&quot;</span><span class="p">:</span> <span class="n">log_nu_m</span><span class="p">,</span>
            <span class="s2">&quot;nu_c&quot;</span><span class="p">:</span> <span class="n">log_nu_c</span><span class="p">,</span>
            <span class="s2">&quot;nu_a&quot;</span><span class="p">:</span> <span class="n">log_nu_a</span><span class="p">,</span>
            <span class="s2">&quot;nu_max&quot;</span><span class="p">:</span> <span class="n">log_nu_max</span><span class="p">,</span>
            <span class="s2">&quot;regime&quot;</span><span class="p">:</span> <span class="n">regime</span><span class="p">,</span>
        <span class="p">}</span>

<div class="viewcode-block" id="PowerLaw_Cooling_SSA_SynchrotronSED.from_physics_to_params">
<a class="viewcode-back" href="../../../_as_gen/radiation.synchrotron.SEDs.PowerLaw_Cooling_SSA_SynchrotronSED.from_physics_to_params.html#radiation.synchrotron.SEDs.PowerLaw_Cooling_SSA_SynchrotronSED.from_physics_to_params">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_physics_to_params</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">B</span><span class="p">:</span> <span class="s2">&quot;_UnitBearingScalarLike&quot;</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="s2">&quot;_UnitBearingScalarLike&quot;</span><span class="p">,</span>
        <span class="n">D_L</span><span class="p">:</span> <span class="s2">&quot;_UnitBearingScalarLike&quot;</span><span class="p">,</span>
        <span class="n">Omega</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">gamma_min</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">gamma_c</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">gamma_max</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
        <span class="n">p</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.5</span><span class="p">,</span>
        <span class="n">epsilon_E</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">epsilon_B</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">pitch_average</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine the equipartition parameters for this SED from physical inputs.</span>

<span class="sd">        This method utilizes the normalization scheme described in :ref:`synch_sed_theory`</span>
<span class="sd">        (specifically :meth:`sed_normalization`) to compute the phenomenological SED parameters</span>
<span class="sd">        (i.e. :math:`F_{\nu,\mathrm{pk}}`, :math:`\nu_m`, :math:`\nu_c`, :math:`\nu_a`, etc.)</span>
<span class="sd">        from the underlying physical parameters of the system.</span>

<span class="sd">        .. note::</span>

<span class="sd">            Users are **strongly encouraged** to read the notes in :ref:`synch_sed_theory`</span>
<span class="sd">            regarding the assumptions and limitations of this approach before applying</span>
<span class="sd">            it to real systems.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        B : ~astropy.units.Quantity or float</span>
<span class="sd">            Magnetic field strength. Must be convertible to Gauss.</span>
<span class="sd">        V : ~astropy.units.Quantity or float</span>
<span class="sd">            Effective emitting volume. Must be convertible to ``cm^3``.</span>
<span class="sd">        D_L : ~astropy.units.Quantity or float</span>
<span class="sd">            Luminosity distance to the source. Must be convertible to ``cm``.</span>
<span class="sd">        Omega : float</span>
<span class="sd">            Effective emission solid angle :math:`\Omega = A / D^2`.</span>
<span class="sd">        gamma_min : float</span>
<span class="sd">            Minimum electron Lorentz factor :math:`\gamma_m`.</span>
<span class="sd">        gamma_c : float</span>
<span class="sd">            Cooling Lorentz factor :math:`\gamma_c`.</span>
<span class="sd">        gamma_max : float, optional</span>
<span class="sd">            Maximum electron Lorentz factor. Default corresponds to no cutoff.</span>
<span class="sd">        p : float, optional</span>
<span class="sd">            Power-law index of the injected electron energy distribution.</span>
<span class="sd">        epsilon_E : float, optional</span>
<span class="sd">            Fraction of post-shock internal energy in relativistic electrons.</span>
<span class="sd">        epsilon_B : float, optional</span>
<span class="sd">            Fraction of post-shock internal energy in magnetic fields.</span>
<span class="sd">        alpha : float, optional</span>
<span class="sd">            Electron pitch angle in radians. Ignored if ``pitch_average=True``.</span>
<span class="sd">        pitch_average : bool, optional</span>
<span class="sd">            If ``True``, use pitch-angle averaged synchrotron emissivity.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        params : dict</span>
<span class="sd">            Dictionary containing the phenomenological SED parameters:</span>

<span class="sd">            - ``F_peak`` : Peak flux density (:math:`F_{\nu,\mathrm{pk}}`)</span>
<span class="sd">              with units ``erg cm^-2 s^-1 Hz^-1``.</span>
<span class="sd">            - ``nu_m`` : Injection frequency :math:`\nu_m` (Hz).</span>
<span class="sd">            - ``nu_c`` : Cooling frequency :math:`\nu_c` (Hz).</span>
<span class="sd">            - ``nu_a`` : Self-absorption frequency :math:`\nu_a` (Hz).</span>
<span class="sd">            - ``nu_max`` : Maximum synchrotron frequency :math:`\nu_{\max}` (Hz).</span>
<span class="sd">            - ``regime`` : Enum identifying the global synchrotron spectral regime.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This method assumes a **single-zone, homogeneous emitting region**.</span>
<span class="sd">        - Equipartition is an **assumption**, not a physical necessity.</span>
<span class="sd">        - The returned parameters are guaranteed to be **self-consistent** with</span>
<span class="sd">          the selected synchrotron spectral regime.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Coerce things down to unit carrying values.</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">ensure_in_units</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="s2">&quot;G&quot;</span><span class="p">)</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">ensure_in_units</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="s2">&quot;cm^3&quot;</span><span class="p">)</span>
        <span class="n">D_L</span> <span class="o">=</span> <span class="n">ensure_in_units</span><span class="p">(</span><span class="n">D_L</span><span class="p">,</span> <span class="s2">&quot;cm&quot;</span><span class="p">)</span>

        <span class="c1"># Get everything in log-space. The low-level implementation is</span>
        <span class="c1"># done natively in log-space for stability.</span>
        <span class="n">log_B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
        <span class="n">log_V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
        <span class="n">log_D_L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">D_L</span><span class="p">)</span>
        <span class="n">log_Omega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">Omega</span><span class="p">)</span>

        <span class="n">log_gamma_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">gamma_min</span><span class="p">)</span>
        <span class="n">log_gamma_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">gamma_c</span><span class="p">)</span>
        <span class="n">log_gamma_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">gamma_max</span><span class="p">)</span>

        <span class="c1"># Dispatch to the optimized low-level implementation.</span>
        <span class="n">params_log</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_opt_from_physics_to_params</span><span class="p">(</span>
            <span class="n">log_B</span><span class="o">=</span><span class="n">log_B</span><span class="p">,</span>
            <span class="n">log_V</span><span class="o">=</span><span class="n">log_V</span><span class="p">,</span>
            <span class="n">log_D_L</span><span class="o">=</span><span class="n">log_D_L</span><span class="p">,</span>
            <span class="n">log_Omega</span><span class="o">=</span><span class="n">log_Omega</span><span class="p">,</span>
            <span class="n">log_gamma_min</span><span class="o">=</span><span class="n">log_gamma_min</span><span class="p">,</span>
            <span class="n">log_gamma_c</span><span class="o">=</span><span class="n">log_gamma_c</span><span class="p">,</span>
            <span class="n">log_gamma_max</span><span class="o">=</span><span class="n">log_gamma_max</span><span class="p">,</span>
            <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span>
            <span class="n">epsilon_E</span><span class="o">=</span><span class="n">epsilon_E</span><span class="p">,</span>
            <span class="n">epsilon_B</span><span class="o">=</span><span class="n">epsilon_B</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
            <span class="n">pitch_average</span><span class="o">=</span><span class="n">pitch_average</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Convert back to linear CGS units and return.</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;F_norm&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">params_log</span><span class="p">[</span><span class="s2">&quot;F_norm&quot;</span><span class="p">])</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">erg</span> <span class="o">/</span> <span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">cm</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">s</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">Hz</span><span class="p">),</span>
            <span class="s2">&quot;nu_m&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">params_log</span><span class="p">[</span><span class="s2">&quot;nu_m&quot;</span><span class="p">])</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">Hz</span><span class="p">,</span>
            <span class="s2">&quot;nu_c&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">params_log</span><span class="p">[</span><span class="s2">&quot;nu_c&quot;</span><span class="p">])</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">Hz</span><span class="p">,</span>
            <span class="s2">&quot;nu_a&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">params_log</span><span class="p">[</span><span class="s2">&quot;nu_a&quot;</span><span class="p">])</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">Hz</span><span class="p">,</span>
            <span class="s2">&quot;nu_max&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">params_log</span><span class="p">[</span><span class="s2">&quot;nu_max&quot;</span><span class="p">])</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">Hz</span><span class="p">,</span>
            <span class="s2">&quot;regime&quot;</span><span class="p">:</span> <span class="n">params_log</span><span class="p">[</span><span class="s2">&quot;regime&quot;</span><span class="p">],</span>
        <span class="p">}</span></div>
</div>



<div class="viewcode-block" id="PowerLaw_Cooling_SynchrotronSED">
<a class="viewcode-back" href="../../../_as_gen/radiation.synchrotron.SEDs.PowerLaw_Cooling_SynchrotronSED.html#radiation.synchrotron.SEDs.PowerLaw_Cooling_SynchrotronSED">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">PowerLaw_Cooling_SynchrotronSED</span><span class="p">(</span><span class="n">MultiSpectrumSynchrotronSED</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Synchrotron SED with cooling but no self-absorption.</span>

<span class="sd">    This class implements the **canonical optically thin synchrotron spectral</span>
<span class="sd">    energy distribution** produced by a power-law electron energy distribution</span>
<span class="sd">    subject to radiative cooling, **without synchrotron self-absorption (SSA)**.</span>

<span class="sd">    It is appropriate for emission regions where the synchrotron self-absorption</span>
<span class="sd">    turnover frequency :math:`\nu_a` lies well below the lowest frequency of</span>
<span class="sd">    interest, and the emitting plasma can be treated as homogeneous.</span>

<span class="sd">    The spectrum is constructed using **smoothed broken power laws (SBPLs)** and</span>
<span class="sd">    supports all standard cooling regimes encountered in synchrotron theory.</span>
<span class="sd">    Regime selection is **global** and based entirely on the ordering of the</span>
<span class="sd">    characteristic break frequencies.</span>

<span class="sd">    For a detailed theoretical derivation of the spectral slopes and normalization</span>
<span class="sd">    conventions, see :ref:`synchrotron_theory`.</span>

<span class="sd">    .. rubric:: Spectral Structure</span>

<span class="sd">    The synchrotron spectrum is classified into one of three cooling regimes</span>
<span class="sd">    based on the ordering of the characteristic frequencies:</span>

<span class="sd">    - Injection frequency :math:`\nu_m`,</span>
<span class="sd">    - Cooling frequency :math:`\nu_c`,</span>
<span class="sd">    - Maximum synchrotron frequency :math:`\nu_{\max}`.</span>

<span class="sd">    The supported regimes are:</span>

<span class="sd">    **Fast cooling** (:math:`\nu_c &lt; \nu_m`)</span>

<span class="sd">    .. math::</span>

<span class="sd">        F_\nu \propto</span>
<span class="sd">        \begin{cases}</span>
<span class="sd">            \nu^{1/3}, &amp; \nu &lt; \nu_c \</span>
<span class="sd">            \nu^{-1/2}, &amp; \nu_c &lt; \nu &lt; \nu_m \</span>
<span class="sd">            \nu^{-p/2}, &amp; \nu &gt; \nu_m</span>
<span class="sd">        \end{cases}</span>

<span class="sd">    **Slow cooling** (:math:`\nu_m &lt; \nu_c &lt; \nu_{\max}`)</span>

<span class="sd">    .. math::</span>

<span class="sd">        F_\nu \propto</span>
<span class="sd">        \begin{cases}</span>
<span class="sd">            \nu^{1/3}, &amp; \nu &lt; \nu_m \</span>
<span class="sd">            \nu^{-(p-1)/2}, &amp; \nu_m &lt; \nu &lt; \nu_c \</span>
<span class="sd">            \nu^{-p/2}, &amp; \nu &gt; \nu_c</span>
<span class="sd">        \end{cases}</span>

<span class="sd">    **Effectively non-cooling** (:math:`\nu_c &gt; \nu_{\max}`)</span>

<span class="sd">    .. math::</span>

<span class="sd">        F_\nu \propto</span>
<span class="sd">        \begin{cases}</span>
<span class="sd">            \nu^{1/3}, &amp; \nu &lt; \nu_m \</span>
<span class="sd">            \nu^{-(p-1)/2}, &amp; \nu &gt; \nu_m</span>
<span class="sd">        \end{cases}</span>

<span class="sd">    The selected regime applies **globally** to the spectrum and does not depend</span>
<span class="sd">    on the frequency grid used for evaluation.</span>

<span class="sd">    .. rubric:: Parameters</span>

<span class="sd">    The parameters entering this SED fall into three conceptual categories.</span>

<span class="sd">    .. tab-set::</span>

<span class="sd">        .. tab-item:: Free parameters (phenomenological)</span>

<span class="sd">            These parameters define the observable structure of the SED and are</span>
<span class="sd">            typically inferred directly from broadband data.</span>

<span class="sd">            .. list-table::</span>
<span class="sd">                :widths: 25 15 60</span>
<span class="sd">                :header-rows: 1</span>

<span class="sd">                * - Parameter</span>
<span class="sd">                  - Symbol</span>
<span class="sd">                  - Description</span>
<span class="sd">                * - Flux normalization</span>
<span class="sd">                  - :math:`F_{\nu,\mathrm{norm}}`</span>
<span class="sd">                  - Flux density normalization corresponding to the *optically thin* equivalent</span>
<span class="sd">                    emission at the dominant electron frequency. See :ref:`sed_normalization` for details</span>
<span class="sd">                    on how to determine the appropriate normalization.</span>
<span class="sd">                * - Injection frequency</span>
<span class="sd">                  - :math:`\nu_m`</span>
<span class="sd">                  - Synchrotron frequency of minimum-energy electrons</span>
<span class="sd">                * - Cooling frequency</span>
<span class="sd">                  - :math:`\nu_c`</span>
<span class="sd">                  - Frequency corresponding to the cooling Lorentz factor</span>
<span class="sd">                * - Maximum frequency</span>
<span class="sd">                  - :math:`\nu_{\max}`</span>
<span class="sd">                  - High-energy synchrotron cutoff frequency</span>

<span class="sd">        .. tab-item:: Hyper-parameters</span>

<span class="sd">            These parameters control the *shape* and smoothness of the spectrum</span>
<span class="sd">            but are not usually tightly constrained by broadband observations.</span>

<span class="sd">            .. list-table::</span>
<span class="sd">                :widths: 25 15 60</span>
<span class="sd">                :header-rows: 1</span>

<span class="sd">                * - Parameter</span>
<span class="sd">                  - Symbol</span>
<span class="sd">                  - Description</span>
<span class="sd">                * - Electron power-law index</span>
<span class="sd">                  - :math:`p`</span>
<span class="sd">                  - Index of the injected electron energy distribution</span>
<span class="sd">                * - Smoothing parameter</span>
<span class="sd">                  - :math:`s`</span>
<span class="sd">                  - Controls the sharpness of spectral breaks</span>
<span class="sd">                * - Minimum Lorentz factor</span>
<span class="sd">                  - :math:`\gamma_m`</span>
<span class="sd">                  - Minimum electron Lorentz factor (used in normalization)</span>

<span class="sd">        .. tab-item:: Derived quantities (internal)</span>

<span class="sd">            These quantities are **not user inputs**, but are determined internally</span>
<span class="sd">            from the supplied parameters.</span>

<span class="sd">            .. list-table::</span>
<span class="sd">                :widths: 25 15 60</span>
<span class="sd">                :header-rows: 1</span>

<span class="sd">                * - Quantity</span>
<span class="sd">                  - Symbol</span>
<span class="sd">                  - Description</span>
<span class="sd">                * - Cooling regime</span>
<span class="sd">                  - —</span>
<span class="sd">                  - Fast, slow, or effectively non-cooling classification</span>
<span class="sd">                * - Regime identifier</span>
<span class="sd">                  - —</span>
<span class="sd">                  - Discrete index selecting the appropriate SED kernel</span>

<span class="sd">    .. rubric:: Normalization and Closure</span>

<span class="sd">    The SED is normalized using :math:`F_{\nu,\mathrm{norm}}`, defined as the flux</span>
<span class="sd">    density of the dominant optically thin emitting electron population. The</span>
<span class="sd">    frequency at which this population emits depends on the cooling regime.</span>

<span class="sd">    In the fast-cooling regime, normalization is anchored at the cooling frequency</span>
<span class="sd">    :math:`\nu_c`; in the slow- and non-cooling regimes, normalization is anchored</span>
<span class="sd">    at the injection frequency :math:`\nu_m`.</span>

<span class="sd">    Optional equipartition-based closure relations are provided to map physical</span>
<span class="sd">    model parameters onto the phenomenological SED parameters.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :class:`SynchrotronSED` : Base class for synchrotron SED implementations.</span>
<span class="sd">    :class:`MultiSpectrumSynchrotronSED` : Base class for multi-regime synchrotron SEDs.</span>
<span class="sd">    :class:`PowerLaw_SynchrotronSED` : Synchrotron SED without cooling or self-absorption.</span>
<span class="sd">    :class:`PowerLaw_SSA_SynchrotronSED` : Synchrotron SED with synchrotron self-absorption.</span>
<span class="sd">    :class:`PowerLaw_Cooling_SSA_SynchrotronSED` : Synchrotron SED with cooling and self-absorption.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">SPECTRUM_FUNCTIONS</span> <span class="o">=</span> <span class="n">_SynchrotronCoolingSEDFunctions</span>

    <span class="c1"># ------------------------------------------------------------ #</span>
    <span class="c1"># Regime determination                                        #</span>
    <span class="c1"># ------------------------------------------------------------ #</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_sed_regime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">log_nu_m</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">log_nu_c</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">log_nu_max</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine the optically thin synchrotron cooling regime.</span>

<span class="sd">        This low-level method classifies the synchrotron spectrum based on the</span>
<span class="sd">        ordering of the characteristic frequencies in log-space:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \nu_m \quad \text{(injection frequency)}, \qquad</span>
<span class="sd">            \nu_c \quad \text{(cooling frequency)}, \qquad</span>
<span class="sd">            \nu_{\max} \quad \text{(high-frequency cutoff)}.</span>

<span class="sd">        The regime determination is **global** and applies to the entire SED;</span>
<span class="sd">        it does not depend on the evaluation frequency array ``nu``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        log_nu_m : float</span>
<span class="sd">            Natural logarithm of the injection frequency :math:`\nu_m`.</span>
<span class="sd">        log_nu_c : float</span>
<span class="sd">            Natural logarithm of the cooling frequency :math:`\nu_c`.</span>
<span class="sd">        log_nu_max : float</span>
<span class="sd">            Natural logarithm of the maximum synchrotron frequency</span>
<span class="sd">            :math:`\nu_{\max}`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        regime : enum-like</span>
<span class="sd">            A member of :attr:`SPECTRUM_FUNCTIONS` identifying the cooling regime.</span>
<span class="sd">        metadata : dict</span>
<span class="sd">            Empty dictionary (present for API consistency with multi-regime SEDs</span>
<span class="sd">            that require auxiliary derived parameters).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The regimes correspond to the following orderings:</span>

<span class="sd">        - **Fast cooling**: :math:`\nu_c &lt; \nu_m`</span>
<span class="sd">        - **Slow cooling**: :math:`\nu_m &lt; \nu_c &lt; \nu_{\max}`</span>
<span class="sd">        - **Non-cooling**: :math:`\nu_c &gt; \nu_{\max}`</span>

<span class="sd">        This method assumes that all inputs are already in log-space and does</span>
<span class="sd">        not perform unit validation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">log_nu_c</span> <span class="o">&lt;</span> <span class="n">log_nu_m</span><span class="p">:</span>
            <span class="n">regime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_1</span>
        <span class="k">elif</span> <span class="n">log_nu_m</span> <span class="o">&lt;</span> <span class="n">log_nu_c</span> <span class="o">&lt;</span> <span class="n">log_nu_max</span><span class="p">:</span>
            <span class="n">regime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_2</span>
        <span class="k">elif</span> <span class="n">log_nu_c</span> <span class="o">&gt;</span> <span class="n">log_nu_max</span><span class="p">:</span>
            <span class="n">regime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_3</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Could not determine cooling regime.&quot;</span><span class="p">)</span>

        <span class="c1"># Now complete, log that we have completed the step, and return.</span>
        <span class="k">if</span> <span class="n">triceratops_logger</span><span class="o">.</span><span class="n">isEnabledFor</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">):</span>
            <span class="n">triceratops_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;PowerLaw_Cooling_SSA_SynchrotronSED: selected regime.&quot;</span><span class="p">,</span>
                <span class="n">extra</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;log_nu_m&quot;</span><span class="p">:</span> <span class="n">log_nu_m</span><span class="p">,</span>
                    <span class="s2">&quot;log_nu_c&quot;</span><span class="p">:</span> <span class="n">log_nu_c</span><span class="p">,</span>
                    <span class="s2">&quot;log_nu_max&quot;</span><span class="p">:</span> <span class="n">log_nu_max</span><span class="p">,</span>
                    <span class="s2">&quot;regime&quot;</span><span class="p">:</span> <span class="n">regime</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">regime</span><span class="p">,</span> <span class="p">{}</span>

<div class="viewcode-block" id="PowerLaw_Cooling_SynchrotronSED.determine_sed_regime">
<a class="viewcode-back" href="../../../_as_gen/radiation.synchrotron.SEDs.PowerLaw_Cooling_SynchrotronSED.determine_sed_regime.html#radiation.synchrotron.SEDs.PowerLaw_Cooling_SynchrotronSED.determine_sed_regime">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">determine_sed_regime</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">nu_m</span><span class="p">:</span> <span class="s2">&quot;_UnitBearingScalarLike&quot;</span><span class="p">,</span> <span class="n">nu_c</span><span class="p">:</span> <span class="s2">&quot;_UnitBearingScalarLike&quot;</span><span class="p">,</span> <span class="n">nu_max</span><span class="p">:</span> <span class="s2">&quot;_UnitBearingScalarLike&quot;</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Public interface for determining the synchrotron cooling regime.</span>

<span class="sd">        This method provides a user-facing wrapper around</span>
<span class="sd">        :meth:`_compute_sed_regime`. It handles unit validation and conversion</span>
<span class="sd">        to log-space before performing regime classification.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nu_m : ~astropy.units.Quantity or float</span>
<span class="sd">            Injection frequency :math:`\nu_m`.</span>
<span class="sd">        nu_c : ~astropy.units.Quantity or float</span>
<span class="sd">            Cooling frequency :math:`\nu_c`.</span>
<span class="sd">        nu_max : ~astropy.units.Quantity or float, optional</span>
<span class="sd">            Maximum synchrotron frequency :math:`\nu_{\max}`.</span>
<span class="sd">            Defaults to :math:`\infty`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        regime : enum-like</span>
<span class="sd">            Identifier specifying the **global cooling regime** of the synchrotron</span>
<span class="sd">            spectrum, determined by the ordering of :math:`\nu_m`, :math:`\nu_c`,</span>
<span class="sd">            and :math:`\nu_{\max}`.</span>

<span class="sd">            The returned value is a member of</span>
<span class="sd">            :attr:`PowerLaw_Cooling_SynchrotronSED.SPECTRUM_FUNCTIONS` and uniquely</span>
<span class="sd">            selects the corresponding optically thin spectral kernel.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This method does **not** depend on the frequency array used to</span>
<span class="sd">          evaluate the SED.</span>
<span class="sd">        - The returned regime must be consistent with the spectrum produced</span>
<span class="sd">          by :meth:`sed` for the same parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nu_m</span> <span class="o">=</span> <span class="n">ensure_in_units</span><span class="p">(</span><span class="n">nu_m</span><span class="p">,</span> <span class="s2">&quot;Hz&quot;</span><span class="p">)</span>
        <span class="n">nu_c</span> <span class="o">=</span> <span class="n">ensure_in_units</span><span class="p">(</span><span class="n">nu_c</span><span class="p">,</span> <span class="s2">&quot;Hz&quot;</span><span class="p">)</span>
        <span class="n">nu_max</span> <span class="o">=</span> <span class="n">ensure_in_units</span><span class="p">(</span><span class="n">nu_max</span><span class="p">,</span> <span class="s2">&quot;Hz&quot;</span><span class="p">)</span>

        <span class="n">regime</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_sed_regime</span><span class="p">(</span>
            <span class="n">log_nu_m</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">nu_m</span><span class="p">),</span>
            <span class="n">log_nu_c</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">nu_c</span><span class="p">),</span>
            <span class="n">log_nu_max</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">nu_max</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">regime</span></div>


    <span class="c1"># ------------------------------------------------------------ #</span>
    <span class="c1"># Regime-specific kernel                                       #</span>
    <span class="c1"># ------------------------------------------------------------ #</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_log_opt_sed_from_regime</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">log_nu</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">regime</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
        <span class="n">log_nu_m</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_nu_c</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_nu_max</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_F_norm</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">p</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">s</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the log-space synchrotron SED for a fixed cooling regime.</span>

<span class="sd">        This method implements the **numerical kernel** for computing the</span>
<span class="sd">        synchrotron SED once the cooling regime has been determined. All</span>
<span class="sd">        branching on the regime identifier occurs here.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        log_nu : array-like</span>
<span class="sd">            Natural logarithm of the frequencies at which to evaluate the SED.</span>
<span class="sd">        regime : enum-like</span>
<span class="sd">            Cooling regime identifier returned by</span>
<span class="sd">            :meth:`_compute_sed_regime`.</span>
<span class="sd">        log_nu_m : float</span>
<span class="sd">            Natural logarithm of the injection frequency :math:`\nu_m`.</span>
<span class="sd">        log_nu_c : float</span>
<span class="sd">            Natural logarithm of the cooling frequency :math:`\nu_c`.</span>
<span class="sd">        log_nu_max : float</span>
<span class="sd">            Natural logarithm of the maximum synchrotron frequency</span>
<span class="sd">            :math:`\nu_{\max}`.</span>
<span class="sd">        log_F_norm : float</span>
<span class="sd">            Natural logarithm of the flux density normalization corresponding to</span>
<span class="sd">            the *optically thin* equivalent emission at the dominant electron frequency.</span>
<span class="sd">        p : float</span>
<span class="sd">            Electron energy power-law index.</span>
<span class="sd">        s : float</span>
<span class="sd">            SBPL smoothness parameter.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        log_sed : array-like</span>
<span class="sd">            Natural logarithm of the flux density</span>
<span class="sd">            :math:`\log F_\nu` evaluated at ``log_nu``.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The returned spectrum is **not normalized** until ``log_F_peak``</span>
<span class="sd">          is added.</span>
<span class="sd">        - This method assumes an optically thin emitting region and does not</span>
<span class="sd">          include synchrotron self-absorption.</span>
<span class="sd">        - No unit validation is performed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">regime</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_1</span><span class="p">:</span>
            <span class="n">log_sed</span> <span class="o">=</span> <span class="n">regime</span><span class="p">(</span><span class="n">log_nu</span><span class="p">,</span> <span class="n">log_nu_m</span><span class="p">,</span> <span class="n">log_nu_c</span><span class="p">,</span> <span class="n">log_nu_max</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">regime</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_2</span><span class="p">:</span>
            <span class="n">log_sed</span> <span class="o">=</span> <span class="n">regime</span><span class="p">(</span><span class="n">log_nu</span><span class="p">,</span> <span class="n">log_nu_m</span><span class="p">,</span> <span class="n">log_nu_c</span><span class="p">,</span> <span class="n">log_nu_max</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">regime</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_3</span><span class="p">:</span>
            <span class="n">log_sed</span> <span class="o">=</span> <span class="n">regime</span><span class="p">(</span><span class="n">log_nu</span><span class="p">,</span> <span class="n">log_nu_m</span><span class="p">,</span> <span class="n">log_nu_max</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Unrecognized cooling regime.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">log_sed</span> <span class="o">+</span> <span class="n">log_F_norm</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_log_opt_sed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">log_nu</span><span class="p">,</span> <span class="n">log_nu_m</span><span class="p">,</span> <span class="n">log_nu_c</span><span class="p">,</span> <span class="n">log_nu_max</span><span class="p">,</span> <span class="n">log_F_norm</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Optimized log-space SED evaluation with regime determination.</span>

<span class="sd">        This method orchestrates the full SED evaluation by:</span>

<span class="sd">        1. Determining the global spectral regime,</span>
<span class="sd">        2. Dispatching to the appropriate regime-specific kernel.</span>

<span class="sd">        All inputs are assumed to be in **natural logarithmic CGS units**.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        log_nu : &quot;_ArrayLike&quot;</span>
<span class="sd">            Natural logarithm of the evaluation frequencies.</span>
<span class="sd">        log_nu_m : float</span>
<span class="sd">            Natural logarithm of the injection frequency.</span>
<span class="sd">        log_nu_c : float</span>
<span class="sd">            Natural logarithm of the cooling frequency.</span>
<span class="sd">        log_nu_max : float</span>
<span class="sd">            Natural logarithm of the maximum synchrotron frequency.</span>
<span class="sd">        log_F_norm : float</span>
<span class="sd">            Natural logarithm of the flux density normalization corresponding to</span>
<span class="sd">            the *optically thin* equivalent emission at the dominant electron frequency.</span>
<span class="sd">        p : float</span>
<span class="sd">            Electron power-law index.</span>
<span class="sd">        s : float</span>
<span class="sd">            Smoothing parameter for spectral breaks.</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array-like</span>
<span class="sd">            Natural logarithm of the synchrotron SED evaluated at ``log_nu``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Determine the regime</span>
        <span class="n">regime</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_sed_regime</span><span class="p">(</span>
            <span class="n">log_nu_m</span><span class="p">,</span>
            <span class="n">log_nu_c</span><span class="p">,</span>
            <span class="n">log_nu_max</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Dispatch to the appropriate regime function</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_log_opt_sed_from_regime</span><span class="p">(</span>
            <span class="n">log_nu</span><span class="p">,</span>
            <span class="n">regime</span><span class="p">,</span>
            <span class="n">log_nu_m</span><span class="p">,</span>
            <span class="n">log_nu_c</span><span class="p">,</span>
            <span class="n">log_nu_max</span><span class="p">,</span>
            <span class="n">log_F_norm</span><span class="p">,</span>
            <span class="n">p</span><span class="p">,</span>
            <span class="n">s</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="PowerLaw_Cooling_SynchrotronSED.sed">
<a class="viewcode-back" href="../../../_as_gen/radiation.synchrotron.SEDs.PowerLaw_Cooling_SynchrotronSED.sed.html#radiation.synchrotron.SEDs.PowerLaw_Cooling_SynchrotronSED.sed">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">sed</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">nu</span><span class="p">:</span> <span class="s2">&quot;_UnitBearingArrayLike&quot;</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">nu_m</span><span class="p">:</span> <span class="s2">&quot;_UnitBearingScalarLike&quot;</span><span class="p">,</span>
        <span class="n">nu_c</span><span class="p">:</span> <span class="s2">&quot;_UnitBearingScalarLike&quot;</span><span class="p">,</span>
        <span class="n">F_norm</span><span class="p">:</span> <span class="s2">&quot;_UnitBearingScalarLike&quot;</span><span class="p">,</span>
        <span class="n">nu_max</span><span class="p">:</span> <span class="s2">&quot;_UnitBearingScalarLike&quot;</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
        <span class="n">p</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.5</span><span class="p">,</span>
        <span class="n">s</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the optically thin synchrotron spectral energy distribution.</span>

<span class="sd">        This is the primary user-facing method for computing the synchrotron</span>
<span class="sd">        flux density :math:`F_\nu` produced by a power-law electron population</span>
<span class="sd">        subject to radiative cooling, **without synchrotron self-absorption**.</span>

<span class="sd">        The spectral shape is determined by the ordering of the characteristic</span>
<span class="sd">        break frequencies and is evaluated using smoothed broken power laws</span>
<span class="sd">        (SBPLs).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nu : ~astropy.units.Quantity or float-like or array-like</span>
<span class="sd">            Frequencies at which to evaluate the SED.</span>
<span class="sd">        nu_m : ~astropy.units.Quantity or float-like</span>
<span class="sd">            Injection (minimum electron) synchrotron frequency</span>
<span class="sd">            :math:`\nu_m`.</span>
<span class="sd">        nu_c : ~astropy.units.Quantity or float-like</span>
<span class="sd">            Cooling break frequency :math:`\nu_c`.</span>
<span class="sd">        F_norm : ~astropy.units.Quantity or float-like</span>
<span class="sd">            Flux density normalization corresponding to the *optically thin* equivalent emission</span>
<span class="sd">            at the dominant electron frequency. See :ref:`sed_normalization` for details</span>
<span class="sd">            on how to determine the appropriate normalization.</span>
<span class="sd">        nu_max : ~astropy.units.Quantity or float-like, optional</span>
<span class="sd">            Maximum synchrotron frequency :math:`\nu_{\max}`.</span>
<span class="sd">            Defaults to :math:`\infty`.</span>
<span class="sd">        p : float, optional</span>
<span class="sd">            Power-law index of the injected electron energy distribution.</span>
<span class="sd">            Default is ``2.5``.</span>
<span class="sd">        s : float, optional</span>
<span class="sd">            SBPL smoothing parameter controlling the sharpness of spectral</span>
<span class="sd">            breaks. Must be negative for physical behavior. Default is ``-1.0``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        flux : astropy.units.Quantity</span>
<span class="sd">            Flux density :math:`F_\nu` evaluated at ``nu``.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Units are validated and coerced internally.</span>
<span class="sd">        - The cooling regime is determined **globally** from the ordering of</span>
<span class="sd">          :math:`\nu_m`, :math:`\nu_c`, and :math:`\nu_{\max}` and applies to</span>
<span class="sd">          the entire spectrum.</span>
<span class="sd">        - The returned SED is continuous and differentiable due to SBPL</span>
<span class="sd">          smoothing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nu</span> <span class="o">=</span> <span class="n">ensure_in_units</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="s2">&quot;Hz&quot;</span><span class="p">)</span>
        <span class="n">nu_m</span> <span class="o">=</span> <span class="n">ensure_in_units</span><span class="p">(</span><span class="n">nu_m</span><span class="p">,</span> <span class="s2">&quot;Hz&quot;</span><span class="p">)</span>
        <span class="n">nu_c</span> <span class="o">=</span> <span class="n">ensure_in_units</span><span class="p">(</span><span class="n">nu_c</span><span class="p">,</span> <span class="s2">&quot;Hz&quot;</span><span class="p">)</span>
        <span class="n">nu_max</span> <span class="o">=</span> <span class="n">ensure_in_units</span><span class="p">(</span><span class="n">nu_max</span><span class="p">,</span> <span class="s2">&quot;Hz&quot;</span><span class="p">)</span>
        <span class="n">F_norm</span> <span class="o">=</span> <span class="n">ensure_in_units</span><span class="p">(</span><span class="n">F_norm</span><span class="p">,</span> <span class="s2">&quot;erg s^-1 cm^-2 Hz^-1&quot;</span><span class="p">)</span>

        <span class="n">log_sed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_log_opt_sed</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">nu</span><span class="p">),</span>
            <span class="n">log_nu_m</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">nu_m</span><span class="p">),</span>
            <span class="n">log_nu_c</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">nu_c</span><span class="p">),</span>
            <span class="n">log_nu_max</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">nu_max</span><span class="p">),</span>
            <span class="n">log_F_norm</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">F_norm</span><span class="p">),</span>
            <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span>
            <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_sed</span><span class="p">)</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">erg</span> <span class="o">/</span> <span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">s</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">cm</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">Hz</span><span class="p">)</span></div>


    <span class="c1"># =========================================================== #</span>
    <span class="c1"># Closure Relations Implementation                            #</span>
    <span class="c1"># =========================================================== #</span>
    <span class="c1"># Here we implement the closure relations to go forward and backward</span>
    <span class="c1"># between the physics parameters and the phenomenological SED parameters.</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_opt_from_physics_to_params</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">log_B</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_V</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_D_L</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_gamma_min</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_gamma_c</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_gamma_max</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
        <span class="n">p</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.5</span><span class="p">,</span>
        <span class="n">epsilon_E</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">epsilon_B</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">pitch_average</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute phenomenological synchrotron SED parameters from physical inputs (log-space).</span>

<span class="sd">        This low-level method converts physical parameters describing a synchrotron-</span>
<span class="sd">        emitting plasma into the **phenomenological parameters** required to evaluate</span>
<span class="sd">        an optically thin, cooling synchrotron spectral energy distribution.</span>

<span class="sd">        All calculations are performed natively in **logarithmic CGS units** for</span>
<span class="sd">        numerical stability and performance. This method is not intended for direct</span>
<span class="sd">        user access.</span>

<span class="sd">        The normalization follows an **equipartition-based prescription**, in which</span>
<span class="sd">        fixed fractions of the post-shock internal energy are assumed to reside in</span>
<span class="sd">        relativistic electrons (:math:`\epsilon_E`) and magnetic fields</span>
<span class="sd">        (:math:`\epsilon_B`).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        log_B : float</span>
<span class="sd">            Natural logarithm of the magnetic field strength in Gauss.</span>
<span class="sd">        log_V : float</span>
<span class="sd">            Natural logarithm of the effective emitting volume in ``cm^3``.</span>
<span class="sd">        log_D_L : float</span>
<span class="sd">            Natural logarithm of the luminosity distance in ``cm``.</span>
<span class="sd">        log_gamma_min : float</span>
<span class="sd">            Natural logarithm of the minimum electron Lorentz factor</span>
<span class="sd">            :math:`\gamma_m`.</span>
<span class="sd">        log_gamma_c : float</span>
<span class="sd">            Natural logarithm of the cooling Lorentz factor</span>
<span class="sd">            :math:`\gamma_c`.</span>
<span class="sd">        log_gamma_max : float, optional</span>
<span class="sd">            Natural logarithm of the maximum electron Lorentz factor.</span>
<span class="sd">            Defaults to :math:`+\infty`, corresponding to no high-energy cutoff.</span>
<span class="sd">        p : float, optional</span>
<span class="sd">            Power-law index of the injected electron energy distribution.</span>
<span class="sd">            Default is ``2.5``.</span>
<span class="sd">        epsilon_E : float, optional</span>
<span class="sd">            Fraction of post-shock internal energy carried by relativistic electrons.</span>
<span class="sd">            Default is ``0.1``.</span>
<span class="sd">        epsilon_B : float, optional</span>
<span class="sd">            Fraction of post-shock internal energy carried by magnetic fields.</span>
<span class="sd">            Default is ``0.1``.</span>
<span class="sd">        alpha : float, optional</span>
<span class="sd">            Electron pitch angle in radians. Ignored if ``pitch_average=True``.</span>
<span class="sd">        pitch_average : bool, optional</span>
<span class="sd">            If ``True``, use pitch-angle averaged synchrotron emissivity and</span>
<span class="sd">            normalization.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        params : dict</span>
<span class="sd">            Dictionary containing logarithmic phenomenological parameters:</span>

<span class="sd">            - ``F_peak`` : Natural logarithm of the peak flux density</span>
<span class="sd">              :math:`F_{\nu,\mathrm{pk}}`.</span>
<span class="sd">            - ``nu_m`` : Natural logarithm of the injection frequency</span>
<span class="sd">              :math:`\nu_m`.</span>
<span class="sd">            - ``nu_c`` : Natural logarithm of the cooling frequency</span>
<span class="sd">              :math:`\nu_c`.</span>
<span class="sd">            - ``nu_max`` : Natural logarithm of the maximum synchrotron frequency</span>
<span class="sd">              :math:`\nu_{\max}`.</span>
<span class="sd">            - ``regime`` : Enum identifying the **global cooling regime** and</span>
<span class="sd">              corresponding spectral kernel.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The cooling regime is determined **globally** from the ordering of</span>
<span class="sd">          :math:`\nu_m`, :math:`\nu_c`, and :math:`\nu_{\max}`.</span>
<span class="sd">        - In the fast-cooling regime, normalization is performed at</span>
<span class="sd">          :math:`\nu_c`; in other regimes, normalization is performed at</span>
<span class="sd">          :math:`\nu_m`.</span>
<span class="sd">        - This method assumes a **single-zone, homogeneous emitting region**.</span>
<span class="sd">        - No synchrotron self-absorption is included.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Handle pitch angle details and the relevant values of</span>
        <span class="c1"># the log_chi parameter in each case. This allows us to</span>
        <span class="c1"># permit both a fixed pitch angle and pitch-angle averaging.</span>
        <span class="n">sin_alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">log_sin_alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">sin_alpha</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">pitch_average</span> <span class="k">else</span> <span class="mf">0.0</span>
        <span class="n">log_chi</span> <span class="o">=</span> <span class="n">_log_chi_cgs_iso</span> <span class="k">if</span> <span class="n">pitch_average</span> <span class="k">else</span> <span class="n">_log_chi_cgs</span>

        <span class="c1"># --- Compute the Frequencies --- #</span>
        <span class="c1"># We need to use the electron Lorentz factors to compute</span>
        <span class="c1"># the relevant synchrotron frequencies. This should be done for</span>
        <span class="c1"># gamma_c, gamma_min, and gamma_max.</span>
        <span class="n">log_nu_m</span> <span class="o">=</span> <span class="n">_opt_compute_log_synch_frequency</span><span class="p">(</span>
            <span class="n">log_gamma_min</span><span class="p">,</span>
            <span class="n">log_B</span><span class="p">,</span>
            <span class="n">sin_alpha</span><span class="o">=</span><span class="n">sin_alpha</span><span class="p">,</span>
            <span class="n">pitch_average</span><span class="o">=</span><span class="n">pitch_average</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">log_nu_max</span> <span class="o">=</span> <span class="n">_opt_compute_log_synch_frequency</span><span class="p">(</span>
            <span class="n">log_gamma_max</span><span class="p">,</span>
            <span class="n">log_B</span><span class="p">,</span>
            <span class="n">sin_alpha</span><span class="o">=</span><span class="n">sin_alpha</span><span class="p">,</span>
            <span class="n">pitch_average</span><span class="o">=</span><span class="n">pitch_average</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">log_nu_c</span> <span class="o">=</span> <span class="n">_opt_compute_log_synch_frequency</span><span class="p">(</span>
            <span class="n">log_gamma_c</span><span class="p">,</span>
            <span class="n">log_B</span><span class="p">,</span>
            <span class="n">sin_alpha</span><span class="o">=</span><span class="n">sin_alpha</span><span class="p">,</span>
            <span class="n">pitch_average</span><span class="o">=</span><span class="n">pitch_average</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># --- Compute the correct peak flux based on the regime --- #</span>
        <span class="k">if</span> <span class="n">log_nu_c</span> <span class="o">&lt;</span> <span class="n">log_nu_m</span><span class="p">:</span>
            <span class="c1"># This is fast cooling, we need to normalize at nu_c.</span>
            <span class="n">log_electron_norm</span> <span class="o">=</span> <span class="n">_opt_normalize_BPL_from_magnetic_field</span><span class="p">(</span>
                <span class="n">log_B</span><span class="p">,</span>
                <span class="o">-</span><span class="mi">2</span><span class="p">,</span>
                <span class="o">-</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
                <span class="n">gamma_b</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_gamma_min</span><span class="p">),</span>
                <span class="n">gamma_min</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_gamma_c</span><span class="p">),</span>
                <span class="n">gamma_max</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_gamma_max</span><span class="p">),</span>
                <span class="n">epsilon_E</span><span class="o">=</span><span class="n">epsilon_E</span><span class="p">,</span>
                <span class="n">epsilon_B</span><span class="o">=</span><span class="n">epsilon_B</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">log_F_norm</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">log_chi</span>
                <span class="o">+</span> <span class="n">log_B</span>
                <span class="o">+</span> <span class="n">log_sin_alpha</span>  <span class="c1"># Zero if pitch averaged</span>
                <span class="o">+</span> <span class="n">log_electron_norm</span>
                <span class="o">+</span> <span class="n">log_nu_m</span>
                <span class="o">-</span> <span class="n">log_nu_c</span>
                <span class="o">+</span> <span class="n">log_gamma_c</span>
                <span class="o">+</span> <span class="n">log_V</span>
                <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">log_D_L</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">log_nu_m</span> <span class="o">&lt;=</span> <span class="n">log_nu_c</span><span class="p">:</span>
            <span class="c1"># This is slow cooling, we need to normalize at nu_m.</span>
            <span class="n">log_electron_norm</span> <span class="o">=</span> <span class="n">_opt_normalize_PL_from_magnetic_field</span><span class="p">(</span>
                <span class="n">log_B</span><span class="p">,</span>
                <span class="n">p</span><span class="p">,</span>
                <span class="n">gamma_min</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_gamma_min</span><span class="p">),</span>
                <span class="n">gamma_max</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_gamma_max</span><span class="p">),</span>
                <span class="n">epsilon_E</span><span class="o">=</span><span class="n">epsilon_E</span><span class="p">,</span>
                <span class="n">epsilon_B</span><span class="o">=</span><span class="n">epsilon_B</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">log_F_norm</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">log_chi</span>
                <span class="o">+</span> <span class="n">log_B</span>
                <span class="o">+</span> <span class="n">log_sin_alpha</span>  <span class="c1"># Zero if pitch averaged</span>
                <span class="o">+</span> <span class="n">log_electron_norm</span>
                <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="n">log_gamma_min</span>
                <span class="o">+</span> <span class="n">log_V</span>
                <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">log_D_L</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Unrecognized regime in from_physics_to_params.&quot;</span><span class="p">)</span>

        <span class="c1"># Return the relevant parameters.</span>
        <span class="n">regime</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_sed_regime</span><span class="p">(</span><span class="n">log_nu_m</span><span class="p">,</span> <span class="n">log_nu_c</span><span class="p">,</span> <span class="n">log_nu_max</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">triceratops_logger</span><span class="o">.</span><span class="n">isEnabledFor</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">):</span>
            <span class="n">triceratops_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;PowerLaw_Cooling_SSA_SynchrotronSED: completed normalization.&quot;</span><span class="p">,</span>
                <span class="n">extra</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;log_gamma_min&quot;</span><span class="p">:</span> <span class="n">log_gamma_min</span><span class="p">,</span>
                    <span class="s2">&quot;log_gamma_c&quot;</span><span class="p">:</span> <span class="n">log_gamma_c</span><span class="p">,</span>
                    <span class="s2">&quot;log_gamma_max&quot;</span><span class="p">:</span> <span class="n">log_gamma_max</span><span class="p">,</span>
                    <span class="s2">&quot;log_nu_m&quot;</span><span class="p">:</span> <span class="n">log_nu_m</span><span class="p">,</span>
                    <span class="s2">&quot;log_nu_c&quot;</span><span class="p">:</span> <span class="n">log_nu_c</span><span class="p">,</span>
                    <span class="s2">&quot;log_nu_max&quot;</span><span class="p">:</span> <span class="n">log_nu_max</span><span class="p">,</span>
                    <span class="s2">&quot;regime&quot;</span><span class="p">:</span> <span class="n">regime</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                    <span class="s2">&quot;log_electron_norm&quot;</span><span class="p">:</span> <span class="n">log_electron_norm</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>

        <span class="c1"># Return the output.</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;F_norm&quot;</span><span class="p">:</span> <span class="n">log_F_norm</span><span class="p">,</span>
            <span class="s2">&quot;nu_m&quot;</span><span class="p">:</span> <span class="n">log_nu_m</span><span class="p">,</span>
            <span class="s2">&quot;nu_c&quot;</span><span class="p">:</span> <span class="n">log_nu_c</span><span class="p">,</span>
            <span class="s2">&quot;nu_max&quot;</span><span class="p">:</span> <span class="n">log_nu_max</span><span class="p">,</span>
            <span class="s2">&quot;regime&quot;</span><span class="p">:</span> <span class="n">regime</span><span class="p">,</span>
        <span class="p">}</span>

<div class="viewcode-block" id="PowerLaw_Cooling_SynchrotronSED.from_physics_to_params">
<a class="viewcode-back" href="../../../_as_gen/radiation.synchrotron.SEDs.PowerLaw_Cooling_SynchrotronSED.from_physics_to_params.html#radiation.synchrotron.SEDs.PowerLaw_Cooling_SynchrotronSED.from_physics_to_params">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_physics_to_params</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">B</span><span class="p">:</span> <span class="s2">&quot;_UnitBearingScalarLike&quot;</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="s2">&quot;_UnitBearingScalarLike&quot;</span><span class="p">,</span>
        <span class="n">D_L</span><span class="p">:</span> <span class="s2">&quot;_UnitBearingScalarLike&quot;</span><span class="p">,</span>
        <span class="n">gamma_min</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">gamma_c</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">gamma_max</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
        <span class="n">p</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.5</span><span class="p">,</span>
        <span class="n">epsilon_E</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">epsilon_B</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">pitch_average</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine phenomenological synchrotron SED parameters from physical inputs.</span>

<span class="sd">        This method computes the phenomenological parameters required to evaluate</span>
<span class="sd">        the optically thin synchrotron spectral energy distribution from a set of</span>
<span class="sd">        physical inputs describing the emitting plasma.</span>

<span class="sd">        The normalization follows an **equipartition-based prescription**, in which</span>
<span class="sd">        fixed fractions of the post-shock internal energy are assumed to reside in</span>
<span class="sd">        relativistic electrons (:math:`\epsilon_E`) and magnetic fields</span>
<span class="sd">        (:math:`\epsilon_B`). The resulting parameters are guaranteed to be</span>
<span class="sd">        internally self-consistent with the selected cooling regime.</span>

<span class="sd">        Users are **strongly encouraged** to consult :ref:`synch_sed_theory` for a</span>
<span class="sd">        detailed discussion of the assumptions and limitations of this approach.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        B : ~astropy.units.Quantity or float</span>
<span class="sd">            Magnetic field strength. Must be convertible to Gauss.</span>
<span class="sd">        V : ~astropy.units.Quantity or float</span>
<span class="sd">            Effective emitting volume. Must be convertible to ``cm^3``.</span>
<span class="sd">        D_L : ~astropy.units.Quantity or float</span>
<span class="sd">            Luminosity distance to the source. Must be convertible to ``cm``.</span>
<span class="sd">        gamma_min : float</span>
<span class="sd">            Minimum electron Lorentz factor :math:`\gamma_m`.</span>
<span class="sd">        gamma_c : float</span>
<span class="sd">            Cooling Lorentz factor :math:`\gamma_c`.</span>
<span class="sd">        gamma_max : float, optional</span>
<span class="sd">            Maximum electron Lorentz factor. Default corresponds to no high-energy</span>
<span class="sd">            cutoff.</span>
<span class="sd">        p : float, optional</span>
<span class="sd">            Power-law index of the injected electron energy distribution.</span>
<span class="sd">            Default is ``2.5``.</span>
<span class="sd">        epsilon_E : float, optional</span>
<span class="sd">            Fraction of post-shock internal energy carried by relativistic electrons.</span>
<span class="sd">            Default is ``0.1``.</span>
<span class="sd">        epsilon_B : float, optional</span>
<span class="sd">            Fraction of post-shock internal energy carried by magnetic fields.</span>
<span class="sd">            Default is ``0.1``.</span>
<span class="sd">        alpha : float, optional</span>
<span class="sd">            Electron pitch angle in radians. Ignored if ``pitch_average=True``.</span>
<span class="sd">        pitch_average : bool, optional</span>
<span class="sd">            If ``True``, use pitch-angle averaged synchrotron emissivity and</span>
<span class="sd">            normalization.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        params : dict</span>
<span class="sd">            Dictionary containing the phenomenological SED parameters:</span>

<span class="sd">            - ``F_peak`` : Peak flux density</span>
<span class="sd">              (:math:`F_{\nu,\mathrm{pk}}`) with units</span>
<span class="sd">              ``erg cm^-2 s^-1 Hz^-1``.</span>
<span class="sd">            - ``nu_m`` : Injection frequency :math:`\nu_m` (Hz).</span>
<span class="sd">            - ``nu_c`` : Cooling frequency :math:`\nu_c` (Hz).</span>
<span class="sd">            - ``nu_max`` : Maximum synchrotron frequency</span>
<span class="sd">              :math:`\nu_{\max}` (Hz).</span>
<span class="sd">            - ``regime`` : Enum identifying the **global synchrotron cooling</span>
<span class="sd">              regime** and corresponding spectral kernel.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This method assumes a **single-zone, homogeneous emitting region**.</span>
<span class="sd">        - Equipartition is an **assumption**, not a physical necessity.</span>
<span class="sd">        - The cooling regime is determined globally and applies to the entire</span>
<span class="sd">          spectrum.</span>
<span class="sd">        - Synchrotron self-absorption is **not included** in this model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Coerce things down to unit carrying values.</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">ensure_in_units</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="s2">&quot;G&quot;</span><span class="p">)</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">ensure_in_units</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="s2">&quot;cm^3&quot;</span><span class="p">)</span>
        <span class="n">D_L</span> <span class="o">=</span> <span class="n">ensure_in_units</span><span class="p">(</span><span class="n">D_L</span><span class="p">,</span> <span class="s2">&quot;cm&quot;</span><span class="p">)</span>

        <span class="c1"># Get everything in log-space. The low-level implementation is</span>
        <span class="c1"># done natively in log-space for stability.</span>
        <span class="n">log_B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
        <span class="n">log_V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
        <span class="n">log_D_L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">D_L</span><span class="p">)</span>

        <span class="n">log_gamma_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">gamma_min</span><span class="p">)</span>
        <span class="n">log_gamma_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">gamma_c</span><span class="p">)</span>
        <span class="n">log_gamma_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">gamma_max</span><span class="p">)</span>

        <span class="c1"># Dispatch to the optimized low-level implementation.</span>
        <span class="n">params_log</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_opt_from_physics_to_params</span><span class="p">(</span>
            <span class="n">log_B</span><span class="o">=</span><span class="n">log_B</span><span class="p">,</span>
            <span class="n">log_V</span><span class="o">=</span><span class="n">log_V</span><span class="p">,</span>
            <span class="n">log_D_L</span><span class="o">=</span><span class="n">log_D_L</span><span class="p">,</span>
            <span class="n">log_gamma_min</span><span class="o">=</span><span class="n">log_gamma_min</span><span class="p">,</span>
            <span class="n">log_gamma_c</span><span class="o">=</span><span class="n">log_gamma_c</span><span class="p">,</span>
            <span class="n">log_gamma_max</span><span class="o">=</span><span class="n">log_gamma_max</span><span class="p">,</span>
            <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span>
            <span class="n">epsilon_E</span><span class="o">=</span><span class="n">epsilon_E</span><span class="p">,</span>
            <span class="n">epsilon_B</span><span class="o">=</span><span class="n">epsilon_B</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
            <span class="n">pitch_average</span><span class="o">=</span><span class="n">pitch_average</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Convert back to linear CGS units and return.</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;F_norm&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">params_log</span><span class="p">[</span><span class="s2">&quot;F_norm&quot;</span><span class="p">])</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">erg</span> <span class="o">/</span> <span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">cm</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">s</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">Hz</span><span class="p">),</span>
            <span class="s2">&quot;nu_m&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">params_log</span><span class="p">[</span><span class="s2">&quot;nu_m&quot;</span><span class="p">])</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">Hz</span><span class="p">,</span>
            <span class="s2">&quot;nu_c&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">params_log</span><span class="p">[</span><span class="s2">&quot;nu_c&quot;</span><span class="p">])</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">Hz</span><span class="p">,</span>
            <span class="s2">&quot;nu_max&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">params_log</span><span class="p">[</span><span class="s2">&quot;nu_max&quot;</span><span class="p">])</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">Hz</span><span class="p">,</span>
            <span class="s2">&quot;regime&quot;</span><span class="p">:</span> <span class="n">params_log</span><span class="p">[</span><span class="s2">&quot;regime&quot;</span><span class="p">],</span>
        <span class="p">}</span></div>
</div>



<div class="viewcode-block" id="PowerLaw_SSA_SynchrotronSED">
<a class="viewcode-back" href="../../../_as_gen/radiation.synchrotron.SEDs.PowerLaw_SSA_SynchrotronSED.html#radiation.synchrotron.SEDs.PowerLaw_SSA_SynchrotronSED">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">PowerLaw_SSA_SynchrotronSED</span><span class="p">(</span><span class="n">MultiSpectrumSynchrotronSED</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Synchrotron SED with synchrotron self-absorption and no radiative cooling.</span>

<span class="sd">    This class implements the **canonical non-cooling synchrotron spectral energy</span>
<span class="sd">    distribution** produced by a power-law electron population, including</span>
<span class="sd">    **synchrotron self-absorption (SSA)** but **excluding radiative cooling**.</span>

<span class="sd">    It is applicable to homogeneous, single-zone emission regions in which the</span>
<span class="sd">    synchrotron cooling frequency lies well above the maximum frequency of</span>
<span class="sd">    interest, while synchrotron self-absorption may occur at or near the injection</span>
<span class="sd">    frequency. Typical examples include early-time shocks or low-density systems</span>
<span class="sd">    where electron cooling is negligible but SSA shapes the low-frequency spectrum.</span>

<span class="sd">    The spectrum is constructed using **scale-free smoothed broken power laws</span>
<span class="sd">    (SFBPLs)** and evaluated entirely in log-space to ensure numerical stability and</span>
<span class="sd">    smooth transitions between spectral segments.</span>

<span class="sd">    For theoretical background and derivations, see :ref:`synchrotron_theory` and</span>
<span class="sd">    :ref:`synch_sed_theory`.</span>

<span class="sd">    .. rubric:: Spectral Structure</span>

<span class="sd">    The synchrotron spectrum is classified into one of two **self-absorption</span>
<span class="sd">    regimes**, based on the ordering of the characteristic frequencies:</span>

<span class="sd">    - Injection frequency :math:`\nu_m`,</span>
<span class="sd">    - Self-absorption frequency :math:`\nu_a`,</span>
<span class="sd">    - Maximum synchrotron frequency :math:`\nu_{\max}`.</span>

<span class="sd">    The supported configurations are:</span>

<span class="sd">    - **Optically thin at the injection frequency**</span>
<span class="sd">      (:math:`\nu_a &lt; \nu_m &lt; \nu_{\max}`)</span>

<span class="sd">    - **Optically thick at the injection frequency**</span>
<span class="sd">      (:math:`\nu_m &lt; \nu_a &lt; \nu_{\max}`)</span>

<span class="sd">    There is no physically relevant regime with</span>
<span class="sd">    :math:`\nu_a &gt; \nu_{\max}` in the absence of radiative cooling.</span>

<span class="sd">    The selected regime applies **globally** to the spectrum and does not depend on</span>
<span class="sd">    the frequency grid used for evaluation.</span>

<span class="sd">    .. rubric:: SED Parameters</span>

<span class="sd">    The parameters entering this SED fall into three conceptual categories.</span>

<span class="sd">    .. tab-set::</span>

<span class="sd">        .. tab-item:: Free parameters (phenomenological)</span>

<span class="sd">            These parameters define the observable structure of the SED and are</span>
<span class="sd">            typically inferred directly from broadband data.</span>

<span class="sd">            .. list-table::</span>
<span class="sd">                :widths: 25 15 60</span>
<span class="sd">                :header-rows: 1</span>

<span class="sd">                * - Parameter</span>
<span class="sd">                  - Symbol</span>
<span class="sd">                  - Description</span>
<span class="sd">                * - Normalization flux density</span>
<span class="sd">                  - :math:`F_{\nu,\mathrm{norm}}`</span>
<span class="sd">                  - Flux density of the **dominant optically thin emitting population**.</span>
<span class="sd">                    In the non-cooling SSA case, this corresponds to the optically thin</span>
<span class="sd">                    flux at the injection frequency :math:`\nu_m`,</span>
<span class="sd">                    i.e. :math:`F_{\nu,\mathrm{norm}} = F_\nu(\nu_m)`.</span>
<span class="sd">                * - Injection frequency</span>
<span class="sd">                  - :math:`\nu_m`</span>
<span class="sd">                  - Synchrotron characteristic frequency of the minimum-energy</span>
<span class="sd">                    electrons.</span>
<span class="sd">                * - Maximum frequency</span>
<span class="sd">                  - :math:`\nu_{\max}`</span>
<span class="sd">                  - High-frequency synchrotron cutoff.</span>

<span class="sd">        .. tab-item:: Hyper-parameters</span>

<span class="sd">            These parameters control the *shape* of the spectrum but are not usually</span>
<span class="sd">            directly constrained by broadband observations.</span>

<span class="sd">            .. list-table::</span>
<span class="sd">                :widths: 25 15 60</span>
<span class="sd">                :header-rows: 1</span>

<span class="sd">                * - Parameter</span>
<span class="sd">                  - Symbol</span>
<span class="sd">                  - Description</span>
<span class="sd">                * - Electron power-law index</span>
<span class="sd">                  - :math:`p`</span>
<span class="sd">                  - Index of the injected electron energy distribution,</span>
<span class="sd">                    :math:`N(\gamma) \propto \gamma^{-p}`.</span>
<span class="sd">                * - Smoothing parameter</span>
<span class="sd">                  - :math:`s`</span>
<span class="sd">                  - Controls the sharpness of the SSA and injection-frequency</span>
<span class="sd">                    transitions.</span>
<span class="sd">                * - Emission solid angle</span>
<span class="sd">                  - :math:`\Omega`</span>
<span class="sd">                  - Effective emitting area divided by distance squared.</span>
<span class="sd">                * - Minimum Lorentz factor</span>
<span class="sd">                  - :math:`\gamma_m`</span>
<span class="sd">                  - Minimum electron Lorentz factor used in normalization.</span>

<span class="sd">        .. tab-item:: Derived parameters (internal)</span>

<span class="sd">            These quantities are **not user inputs**, but are computed internally</span>
<span class="sd">            from the supplied parameters.</span>

<span class="sd">            .. list-table::</span>
<span class="sd">                :widths: 25 15 60</span>
<span class="sd">                :header-rows: 1</span>

<span class="sd">                * - Quantity</span>
<span class="sd">                  - Symbol</span>
<span class="sd">                  - Description</span>
<span class="sd">                * - Self-absorption frequency</span>
<span class="sd">                  - :math:`\nu_a`</span>
<span class="sd">                  - Synchrotron self-absorption break frequency.</span>
<span class="sd">                * - SSA regime</span>
<span class="sd">                  - —</span>
<span class="sd">                  - Discrete identifier selecting the global SSA spectral branch.</span>

<span class="sd">    .. rubric:: Normalization and Closure</span>

<span class="sd">    The SED is **always normalized using**</span>
<span class="sd">    :math:`F_{\nu,\mathrm{norm}}`, defined as the flux density of the dominant</span>
<span class="sd">    optically thin electron population.</span>

<span class="sd">    In the SSA-only, non-cooling case, this population emits at the injection</span>
<span class="sd">    frequency :math:`\nu_m`, so the normalization is anchored at</span>
<span class="sd">    :math:`F_\nu(\nu_m)` regardless of whether the spectrum is optically thick or</span>
<span class="sd">    thin at that frequency. If the spectrum is optically thick at the peak, the</span>
<span class="sd">    normalization is propagated self-consistently to the true spectral maximum.</span>

<span class="sd">    Optional closure relations are provided to map physical model parameters</span>
<span class="sd">    (e.g. magnetic field strength, emitting volume, electron energy fractions)</span>
<span class="sd">    onto the phenomenological SED parameters under assumed microphysical</span>
<span class="sd">    conditions such as equipartition.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :class:`SynchrotronSED`</span>
<span class="sd">        Base class for synchrotron SED implementations.</span>
<span class="sd">    :class:`MultiSpectrumSynchrotronSED`</span>
<span class="sd">        Base class for multi-regime synchrotron SEDs.</span>
<span class="sd">    :class:`PowerLaw_SynchrotronSED`</span>
<span class="sd">        Canonical optically thin synchrotron SED without cooling or SSA.</span>
<span class="sd">    :class:`PowerLaw_Cooling_SynchrotronSED`</span>
<span class="sd">        Synchrotron SED with radiative cooling and no SSA.</span>
<span class="sd">    :class:`PowerLaw_Cooling_SSA_SynchrotronSED`</span>
<span class="sd">        Synchrotron SED including both cooling and self-absorption.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Evaluate a synchrotron SED with self-absorption and no cooling:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import numpy as np</span>
<span class="sd">        import astropy.units as u</span>
<span class="sd">        from triceratops.radiation.synchrotron import (</span>
<span class="sd">            PowerLaw_SSA_SynchrotronSED,</span>
<span class="sd">        )</span>

<span class="sd">        sed = PowerLaw_SSA_SynchrotronSED()</span>

<span class="sd">        nu = np.logspace(8, 14, 500) * u.Hz</span>

<span class="sd">        F_nu = sed.sed(</span>
<span class="sd">            nu=nu,</span>
<span class="sd">            nu_m=1e11 * u.Hz,</span>
<span class="sd">            F_norm=1e-26 * u.erg / (u.cm**2 * u.s * u.Hz),</span>
<span class="sd">            p=2.5,</span>
<span class="sd">            s=-0.05,</span>
<span class="sd">        )</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">SPECTRUM_FUNCTIONS</span> <span class="o">=</span> <span class="n">_SynchrotronSSASEDFunctions</span>

    <span class="c1"># ============================================================ #</span>
    <span class="c1"># Regime determination                                        #</span>
    <span class="c1"># ============================================================ #</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_sed_regime</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">log_nu_m</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_nu_a</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="o">**</span><span class="n">_</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine the global SSA spectral regime for a non-cooling synchrotron spectrum.</span>

<span class="sd">        This low-level method classifies the synchrotron spectrum into one of two</span>
<span class="sd">        **self-absorption regimes**, assuming:</span>

<span class="sd">        - No radiative cooling,</span>
<span class="sd">        - A single-zone, homogeneous emitting region,</span>
<span class="sd">        - A power-law electron energy distribution.</span>

<span class="sd">        The classification depends solely on the ordering of the characteristic</span>
<span class="sd">        frequencies:</span>

<span class="sd">        - Injection frequency :math:`\nu_m`,</span>
<span class="sd">        - Synchrotron self-absorption frequency :math:`\nu_a`.</span>

<span class="sd">        The supported regimes are:</span>

<span class="sd">        - :math:`\nu_a &lt; \nu_m` — optically thin at the injection frequency,</span>
<span class="sd">        - :math:`\nu_a &gt; \nu_m` — optically thick at the injection frequency.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        log_nu_m : float</span>
<span class="sd">            Natural logarithm of the injection frequency :math:`\nu_m`.</span>
<span class="sd">        log_nu_a : float</span>
<span class="sd">            Natural logarithm of the synchrotron self-absorption frequency</span>
<span class="sd">            :math:`\nu_a`.</span>
<span class="sd">        **_ :</span>
<span class="sd">            Additional unused keyword arguments, accepted for API compatibility with</span>
<span class="sd">            multi-regime SED classes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        regime : enum-like</span>
<span class="sd">            Member of :attr:`SPECTRUM_FUNCTIONS` identifying the global SSA spectral</span>
<span class="sd">            regime.</span>
<span class="sd">        metadata : dict</span>
<span class="sd">            Empty dictionary (present for API consistency).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This method performs **no unit validation**.</span>
<span class="sd">        - Radiative cooling, stratified SSA, and high-energy cutoffs are not considered.</span>
<span class="sd">        - The returned regime applies **globally** to the SED.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">log_nu_a</span> <span class="o">&lt;</span> <span class="n">log_nu_m</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_1</span><span class="p">,</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_2</span><span class="p">,</span> <span class="p">{}</span>

<div class="viewcode-block" id="PowerLaw_SSA_SynchrotronSED.determine_sed_regime">
<a class="viewcode-back" href="../../../_as_gen/radiation.synchrotron.SEDs.PowerLaw_SSA_SynchrotronSED.determine_sed_regime.html#radiation.synchrotron.SEDs.PowerLaw_SSA_SynchrotronSED.determine_sed_regime">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">determine_sed_regime</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">nu_m</span><span class="p">:</span> <span class="s2">&quot;_UnitBearingScalarLike&quot;</span><span class="p">,</span>
        <span class="n">F_norm</span><span class="p">:</span> <span class="s2">&quot;_UnitBearingScalarLike&quot;</span><span class="p">,</span>
        <span class="n">omega</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span>
        <span class="n">gamma_m</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">p</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">3.0</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine the global SSA synchrotron spectral regime from phenomenological inputs.</span>

<span class="sd">        This user-facing method determines whether a non-cooling synchrotron spectrum is</span>
<span class="sd">        **optically thin or optically thick at the injection frequency**. The</span>
<span class="sd">        synchrotron self-absorption frequency :math:`\nu_a` is computed internally from</span>
<span class="sd">        the supplied flux normalization and physical parameters.</span>

<span class="sd">        The classification is based on the ordering of:</span>

<span class="sd">        - the injection frequency :math:`\nu_m`, and</span>
<span class="sd">        - the inferred self-absorption frequency :math:`\nu_a`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nu_m : ~astropy.units.Quantity or float</span>
<span class="sd">            Injection (minimum-electron) synchrotron frequency :math:`\nu_m`.</span>
<span class="sd">        F_norm : ~astropy.units.Quantity or float</span>
<span class="sd">            Flux density normalization anchored at :math:`\nu_m`,</span>
<span class="sd">            i.e. :math:`F_\nu(\nu_m)`.</span>
<span class="sd">        omega : float, optional</span>
<span class="sd">            Effective emission solid angle :math:`\Omega = A / D^2`.</span>
<span class="sd">            Default is :math:`4\pi`.</span>
<span class="sd">        gamma_m : float, optional</span>
<span class="sd">            Minimum electron Lorentz factor :math:`\gamma_m`.</span>
<span class="sd">            Default is ``1.0``.</span>
<span class="sd">        p : float, optional</span>
<span class="sd">            Power-law index of the injected electron energy distribution.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        regime : enum-like</span>
<span class="sd">            Member of :attr:`SPECTRUM_FUNCTIONS` identifying the global synchrotron</span>
<span class="sd">            self-absorption regime.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This method assumes a **non-cooling**, single-zone synchrotron source.</span>
<span class="sd">        - The SSA frequency is inferred analytically from the supplied normalization.</span>
<span class="sd">        - The returned regime applies **globally** to the SED.</span>
<span class="sd">        - Units are validated and coerced internally.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nu_m</span> <span class="o">=</span> <span class="n">ensure_in_units</span><span class="p">(</span><span class="n">nu_m</span><span class="p">,</span> <span class="s2">&quot;Hz&quot;</span><span class="p">)</span>
        <span class="n">F_norm</span> <span class="o">=</span> <span class="n">ensure_in_units</span><span class="p">(</span><span class="n">F_norm</span><span class="p">,</span> <span class="s2">&quot;erg s^-1 cm^-2 Hz^-1&quot;</span><span class="p">)</span>

        <span class="n">log_nu_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">nu_m</span><span class="p">)</span>
        <span class="n">log_F_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">F_norm</span><span class="p">)</span>
        <span class="n">log_omega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">omega</span><span class="p">)</span>
        <span class="n">log_gamma_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">gamma_m</span><span class="p">)</span>

        <span class="n">log_nu_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_ssa_frequency_from_F_norm</span><span class="p">(</span>
            <span class="n">log_F_norm</span><span class="p">,</span>
            <span class="n">log_nu_m</span><span class="p">,</span>
            <span class="n">log_omega</span><span class="p">,</span>
            <span class="n">log_gamma_m</span><span class="p">,</span>
            <span class="n">p</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">regime</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_sed_regime</span><span class="p">(</span>
            <span class="n">log_nu_m</span><span class="o">=</span><span class="n">log_nu_m</span><span class="p">,</span>
            <span class="n">log_nu_a</span><span class="o">=</span><span class="n">log_nu_a</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">regime</span></div>


    <span class="c1"># ============================================================ #</span>
    <span class="c1"># SSA frequency computation                                   #</span>
    <span class="c1"># ============================================================ #</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_ssa_frequency_from_F_norm</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">log_F_norm</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_nu_m</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_omega</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_gamma_m</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">p</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the synchrotron self-absorption frequency from an anchored optically thin normalization.</span>

<span class="sd">        This method infers the synchrotron self-absorption frequency :math:`\nu_a` for a</span>
<span class="sd">        non-cooling synchrotron spectrum that is **normalized at the injection</span>
<span class="sd">        frequency** :math:`\nu_m`, when the ordering of :math:`\nu_a` relative to</span>
<span class="sd">        :math:`\nu_m` is not known a priori.</span>

<span class="sd">        Two candidate solutions are evaluated:</span>

<span class="sd">        1. **Optically thin at the injection frequency** (:math:`\nu_a &lt; \nu_m`)</span>

<span class="sd">           .. math::</span>

<span class="sd">               \nu_a \propto</span>
<span class="sd">               \left(</span>
<span class="sd">                   \frac{F_\nu(\nu_m)}</span>
<span class="sd">                        {m_e c^2 \, \Omega \, \gamma_m}</span>
<span class="sd">               \right)^{6/13}</span>
<span class="sd">               \nu_m^{1/13}</span>

<span class="sd">        2. **Optically thick at the injection frequency** (:math:`\nu_a &gt; \nu_m`)</span>

<span class="sd">           .. math::</span>

<span class="sd">               \nu_a \propto</span>
<span class="sd">               \left(</span>
<span class="sd">                   \frac{F_\nu(\nu_m)}</span>
<span class="sd">                        {m_e c^2 \, \Omega \, \gamma_m}</span>
<span class="sd">               \right)^{2/(p+4)}</span>
<span class="sd">               \nu_m^{p/(p+4)}</span>

<span class="sd">        The physically valid solution is selected by enforcing **self-consistent</span>
<span class="sd">        frequency ordering**.</span>

<span class="sd">        All calculations are performed in **natural logarithmic CGS units**.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        log_F_norm : float</span>
<span class="sd">            Natural logarithm of the flux normalization anchored at</span>
<span class="sd">            :math:`\nu_m`, i.e. :math:`\log F_\nu(\nu_m)`.</span>
<span class="sd">        log_nu_m : float</span>
<span class="sd">            Natural logarithm of the injection frequency :math:`\nu_m`.</span>
<span class="sd">        log_omega : float</span>
<span class="sd">            Natural logarithm of the effective emission solid angle</span>
<span class="sd">            :math:`\Omega = A / D^2`.</span>
<span class="sd">        log_gamma_m : float</span>
<span class="sd">            Natural logarithm of the minimum electron Lorentz factor</span>
<span class="sd">            :math:`\gamma_m`.</span>
<span class="sd">        p : float</span>
<span class="sd">            Power-law index of the injected electron energy distribution.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        log_nu_a : float</span>
<span class="sd">            Natural logarithm of the synchrotron self-absorption frequency</span>
<span class="sd">            :math:`\nu_a`.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        RuntimeError</span>
<span class="sd">            If neither candidate solution satisfies the required frequency ordering.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This method applies only to **non-cooling synchrotron spectra**.</span>
<span class="sd">        - The returned solution is guaranteed to be **self-consistent** with the</span>
<span class="sd">          assumed spectral ordering.</span>
<span class="sd">        - No unit validation is performed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">log_Q</span> <span class="o">=</span> <span class="n">log_F_norm</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">electron_rest_mass_cgs</span><span class="p">)</span> <span class="o">-</span> <span class="n">log_omega</span> <span class="o">-</span> <span class="n">log_gamma_m</span>

        <span class="c1"># Candidate: optically thin at the peak (nu_a &lt; nu_m)</span>
        <span class="n">log_nu_a_thin</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span> <span class="o">*</span> <span class="n">log_Q</span> <span class="o">/</span> <span class="mi">13</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">log_nu_m</span> <span class="o">/</span> <span class="mi">13</span><span class="p">)</span>
        <span class="n">log_nu_a_thick</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">log_Q</span> <span class="o">/</span> <span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">4</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="n">log_nu_m</span> <span class="o">/</span> <span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">4</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">log_nu_a_thin</span> <span class="o">&lt;</span> <span class="n">log_nu_m</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">log_nu_a_thin</span>
        <span class="k">elif</span> <span class="n">log_nu_a_thick</span> <span class="o">&gt;</span> <span class="n">log_nu_m</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">log_nu_a_thick</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Could not determine a self-consistent SSA frequency from the supplied normalization.&quot;</span><span class="p">)</span>

    <span class="c1"># ============================================================ #</span>
    <span class="c1"># Regime-specific kernel                                      #</span>
    <span class="c1"># ============================================================ #</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_log_opt_sed_from_regime</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">log_nu</span><span class="p">,</span>
        <span class="n">regime</span><span class="p">,</span>
        <span class="n">log_nu_m</span><span class="p">,</span>
        <span class="n">log_nu_a</span><span class="p">,</span>
        <span class="n">log_nu_max</span><span class="p">,</span>
        <span class="n">log_F_norm</span><span class="p">,</span>
        <span class="n">p</span><span class="p">,</span>
        <span class="n">s</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the log-space synchrotron SED for a fixed SSA spectral regime.</span>

<span class="sd">        This method dispatches to the appropriate **regime-specific numerical</span>
<span class="sd">        kernel** for synchrotron emission with self-absorption and applies the</span>
<span class="sd">        overall flux normalization.</span>

<span class="sd">        All spectral-shape logic is contained in the regime-specific kernel</span>
<span class="sd">        functions; this method performs no regime determination.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        log_nu : array-like</span>
<span class="sd">            Natural logarithm of the frequencies at which to evaluate the SED.</span>
<span class="sd">        regime : enum</span>
<span class="sd">            SSA spectral regime identifier returned by</span>
<span class="sd">            :meth:`_compute_sed_regime`.</span>
<span class="sd">        log_nu_m : float</span>
<span class="sd">            Natural logarithm of the injection frequency</span>
<span class="sd">            :math:`\nu_m`.</span>
<span class="sd">        log_nu_a : float</span>
<span class="sd">            Natural logarithm of the self-absorption frequency</span>
<span class="sd">            :math:`\nu_a`.</span>
<span class="sd">        log_nu_max : float</span>
<span class="sd">            Natural logarithm of the maximum synchrotron frequency</span>
<span class="sd">            :math:`\nu_{\max}`.</span>
<span class="sd">        log_F_norm : float</span>
<span class="sd">            Natural logarithm of the peak flux density</span>
<span class="sd">            :math:`F_{\nu,\mathrm{pk}}`.</span>
<span class="sd">        p : float</span>
<span class="sd">            Electron energy power-law index.</span>
<span class="sd">        s : float</span>
<span class="sd">            Smoothness parameter for the smoothed broken power-law (SBPL)</span>
<span class="sd">            transitions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        log_sed : array-like</span>
<span class="sd">            Natural logarithm of the flux density</span>
<span class="sd">            :math:`\log F_\nu` evaluated at ``log_nu``.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        RuntimeError</span>
<span class="sd">            If an unrecognized SSA regime identifier is supplied.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This method assumes a **non-cooling, SSA-only** synchrotron spectrum.</span>
<span class="sd">        - The optically thick branch includes an explicit normalization shift to ensure</span>
<span class="sd">          continuity with the anchored normalization at :math:`\nu_m`.</span>
<span class="sd">        - No unit validation is performed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">regime</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_1</span><span class="p">:</span>
            <span class="n">log_sed</span> <span class="o">=</span> <span class="n">_log_powerlaw_sbpl_sed_ssa_1</span><span class="p">(</span><span class="n">log_nu</span><span class="p">,</span> <span class="n">log_nu_m</span><span class="p">,</span> <span class="n">log_nu_a</span><span class="p">,</span> <span class="n">log_nu_max</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="o">+</span> <span class="n">log_F_norm</span>
        <span class="k">elif</span> <span class="n">regime</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPECTRUM_FUNCTIONS</span><span class="o">.</span><span class="n">SPECTRUM_2</span><span class="p">:</span>
            <span class="n">log_sed</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">_log_powerlaw_sbpl_sed_ssa_2</span><span class="p">(</span><span class="n">log_nu</span><span class="p">,</span> <span class="n">log_nu_m</span><span class="p">,</span> <span class="n">log_nu_a</span><span class="p">,</span> <span class="n">log_nu_max</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
                <span class="o">+</span> <span class="n">log_F_norm</span>
                <span class="o">-</span> <span class="p">((</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">log_nu_a</span> <span class="o">-</span> <span class="n">log_nu_m</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Unrecognized SSA regime.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">log_sed</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_log_opt_sed</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">log_nu</span><span class="p">:</span> <span class="s2">&quot;_ArrayLike&quot;</span><span class="p">,</span>
        <span class="n">log_nu_m</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_nu_max</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_F_norm</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_omega</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_gamma_m</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">p</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">3.0</span><span class="p">,</span>
        <span class="n">s</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the log-space synchrotron SED with self-absorption and no cooling.</span>

<span class="sd">        This optimized internal method orchestrates the full SED evaluation by:</span>

<span class="sd">        1. Computing the synchrotron self-absorption frequency :math:`\nu_a`,</span>
<span class="sd">        2. Determining the global SSA spectral regime,</span>
<span class="sd">        3. Dispatching to the appropriate regime-specific SED kernel.</span>

<span class="sd">        All calculations are performed in **natural logarithmic CGS units**.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        log_nu : array-like</span>
<span class="sd">            Natural logarithm of the frequencies at which to evaluate the SED.</span>
<span class="sd">        log_nu_m : float</span>
<span class="sd">            Natural logarithm of the injection frequency</span>
<span class="sd">            :math:`\nu_m`.</span>
<span class="sd">        log_nu_max : float</span>
<span class="sd">            Natural logarithm of the maximum synchrotron frequency</span>
<span class="sd">            :math:`\nu_{\max}`.</span>
<span class="sd">        log_F_norm : float</span>
<span class="sd">            Natural logarithm of the peak flux density</span>
<span class="sd">            :math:`F_{\nu,\mathrm{pk}}`.</span>
<span class="sd">        log_omega : float</span>
<span class="sd">            Natural logarithm of the effective emission solid angle</span>
<span class="sd">            :math:`\Omega = A / D^2`.</span>
<span class="sd">        log_gamma_m : float</span>
<span class="sd">            Natural logarithm of the minimum electron Lorentz factor</span>
<span class="sd">            :math:`\gamma_m`.</span>
<span class="sd">        p : float, optional</span>
<span class="sd">            Electron energy power-law index.</span>
<span class="sd">            Default is ``3.0``.</span>
<span class="sd">        s : float, optional</span>
<span class="sd">            SBPL smoothness parameter.</span>
<span class="sd">            Must be negative for physical behavior.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        log_sed : array-like</span>
<span class="sd">            Natural logarithm of the synchrotron flux density</span>
<span class="sd">            :math:`\log F_\nu` evaluated at ``log_nu``.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This method assumes a **non-cooling**, single-zone synchrotron source.</span>
<span class="sd">        - Synchrotron self-absorption is included using analytic scalings.</span>
<span class="sd">        - No unit validation is performed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Compute the self-absorption frequency</span>
        <span class="n">log_nu_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_ssa_frequency_from_F_norm</span><span class="p">(</span>
            <span class="n">log_F_norm</span><span class="p">,</span>
            <span class="n">log_nu_m</span><span class="p">,</span>
            <span class="n">log_omega</span><span class="p">,</span>
            <span class="n">log_gamma_m</span><span class="p">,</span>
            <span class="n">p</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Determine the global SSA regime</span>
        <span class="n">regime</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_sed_regime</span><span class="p">(</span>
            <span class="n">log_nu_m</span><span class="o">=</span><span class="n">log_nu_m</span><span class="p">,</span>
            <span class="n">log_nu_a</span><span class="o">=</span><span class="n">log_nu_a</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Dispatch to the regime-specific SED kernel</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_log_opt_sed_from_regime</span><span class="p">(</span>
            <span class="n">log_nu</span><span class="p">,</span>
            <span class="n">regime</span><span class="p">,</span>
            <span class="n">log_nu_m</span><span class="p">,</span>
            <span class="n">log_nu_a</span><span class="p">,</span>
            <span class="n">log_nu_max</span><span class="p">,</span>
            <span class="n">log_F_norm</span><span class="p">,</span>
            <span class="n">p</span><span class="p">,</span>
            <span class="n">s</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="PowerLaw_SSA_SynchrotronSED.sed">
<a class="viewcode-back" href="../../../_as_gen/radiation.synchrotron.SEDs.PowerLaw_SSA_SynchrotronSED.sed.html#radiation.synchrotron.SEDs.PowerLaw_SSA_SynchrotronSED.sed">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">sed</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">nu</span><span class="p">:</span> <span class="s2">&quot;_UnitBearingArrayLike&quot;</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">nu_m</span><span class="p">:</span> <span class="s2">&quot;_UnitBearingScalarLike&quot;</span><span class="p">,</span>
        <span class="n">F_norm</span><span class="p">:</span> <span class="s2">&quot;_UnitBearingScalarLike&quot;</span><span class="p">,</span>
        <span class="n">nu_max</span><span class="p">:</span> <span class="s2">&quot;_UnitBearingScalarLike&quot;</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
        <span class="n">omega</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span>
        <span class="n">gamma_m</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">p</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.5</span><span class="p">,</span>
        <span class="n">s</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the synchrotron spectral energy distribution with self-absorption and no radiative cooling.</span>

<span class="sd">        This method computes the flux density :math:`F_\nu` for a power-law</span>
<span class="sd">        electron population emitting synchrotron radiation in a homogeneous,</span>
<span class="sd">        single-zone region, including synchrotron self-absorption but **excluding</span>
<span class="sd">        radiative cooling**.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nu : ~astropy.units.Quantity or float-like or array-like</span>
<span class="sd">            Frequencies at which to evaluate the SED.</span>
<span class="sd">        nu_m : ~astropy.units.Quantity or float-like</span>
<span class="sd">            Injection (minimum-electron) synchrotron frequency</span>
<span class="sd">            :math:`\nu_m`.</span>
<span class="sd">        F_norm : ~astropy.units.Quantity or float-like</span>
<span class="sd">            The flux density normalization anchored at :math:`\nu_m`, i.e. :math:`F_\nu(\nu_m)`.</span>
<span class="sd">            See :ref:`sed_normalization` for details on how to compute this from physical parameters.</span>
<span class="sd">        nu_max : ~astropy.units.Quantity or float-like, optional</span>
<span class="sd">            Maximum synchrotron frequency</span>
<span class="sd">            :math:`\nu_{\max}`.</span>
<span class="sd">            Defaults to :math:`\infty`.</span>
<span class="sd">        omega : float, optional</span>
<span class="sd">            Effective emission solid angle</span>
<span class="sd">            :math:`\Omega = A / D^2`.</span>
<span class="sd">            Default is :math:`4\pi`.</span>
<span class="sd">        gamma_m : float, optional</span>
<span class="sd">            Minimum electron Lorentz factor</span>
<span class="sd">            :math:`\gamma_m`.</span>
<span class="sd">            Default is ``1.0``.</span>
<span class="sd">        p : float, optional</span>
<span class="sd">            Electron energy power-law index.</span>
<span class="sd">            Default is ``2.5``.</span>
<span class="sd">        s : float, optional</span>
<span class="sd">            SBPL smoothness parameter.</span>
<span class="sd">            Must be negative for physical behavior.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        flux : astropy.units.Quantity</span>
<span class="sd">            Flux density :math:`F_\nu` evaluated at ``nu``.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Units are validated and coerced internally.</span>
<span class="sd">        - The SSA regime is determined automatically and applies globally.</span>
<span class="sd">        - This model assumes a **non-cooling** synchrotron source.</span>
<span class="sd">        - The returned spectrum is continuous and differentiable due to SBPL</span>
<span class="sd">          smoothing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nu</span> <span class="o">=</span> <span class="n">ensure_in_units</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="s2">&quot;Hz&quot;</span><span class="p">)</span>
        <span class="n">nu_m</span> <span class="o">=</span> <span class="n">ensure_in_units</span><span class="p">(</span><span class="n">nu_m</span><span class="p">,</span> <span class="s2">&quot;Hz&quot;</span><span class="p">)</span>
        <span class="n">nu_max</span> <span class="o">=</span> <span class="n">ensure_in_units</span><span class="p">(</span><span class="n">nu_max</span><span class="p">,</span> <span class="s2">&quot;Hz&quot;</span><span class="p">)</span>
        <span class="n">log_F_norm</span> <span class="o">=</span> <span class="n">ensure_in_units</span><span class="p">(</span><span class="n">F_norm</span><span class="p">,</span> <span class="s2">&quot;erg s^-1 cm^-2 Hz^-1&quot;</span><span class="p">)</span>

        <span class="n">log_nu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">nu</span><span class="p">)</span>
        <span class="n">log_nu_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">nu_m</span><span class="p">)</span>
        <span class="n">log_nu_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">nu_max</span><span class="p">)</span>
        <span class="n">log_F_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">log_F_norm</span><span class="p">)</span>
        <span class="n">log_omega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">omega</span><span class="p">)</span>
        <span class="n">log_gamma_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">gamma_m</span><span class="p">)</span>

        <span class="n">log_sed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_log_opt_sed</span><span class="p">(</span>
            <span class="n">log_nu</span><span class="p">,</span>
            <span class="n">log_nu_m</span><span class="o">=</span><span class="n">log_nu_m</span><span class="p">,</span>
            <span class="n">log_nu_max</span><span class="o">=</span><span class="n">log_nu_max</span><span class="p">,</span>
            <span class="n">log_F_norm</span><span class="o">=</span><span class="n">log_F_norm</span><span class="p">,</span>
            <span class="n">log_omega</span><span class="o">=</span><span class="n">log_omega</span><span class="p">,</span>
            <span class="n">log_gamma_m</span><span class="o">=</span><span class="n">log_gamma_m</span><span class="p">,</span>
            <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span>
            <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_sed</span><span class="p">)</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">erg</span> <span class="o">/</span> <span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">s</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">cm</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">Hz</span><span class="p">)</span></div>


    <span class="c1"># ============================================================ #</span>
    <span class="c1"># Normalization closure relations                              #</span>
    <span class="c1"># ============================================================ #</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_opt_from_physics_to_params</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">log_B</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_V</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_D_L</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_Omega</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_gamma_min</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">log_gamma_max</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
        <span class="n">p</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.5</span><span class="p">,</span>
        <span class="n">epsilon_E</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">epsilon_B</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">pitch_average</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute phenomenological SSA synchrotron parameters from physical inputs.</span>

<span class="sd">        This low-level method converts physical parameters describing a homogeneous,</span>
<span class="sd">        single-zone synchrotron source into a **self-consistent set of phenomenological</span>
<span class="sd">        SED parameters** for a power-law electron population with synchrotron</span>
<span class="sd">        self-absorption and **no radiative cooling**.</span>

<span class="sd">        All calculations are performed in **natural logarithmic CGS units** for</span>
<span class="sd">        numerical stability. This method is intended for internal use only.</span>

<span class="sd">        The electron population is assumed to follow</span>

<span class="sd">        .. math::</span>

<span class="sd">            \frac{dN}{d\gamma} \propto \gamma^{-p},</span>
<span class="sd">            \qquad \gamma \ge \gamma_m,</span>

<span class="sd">        and is normalized using an equipartition prescription with energy fractions</span>
<span class="sd">        :math:`\epsilon_E` and :math:`\epsilon_B`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        log_B : float</span>
<span class="sd">            Natural logarithm of the magnetic field strength (Gauss).</span>
<span class="sd">        log_V : float</span>
<span class="sd">            Natural logarithm of the effective emitting volume (cm³).</span>
<span class="sd">        log_D_L : float</span>
<span class="sd">            Natural logarithm of the luminosity distance (cm).</span>
<span class="sd">        log_Omega : float</span>
<span class="sd">            Natural logarithm of the effective emission solid angle</span>
<span class="sd">            :math:`\Omega = A / D^2`.</span>
<span class="sd">        log_gamma_min : float</span>
<span class="sd">            Natural logarithm of the minimum electron Lorentz factor</span>
<span class="sd">            :math:`\gamma_m`.</span>
<span class="sd">        log_gamma_max : float, optional</span>
<span class="sd">            Natural logarithm of the maximum electron Lorentz factor.</span>
<span class="sd">        p : float, optional</span>
<span class="sd">            Power-law index of the electron energy distribution.</span>
<span class="sd">        epsilon_E : float, optional</span>
<span class="sd">            Fraction of post-shock internal energy carried by relativistic electrons.</span>
<span class="sd">        epsilon_B : float, optional</span>
<span class="sd">            Fraction of post-shock internal energy carried by magnetic fields.</span>
<span class="sd">        alpha : float, optional</span>
<span class="sd">            Electron pitch angle in radians (ignored if ``pitch_average=True``).</span>
<span class="sd">        pitch_average : bool, optional</span>
<span class="sd">            If ``True``, use pitch-angle averaged synchrotron emissivity.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        params : dict</span>
<span class="sd">            Dictionary containing logarithmic phenomenological parameters:</span>

<span class="sd">            - ``F_peak`` : :math:`\log F_{\nu,\mathrm{pk}}`</span>
<span class="sd">            - ``nu_m`` : :math:`\log \nu_m`</span>
<span class="sd">            - ``nu_a`` : :math:`\log \nu_a`</span>
<span class="sd">            - ``nu_max`` : :math:`\log \nu_{\max}`</span>
<span class="sd">            - ``regime`` : Enum identifying the global SSA spectral regime</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Radiative cooling is **not included**.</span>
<span class="sd">        - The SSA frequency is computed self-consistently from the normalization.</span>
<span class="sd">        - The returned regime applies **globally** to the spectrum.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Handle pitch angle details and the relevant values of</span>
        <span class="c1"># the log_chi parameter in each case. This allows us to</span>
        <span class="c1"># permit both a fixed pitch angle and pitch-angle averaging.</span>
        <span class="n">sin_alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">log_sin_alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">sin_alpha</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">pitch_average</span> <span class="k">else</span> <span class="mf">0.0</span>
        <span class="n">log_chi</span> <span class="o">=</span> <span class="n">_log_chi_cgs_iso</span> <span class="k">if</span> <span class="n">pitch_average</span> <span class="k">else</span> <span class="n">_log_chi_cgs</span>

        <span class="c1"># --- Compute the Frequencies --- #</span>
        <span class="c1"># We need to use the electron Lorentz factors to compute</span>
        <span class="c1"># the relevant synchrotron frequencies. This should be done for</span>
        <span class="c1"># gamma_c, gamma_min, and gamma_max.</span>
        <span class="n">log_nu_m</span> <span class="o">=</span> <span class="n">_opt_compute_log_synch_frequency</span><span class="p">(</span>
            <span class="n">log_gamma_min</span><span class="p">,</span>
            <span class="n">log_B</span><span class="p">,</span>
            <span class="n">sin_alpha</span><span class="o">=</span><span class="n">sin_alpha</span><span class="p">,</span>
            <span class="n">pitch_average</span><span class="o">=</span><span class="n">pitch_average</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">log_nu_max</span> <span class="o">=</span> <span class="n">_opt_compute_log_synch_frequency</span><span class="p">(</span>
            <span class="n">log_gamma_max</span><span class="p">,</span>
            <span class="n">log_B</span><span class="p">,</span>
            <span class="n">sin_alpha</span><span class="o">=</span><span class="n">sin_alpha</span><span class="p">,</span>
            <span class="n">pitch_average</span><span class="o">=</span><span class="n">pitch_average</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Compute the normalization flux at nu_m.</span>
        <span class="n">log_electron_norm</span> <span class="o">=</span> <span class="n">_opt_normalize_PL_from_magnetic_field</span><span class="p">(</span>
            <span class="n">log_B</span><span class="p">,</span>
            <span class="n">p</span><span class="p">,</span>
            <span class="n">gamma_min</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_gamma_min</span><span class="p">),</span>
            <span class="n">gamma_max</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_gamma_max</span><span class="p">),</span>
            <span class="n">epsilon_E</span><span class="o">=</span><span class="n">epsilon_E</span><span class="p">,</span>
            <span class="n">epsilon_B</span><span class="o">=</span><span class="n">epsilon_B</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">log_F_norm</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">log_chi</span>
            <span class="o">+</span> <span class="n">log_B</span>
            <span class="o">+</span> <span class="n">log_sin_alpha</span>  <span class="c1"># Zero if pitch averaged</span>
            <span class="o">+</span> <span class="n">log_electron_norm</span>
            <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="n">log_gamma_min</span>
            <span class="o">+</span> <span class="n">log_V</span>
            <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">log_D_L</span>
        <span class="p">)</span>

        <span class="c1"># Compute nu_ssa</span>
        <span class="n">log_nu_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_ssa_frequency_from_F_norm</span><span class="p">(</span>
            <span class="n">log_F_norm</span><span class="p">,</span>
            <span class="n">log_nu_m</span><span class="p">,</span>
            <span class="n">log_Omega</span><span class="p">,</span>
            <span class="n">log_gamma_min</span><span class="p">,</span>
            <span class="n">p</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">regime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_sed_regime</span><span class="p">(</span>
            <span class="n">log_nu_m</span><span class="p">,</span>
            <span class="n">log_nu_a</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># --- LOG AND RETURN --- #</span>
        <span class="k">if</span> <span class="n">triceratops_logger</span><span class="o">.</span><span class="n">isEnabledFor</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">):</span>
            <span class="n">triceratops_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;PowerLaw_Cooling_SSA_SynchrotronSED: completed normalization.&quot;</span><span class="p">,</span>
                <span class="n">extra</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;log_gamma_min&quot;</span><span class="p">:</span> <span class="n">log_gamma_min</span><span class="p">,</span>
                    <span class="s2">&quot;log_gamma_max&quot;</span><span class="p">:</span> <span class="n">log_gamma_max</span><span class="p">,</span>
                    <span class="s2">&quot;log_nu_m&quot;</span><span class="p">:</span> <span class="n">log_nu_m</span><span class="p">,</span>
                    <span class="s2">&quot;log_nu_max&quot;</span><span class="p">:</span> <span class="n">log_nu_max</span><span class="p">,</span>
                    <span class="s2">&quot;log_nu_a&quot;</span><span class="p">:</span> <span class="n">log_nu_a</span><span class="p">,</span>
                    <span class="s2">&quot;regime&quot;</span><span class="p">:</span> <span class="n">regime</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                    <span class="s2">&quot;log_electron_norm&quot;</span><span class="p">:</span> <span class="n">log_electron_norm</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;F_norm&quot;</span><span class="p">:</span> <span class="n">log_F_norm</span><span class="p">,</span>
            <span class="s2">&quot;nu_m&quot;</span><span class="p">:</span> <span class="n">log_nu_m</span><span class="p">,</span>
            <span class="s2">&quot;nu_a&quot;</span><span class="p">:</span> <span class="n">log_nu_a</span><span class="p">,</span>
            <span class="s2">&quot;nu_max&quot;</span><span class="p">:</span> <span class="n">log_nu_max</span><span class="p">,</span>
            <span class="s2">&quot;regime&quot;</span><span class="p">:</span> <span class="n">regime</span><span class="p">,</span>
        <span class="p">}</span>

<div class="viewcode-block" id="PowerLaw_SSA_SynchrotronSED.from_physics_to_params">
<a class="viewcode-back" href="../../../_as_gen/radiation.synchrotron.SEDs.PowerLaw_SSA_SynchrotronSED.from_physics_to_params.html#radiation.synchrotron.SEDs.PowerLaw_SSA_SynchrotronSED.from_physics_to_params">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_physics_to_params</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">B</span><span class="p">:</span> <span class="s2">&quot;_UnitBearingScalarLike&quot;</span><span class="p">,</span>
        <span class="n">V</span><span class="p">:</span> <span class="s2">&quot;_UnitBearingScalarLike&quot;</span><span class="p">,</span>
        <span class="n">D_L</span><span class="p">:</span> <span class="s2">&quot;_UnitBearingScalarLike&quot;</span><span class="p">,</span>
        <span class="n">Omega</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">gamma_min</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">gamma_max</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
        <span class="n">p</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.5</span><span class="p">,</span>
        <span class="n">epsilon_E</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">epsilon_B</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">pitch_average</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine SSA synchrotron SED parameters from physical inputs.</span>

<span class="sd">        This method computes the phenomenological parameters required to evaluate</span>
<span class="sd">        a **synchrotron spectral energy distribution with self-absorption and no</span>
<span class="sd">        radiative cooling** from a set of physical inputs describing the emitting</span>
<span class="sd">        region.</span>

<span class="sd">        The normalization follows an equipartition-based prescription, assuming</span>
<span class="sd">        fixed fractions of the post-shock internal energy reside in relativistic</span>
<span class="sd">        electrons (:math:`\epsilon_E`) and magnetic fields (:math:`\epsilon_B`).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        B : ~astropy.units.Quantity or float</span>
<span class="sd">            Magnetic field strength. Must be convertible to Gauss.</span>
<span class="sd">        V : ~astropy.units.Quantity or float</span>
<span class="sd">            Effective emitting volume. Must be convertible to ``cm^3``.</span>
<span class="sd">        D_L : ~astropy.units.Quantity or float</span>
<span class="sd">            Luminosity distance to the source. Must be convertible to ``cm``.</span>
<span class="sd">        Omega : float</span>
<span class="sd">            Effective emission solid angle :math:`\Omega = A / D^2`.</span>
<span class="sd">        gamma_min : float</span>
<span class="sd">            Minimum electron Lorentz factor :math:`\gamma_m`.</span>
<span class="sd">        gamma_max : float, optional</span>
<span class="sd">            Maximum electron Lorentz factor.</span>
<span class="sd">        p : float, optional</span>
<span class="sd">            Power-law index of the injected electron energy distribution.</span>
<span class="sd">        epsilon_E : float, optional</span>
<span class="sd">            Fraction of post-shock internal energy in relativistic electrons.</span>
<span class="sd">        epsilon_B : float, optional</span>
<span class="sd">            Fraction of post-shock internal energy in magnetic fields.</span>
<span class="sd">        alpha : float, optional</span>
<span class="sd">            Electron pitch angle in radians.</span>
<span class="sd">        pitch_average : bool, optional</span>
<span class="sd">            If ``True``, use pitch-angle averaged synchrotron emissivity.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        params : dict</span>
<span class="sd">            Dictionary containing the phenomenological SED parameters:</span>

<span class="sd">            - ``F_peak`` : Peak flux density (:math:`F_{\nu,\mathrm{pk}}`)</span>
<span class="sd">            - ``nu_m`` : Injection frequency :math:`\nu_m`</span>
<span class="sd">            - ``nu_a`` : Self-absorption frequency :math:`\nu_a`</span>
<span class="sd">            - ``nu_max`` : Maximum synchrotron frequency :math:`\nu_{\max}`</span>
<span class="sd">            - ``regime`` : Enum identifying the SSA spectral regime</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This method assumes a **single-zone, homogeneous emitting region**.</span>
<span class="sd">        - Radiative cooling is **not included**.</span>
<span class="sd">        - The returned parameters are guaranteed to be internally self-consistent.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Coerce things down to unit carrying values.</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">ensure_in_units</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="s2">&quot;G&quot;</span><span class="p">)</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">ensure_in_units</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="s2">&quot;cm^3&quot;</span><span class="p">)</span>
        <span class="n">D_L</span> <span class="o">=</span> <span class="n">ensure_in_units</span><span class="p">(</span><span class="n">D_L</span><span class="p">,</span> <span class="s2">&quot;cm&quot;</span><span class="p">)</span>

        <span class="c1"># Get everything in log-space. The low-level implementation is</span>
        <span class="c1"># done natively in log-space for stability.</span>
        <span class="n">log_B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
        <span class="n">log_V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
        <span class="n">log_D_L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">D_L</span><span class="p">)</span>
        <span class="n">log_Omega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">Omega</span><span class="p">)</span>

        <span class="n">log_gamma_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">gamma_min</span><span class="p">)</span>
        <span class="n">log_gamma_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">gamma_max</span><span class="p">)</span>

        <span class="c1"># Dispatch to the optimized low-level implementation.</span>
        <span class="n">params_log</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_opt_from_physics_to_params</span><span class="p">(</span>
            <span class="n">log_B</span><span class="o">=</span><span class="n">log_B</span><span class="p">,</span>
            <span class="n">log_V</span><span class="o">=</span><span class="n">log_V</span><span class="p">,</span>
            <span class="n">log_D_L</span><span class="o">=</span><span class="n">log_D_L</span><span class="p">,</span>
            <span class="n">log_Omega</span><span class="o">=</span><span class="n">log_Omega</span><span class="p">,</span>
            <span class="n">log_gamma_min</span><span class="o">=</span><span class="n">log_gamma_min</span><span class="p">,</span>
            <span class="n">log_gamma_max</span><span class="o">=</span><span class="n">log_gamma_max</span><span class="p">,</span>
            <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span>
            <span class="n">epsilon_E</span><span class="o">=</span><span class="n">epsilon_E</span><span class="p">,</span>
            <span class="n">epsilon_B</span><span class="o">=</span><span class="n">epsilon_B</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
            <span class="n">pitch_average</span><span class="o">=</span><span class="n">pitch_average</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Convert back to linear CGS units and return.</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;F_norm&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">params_log</span><span class="p">[</span><span class="s2">&quot;F_norm&quot;</span><span class="p">])</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">erg</span> <span class="o">/</span> <span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">cm</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">s</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">Hz</span><span class="p">),</span>
            <span class="s2">&quot;nu_m&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">params_log</span><span class="p">[</span><span class="s2">&quot;nu_m&quot;</span><span class="p">])</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">Hz</span><span class="p">,</span>
            <span class="s2">&quot;nu_a&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">params_log</span><span class="p">[</span><span class="s2">&quot;nu_a&quot;</span><span class="p">])</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">Hz</span><span class="p">,</span>
            <span class="s2">&quot;nu_max&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">params_log</span><span class="p">[</span><span class="s2">&quot;nu_max&quot;</span><span class="p">])</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">Hz</span><span class="p">,</span>
            <span class="s2">&quot;regime&quot;</span><span class="p">:</span> <span class="n">params_log</span><span class="p">[</span><span class="s2">&quot;regime&quot;</span><span class="p">],</span>
        <span class="p">}</span></div>
</div>



<div class="viewcode-block" id="SSA_SED_PowerLaw">
<a class="viewcode-back" href="../../../_as_gen/radiation.synchrotron.SEDs.SSA_SED_PowerLaw.html#radiation.synchrotron.SEDs.SSA_SED_PowerLaw">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SSA_SED_PowerLaw</span><span class="p">(</span><span class="n">SynchrotronSED</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Synchrotron self-absorbed (SSA) broken power-law spectral energy distribution.</span>

<span class="sd">    This class implements a phenomenological synchrotron spectral energy</span>
<span class="sd">    distribution characterized by a single smooth spectral break arising from</span>
<span class="sd">    synchrotron self-absorption (SSA). Below the break frequency, the spectrum is</span>
<span class="sd">    optically thick and follows a power-law slope of :math:`+5/2`; above the</span>
<span class="sd">    break, the spectrum is optically thin and follows a power-law slope of</span>
<span class="sd">    :math:`-(p-1)/2`, where :math:`p` is the power-law index of the electron</span>
<span class="sd">    energy distribution.</span>

<span class="sd">    The SED is implemented as a **smoothly broken power law**, ensuring numerical</span>
<span class="sd">    stability and differentiability across the SSA turnover. This makes the</span>
<span class="sd">    class well-suited for use in parameter inference, optimization, and</span>
<span class="sd">    likelihood-based modeling.</span>

<span class="sd">    In addition to forward evaluation of the SED, this class implements</span>
<span class="sd">    **analytic closure relations** that allow inversion between phenomenological</span>
<span class="sd">    SED parameters (the SSA break frequency and peak flux) and underlying</span>
<span class="sd">    physical properties of the emitting region (magnetic field strength and</span>
<span class="sd">    radius). These closure relations follow the formalism presented in</span>
<span class="sd">    :footcite:t:`demarchiRadioAnalysisSN2004C2022`.</span>

<span class="sd">    This class is intended for modeling radio synchrotron emission from</span>
<span class="sd">    approximately homogeneous emitting regions, such as those encountered in:</span>

<span class="sd">    - supernova radio afterglows,</span>
<span class="sd">    - compact object-powered transients,</span>
<span class="sd">    - synchrotron-emitting shells with a single dominant SSA turnover.</span>

<span class="sd">    No assumptions are made about time evolution, shock dynamics, or cooling</span>
<span class="sd">    regimes beyond those implicit in the broken power-law description.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The break frequency :math:`\nu_{\rm brk}` is defined as the frequency at</span>
<span class="sd">      which the optically thick and optically thin asymptotic power laws</span>
<span class="sd">      intersect.</span>
<span class="sd">    - The closure relations implemented here assume a power-law electron energy</span>
<span class="sd">      distribution with finite bounds</span>
<span class="sd">      :math:`\gamma_{\rm min} \le \gamma \le \gamma_{\rm max}`.</span>
<span class="sd">    - The special case :math:`p = 2` is not supported due to logarithmic</span>
<span class="sd">      divergences in the electron energy integral and must be handled</span>
<span class="sd">      separately.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    SynchrotronSED</span>
<span class="sd">        Abstract base class defining the interface for all synchrotron SED</span>
<span class="sd">        implementations.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. footbibliography::</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ================================================= #</span>
    <span class="c1"># Instantiation                                     #</span>
    <span class="c1"># ================================================= #</span>
<div class="viewcode-block" id="SSA_SED_PowerLaw.__init__">
<a class="viewcode-back" href="../../../_as_gen/radiation.synchrotron.SEDs.SSA_SED_PowerLaw.__init__.html#radiation.synchrotron.SEDs.SSA_SED_PowerLaw.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Instantiate the SSA SED object.&quot;&quot;&quot;</span>
        <span class="c1"># There are no class-wide constants to pre-compute for this SED.</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span></div>


    <span class="c1"># ================================================ #</span>
    <span class="c1"># SED Function Implementation                      #</span>
    <span class="c1"># ================================================ #</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_log_opt_sed</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">nu</span><span class="p">:</span> <span class="s2">&quot;_ArrayLike&quot;</span><span class="p">,</span>
        <span class="n">nu_brk</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">F_nu_brk</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">p</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">s</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;_ArrayLike&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Low-level optimized SSA broken power-law SED.</span>

<span class="sd">        This method implements the synchrotron self-absorbed (SSA) broken power-law SED</span>
<span class="sd">        in a performance-optimized manner. It assumes that all inputs are provided as</span>
<span class="sd">        dimensionless scalars or NumPy arrays in CGS units. No unit validation or safety</span>
<span class="sd">        checks are performed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nu: float or array-like</span>
<span class="sd">            Frequency at which to evaluate the SED (in Hz-equivalent CGS).</span>
<span class="sd">        nu_brk: float</span>
<span class="sd">            Break frequency (Hz-equivalent CGS).</span>
<span class="sd">        F_nu_brk: float</span>
<span class="sd">            Flux density at the break frequency (CGS units).</span>
<span class="sd">        p: float</span>
<span class="sd">            Power-law index of the electron energy distribution.</span>
<span class="sd">        s: float</span>
<span class="sd">            Smoothing parameter for the break.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float or array-like</span>
<span class="sd">            The computed SED value at the specified frequency. The output of this SED</span>
<span class="sd">            is in CGS units of erg s^-1 cm^-2 Hz^-1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">smoothed_BPL</span><span class="p">(</span>
            <span class="n">nu</span><span class="p">,</span>
            <span class="n">F_nu_brk</span><span class="p">,</span>
            <span class="n">nu_brk</span><span class="p">,</span>
            <span class="o">-</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>  <span class="c1"># optically thin index</span>
            <span class="p">(</span><span class="mi">5</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span>  <span class="c1"># optically thick index</span>
            <span class="n">s</span><span class="p">,</span>  <span class="c1"># smoothing parameter</span>
        <span class="p">)</span>

<div class="viewcode-block" id="SSA_SED_PowerLaw.sed">
<a class="viewcode-back" href="../../../_as_gen/radiation.synchrotron.SEDs.SSA_SED_PowerLaw.sed.html#radiation.synchrotron.SEDs.SSA_SED_PowerLaw.sed">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">sed</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">nu</span><span class="p">:</span> <span class="s2">&quot;_UnitBearingArrayLike&quot;</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">nu_brk</span><span class="p">:</span> <span class="s2">&quot;_UnitBearingArrayLike&quot;</span><span class="p">,</span>
        <span class="n">F_nu_brk</span><span class="p">:</span> <span class="s2">&quot;_UnitBearingArrayLike&quot;</span><span class="p">,</span>
        <span class="n">p</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">s</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the synchrotron self-absorbed (SSA) broken power-law SED.</span>

<span class="sd">        This is the user-facing interface for the SSA broken power-law spectral</span>
<span class="sd">        energy distribution. It validates units, coerces inputs to CGS, and</span>
<span class="sd">        dispatches to the optimized low-level backend implementation</span>
<span class="sd">        :meth:`_opt_sed`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nu : float, array-like, or astropy.units.Quantity</span>
<span class="sd">            Frequency at which to evaluate the SED. Default units are Hz.</span>
<span class="sd">        nu_brk : float or astropy.units.Quantity</span>
<span class="sd">            Break frequency of the SED. Default units are Hz.</span>
<span class="sd">        F_nu_brk : float or astropy.units.Quantity</span>
<span class="sd">            Flux density at the break frequency. Default units are</span>
<span class="sd">            erg s^-1 cm^-2 Hz^-1.</span>
<span class="sd">        p : float</span>
<span class="sd">            Power-law index of the electron energy distribution.</span>
<span class="sd">        s : float</span>
<span class="sd">            Smoothing parameter controlling the sharpness of the spectral break.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        astropy.units.Quantity</span>
<span class="sd">            Flux density evaluated at ``nu`` with units of</span>
<span class="sd">            erg s^-1 cm^-2 Hz^-1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># --- Unit validation and coercion --- #</span>
        <span class="n">nu</span> <span class="o">=</span> <span class="n">ensure_in_units</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Hz</span><span class="p">)</span>
        <span class="n">nu_brk</span> <span class="o">=</span> <span class="n">ensure_in_units</span><span class="p">(</span><span class="n">nu_brk</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Hz</span><span class="p">)</span>
        <span class="n">F_nu_brk</span> <span class="o">=</span> <span class="n">ensure_in_units</span><span class="p">(</span><span class="n">F_nu_brk</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">erg</span> <span class="o">/</span> <span class="n">u</span><span class="o">.</span><span class="n">s</span> <span class="o">/</span> <span class="n">u</span><span class="o">.</span><span class="n">cm</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">u</span><span class="o">.</span><span class="n">Hz</span><span class="p">)</span>

        <span class="c1"># --- Call optimized backend --- #</span>
        <span class="n">F_nu_cgs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_log_opt_sed</span><span class="p">(</span>
            <span class="n">nu</span><span class="o">=</span><span class="n">nu</span><span class="p">,</span>
            <span class="n">nu_brk</span><span class="o">=</span><span class="n">nu_brk</span><span class="p">,</span>
            <span class="n">F_nu_brk</span><span class="o">=</span><span class="n">F_nu_brk</span><span class="p">,</span>
            <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span>
            <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">F_nu_cgs</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">erg</span> <span class="o">/</span> <span class="n">u</span><span class="o">.</span><span class="n">s</span> <span class="o">/</span> <span class="n">u</span><span class="o">.</span><span class="n">cm</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">u</span><span class="o">.</span><span class="n">Hz</span></div>


    <span class="c1"># ================================================ #</span>
    <span class="c1"># Closure Relations.                               #</span>
    <span class="c1"># ================================================ #</span>
    <span class="c1"># For this SED, we implement the closure relations to go from</span>
    <span class="c1"># the phenomenological parameters (nu_brk, F_nu_brk) to the physical</span>
    <span class="c1"># parameters (B, R) and vice versa. This is implemented exactly as</span>
    <span class="c1"># done in DeMarchi+22.</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_opt_from_params_to_physics</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">nu_brk</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">F_nu_brk</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">distance</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">p</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">3.0</span><span class="p">,</span>
        <span class="n">f</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">theta</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">epsilon_B</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">epsilon_E</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">gamma_min</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">gamma_max</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e6</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the magnetic field and radius of the emitting region from a broken power-law synchrotron SED.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nu_brk: float or array-like</span>
<span class="sd">            The break frequency :math:`\nu_{\rm brk}` where the synchrotron SED transitions from</span>
<span class="sd">            optically thick to optically thin. This should be provided in GHz. May be provided either</span>
<span class="sd">            as a scalar float (for a single SED) or as a 1-D array (for multiple SEDs).</span>
<span class="sd">        F_nu_brk: float or array-like</span>
<span class="sd">            The flux density :math:`F_{\nu_{\rm brk}}` at the break frequency. This should be provided</span>
<span class="sd">            in Jansky (Jy). May be provided either as a scalar float (for a single SED) or as a 1-D array (for multiple</span>
<span class="sd">            SEDs).</span>
<span class="sd">        distance: float or array-like</span>
<span class="sd">            The distance to the source in Megaparsecs (Mpc). May be provided either as a scalar float (for a single SED)</span>
<span class="sd">            or as a 1-D array (for multiple SEDs).</span>
<span class="sd">        p: float or array-like</span>
<span class="sd">            The power-law index :math:`p` of the electron energy distribution. By default, this is 3.0. If provided as a</span>
<span class="sd">            float, the value is used for all SEDs. If provided as an array, its shape must be compatible with that of</span>
<span class="sd">            ``nu_brk``.</span>

<span class="sd">            .. warning::</span>

<span class="sd">                This function does not handle the case where :math:`p = 2` due to singularities in the underlying</span>
<span class="sd">                equations.</span>
<span class="sd">                Users must ensure that :math:`p` is not equal to 2 when calling this function.</span>

<span class="sd">        f: float or array-like</span>
<span class="sd">            The filling factor :math:`f` of the emitting region. Default is ``0.5``. If provided as a float, the value</span>
<span class="sd">            is</span>
<span class="sd">            used for all SEDs. If provided as an array, its shape must be compatible with that of ``nu_brk``.</span>
<span class="sd">        theta: float or array-like</span>
<span class="sd">            The pitch angle :math:`\theta` between the magnetic field and the line of sight, in radians.</span>
<span class="sd">            Default is ``pi/2`` (i.e., perpendicular). If provided as a float, the value is used for all SEDs.</span>
<span class="sd">            If provided as an array, its shape must be compatible with that of ``nu_brk``.</span>
<span class="sd">        epsilon_B: float or array-like</span>
<span class="sd">            The fraction of post-shock energy in magnetic fields, :math:`\epsilon_B`.</span>
<span class="sd">        epsilon_E: float or array-like</span>
<span class="sd">            The fraction of post-shock energy in relativistic electrons, :math:`\epsilon_E`.</span>
<span class="sd">        gamma_min: float or array-like</span>
<span class="sd">            The minimum Lorentz factor :math:`\gamma_{\rm min}` of the electron energy.</span>
<span class="sd">        gamma_max: float or array-like</span>
<span class="sd">            The maximum Lorentz factor :math:`\gamma_{\rm max}` of the electron energy.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        B: float or array-like</span>
<span class="sd">            The computed magnetic field strength :math:`B` in Gauss. The shape matches that of the input parameters.</span>
<span class="sd">        R: float or array-like</span>
<span class="sd">            The computed radius of the emitting region :math:`R` in cm. The shape matches that of the input parameters.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        See notes in the user-facing wrapper function `compute_BR_from_BPL` for details on the</span>
<span class="sd">        underlying physics and assumptions.</span>

<span class="sd">        Effective 1/19/26: We have modified this to work exclusively in log space due to issues with floating point</span>
<span class="sd">        truncation errors. Catastrophic cancellation caused significant loss of accuracy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Validate input parameters. We do NOT check explicitly for shape correctness of the arrays, instead opting</span>
        <span class="c1"># to allow an error to rise naturally if the shapes are incompatible during computation. We do want to ensure</span>
        <span class="c1"># that all of the constants are cast properly for array operations and masking.</span>
        <span class="n">p</span><span class="p">,</span> <span class="n">gamma_min</span><span class="p">,</span> <span class="n">gamma_max</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;f8&quot;</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">gamma_min</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;f8&quot;</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">gamma_max</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;f8&quot;</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="c1"># Obtain the synchrotron coefficients relevant for this scenario. We need c_1,c_5, and c_6.</span>
        <span class="n">c_5</span> <span class="o">=</span> <span class="n">compute_c5_parameter</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>  <span class="c1"># Should match shape of p.</span>
        <span class="n">c_6</span> <span class="o">=</span> <span class="n">compute_c6_parameter</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>  <span class="c1"># Should match shape of p.</span>
        <span class="n">c_1</span> <span class="o">=</span> <span class="n">c_1_cgs</span>  <span class="c1"># Scalar constant.</span>

        <span class="c1"># Construct the array for delta. See the documentation notes for details on the procedure here / physical</span>
        <span class="c1"># motivation. To do this efficiently, we pre-allocate the array and then fill in values based on the conditions.</span>
        <span class="c1"># Because we pre-allocate with ones, we only need to fill in values where p &lt; 2. In THIS IMPLEMENTATION, we</span>
        <span class="c1"># ignore</span>
        <span class="c1"># cases where p == 2 for efficiency; these should be screened for upstream if needed.</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">_p_lt_2_mask</span> <span class="o">=</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="mi">2</span>
        <span class="n">delta</span><span class="p">[</span><span class="n">_p_lt_2_mask</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">gamma_max</span><span class="p">[</span><span class="n">_p_lt_2_mask</span><span class="p">]</span> <span class="o">/</span> <span class="n">gamma_min</span><span class="p">[</span><span class="n">_p_lt_2_mask</span><span class="p">])</span> <span class="o">**</span> <span class="p">(</span>
            <span class="mi">2</span> <span class="o">-</span> <span class="n">p</span><span class="p">[</span><span class="n">_p_lt_2_mask</span><span class="p">]</span>
        <span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># Fill in values where p &lt; 2.</span>

        <span class="c1"># Construct the &quot;p_norm&quot; term used in the B and R calculations. This allows us to handle the two branches</span>
        <span class="c1"># of the solution (p &lt; 2 and p &gt; 2) in a unified way.</span>
        <span class="c1"># Note that we take the absolute value here to avoid issues with negative bases and fractional exponents.</span>
        <span class="c1"># The p == 2 case is handled upstream.</span>
        <span class="n">p_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mf">2.0</span><span class="p">)</span>

        <span class="c1"># Compute the electron energy floor using the gamma_min parameter and the standard formula.</span>
        <span class="n">E_l</span> <span class="o">=</span> <span class="n">electron_rest_energy_cgs</span> <span class="o">*</span> <span class="n">gamma_min</span>

        <span class="c1"># Normalize unit bearing values and convert them to logarithmic quantities for</span>
        <span class="c1"># numerical stability.</span>
        <span class="n">_log_nu_brk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">nu_brk</span> <span class="o">/</span> <span class="mi">5</span><span class="p">)</span>
        <span class="n">_log_F_nu_brk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">F_nu_brk</span><span class="p">)</span>
        <span class="n">_log_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span>
        <span class="n">_log_c1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">c_1</span><span class="p">)</span>
        <span class="n">_log_E_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">E_l</span><span class="p">)</span>
        <span class="n">_log_delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>
        <span class="n">_log_sin_theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span>
        <span class="n">_log_p_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p_norm</span><span class="p">)</span>

        <span class="c1"># Compute the magnetic field following equation (16) of DeMarchi+22. We break this into</span>
        <span class="c1"># components for clarity. The operation should be heavily CPU bound, so this should not have any impact</span>
        <span class="c1"># on optimization.</span>
        <span class="c1">#</span>
        <span class="c1"># Here nu_brk is in GHz, E_l is in erg, distance is in Mpc, F_nu_brk is in Jy, and B will be in Gauss.</span>
        <span class="n">_log_B_coeff</span> <span class="o">=</span> <span class="mf">21.6396</span> <span class="o">+</span> <span class="n">_log_nu_brk</span> <span class="o">-</span> <span class="n">_log_c1</span>
        <span class="n">_log_B_num</span> <span class="o">=</span> <span class="p">(</span>
            <span class="o">-</span><span class="mf">51.41402455</span>
            <span class="o">+</span> <span class="p">((</span><span class="mi">4</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="n">_log_E_l</span><span class="p">)</span>
            <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">_log_delta</span><span class="p">)</span>
            <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">epsilon_B</span> <span class="o">/</span> <span class="n">epsilon_E</span><span class="p">))</span>
            <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">c_5</span><span class="p">)</span>
            <span class="o">+</span> <span class="p">((</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">5</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="n">_log_sin_theta</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">_log_B_denom</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">_log_p_norm</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">_log_distance</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">_log_F_nu_brk</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)))</span> <span class="o">+</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">c_6</span><span class="p">))</span>
        <span class="n">_log_B</span> <span class="o">=</span> <span class="n">_log_B_coeff</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">13</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">p</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">_log_B_num</span> <span class="o">-</span> <span class="n">_log_B_denom</span><span class="p">)</span>

        <span class="c1"># Compute the radius following equation (17) of DeMarchi+22. We break this into parts as well on the same</span>
        <span class="c1"># basis as above.</span>
        <span class="n">_log_R_coeff</span> <span class="o">=</span> <span class="o">-</span><span class="mf">21.63956</span> <span class="o">+</span> <span class="n">_log_c1</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">_log_nu_brk</span><span class="p">)</span>
        <span class="n">_log_R_t1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">12</span> <span class="o">*</span> <span class="n">epsilon_B</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">6</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">c_5</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">5</span> <span class="o">+</span> <span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">c_6</span><span class="p">)</span>
        <span class="n">_log_R_t2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span> <span class="o">+</span> <span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="mf">59.818022</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">_log_sin_theta</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">5</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">12</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="n">_log_distance</span>
        <span class="n">_log_R_t3</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="n">_log_E_l</span> <span class="o">+</span> <span class="p">(</span><span class="mi">6</span> <span class="o">+</span> <span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="n">_log_F_nu_brk</span>
        <span class="n">_log_R_t4</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">epsilon_E</span><span class="p">)</span> <span class="o">+</span> <span class="n">_log_p_norm</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">f</span> <span class="o">/</span> <span class="mf">0.5</span><span class="p">))</span>
        <span class="n">_log_R</span> <span class="o">=</span> <span class="n">_log_R_coeff</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">13</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">p</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">_log_R_t1</span> <span class="o">+</span> <span class="n">_log_R_t2</span> <span class="o">+</span> <span class="n">_log_R_t3</span> <span class="o">+</span> <span class="n">_log_R_t4</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">_log_B</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">_log_R</span><span class="p">)</span>

<div class="viewcode-block" id="SSA_SED_PowerLaw.from_params_to_physics">
<a class="viewcode-back" href="../../../_as_gen/radiation.synchrotron.SEDs.SSA_SED_PowerLaw.from_params_to_physics.html#radiation.synchrotron.SEDs.SSA_SED_PowerLaw.from_params_to_physics">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_params_to_physics</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">nu_brk</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">],</span>
        <span class="n">F_nu_brk</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">],</span>
        <span class="n">distance</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">p</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">3.0</span><span class="p">,</span>
        <span class="n">f</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">theta</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">epsilon_B</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">epsilon_E</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">gamma_min</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">gamma_max</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e6</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the magnetic field strength and emitting radius from a broken power-law SED.</span>

<span class="sd">        This function provides a **user-facing, unit-aware interface** for computing</span>
<span class="sd">        the physical properties of a synchrotron-emitting region whose radio spectrum</span>
<span class="sd">        exhibits a turnover due to synchrotron self-absorption (SSA). Internally, it</span>
<span class="sd">        wraps a low-level optimized routine that implements the analytic inversion</span>
<span class="sd">        described in :footcite:t:`demarchiRadioAnalysisSN2004C2022` (DM22).</span>

<span class="sd">        The function accepts scalar values, NumPy arrays, or Astropy ``Quantity`` objects</span>
<span class="sd">        and performs the necessary unit coercion, validation, and shape checking before</span>
<span class="sd">        dispatching to the optimized backend.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nu_brk : float, array-like, or astropy.units.Quantity</span>
<span class="sd">            The SSA break (turnover) frequency :math:`\nu_{\rm brk}` separating the</span>
<span class="sd">            optically thick and optically thin synchrotron regimes. Default units are GHz, but may</span>
<span class="sd">            be overridden by providing ``nu_brk`` as a :class:`astropy.units.Quantity` object. May be</span>
<span class="sd">            provided as either a scalar (for a single SED) or a 1-D array (for multiple SEDs).</span>

<span class="sd">        F_nu_brk : float, array-like, or astropy.units.Quantity</span>
<span class="sd">            The flux density :math:`F_{\nu_{\rm brk}}` at the break frequency. Default units</span>
<span class="sd">            are Jansky (Jy), but may be overridden by providing ``F_nu_brk`` as a</span>
<span class="sd">            :class:`astropy.units.Quantity` object. May be provided as either a scalar</span>
<span class="sd">            (for a single SED) or a 1-D array (for multiple SEDs). If provided as an array, shape</span>
<span class="sd">            must be compatible with that of ``nu_brk``.</span>

<span class="sd">        distance : float, array-like, or astropy.units.Quantity</span>
<span class="sd">            The (luminosity) distance to the source. By default, units are Megaparsecs (Mpc),</span>
<span class="sd">            but may be overridden by providing ``distance`` as a :class:`astropy.units.Quantity` object.</span>
<span class="sd">            May be provided as either a scalar (for a single SED) or a 1-D array (for multiple SEDs). If provided</span>
<span class="sd">            as an array, shape must be compatible with that of ``nu_brk``.</span>

<span class="sd">        p : float or array-like, optional</span>
<span class="sd">            The power-law index :math:`p` of the electron Lorentz factor distribution,</span>
<span class="sd">            defined by</span>

<span class="sd">            .. math::</span>

<span class="sd">                N(\Gamma)\, d\Gamma = K_e \Gamma^{-p}\, d\Gamma.</span>

<span class="sd">            Default is ``3.0``.</span>

<span class="sd">            .. warning::</span>

<span class="sd">                This function **does not support** the case :math:`p = 2`, for which</span>
<span class="sd">                the electron energy integral is logarithmically divergent and requires</span>
<span class="sd">                a separate analytic treatment. If any value of ``p`` is exactly equal</span>
<span class="sd">                to 2, a ``ValueError`` is raised.</span>

<span class="sd">        f : float or array-like, optional</span>
<span class="sd">            Volume filling factor of the synchrotron-emitting region. Default is ``0.5``.</span>

<span class="sd">        theta : float or array-like, optional</span>
<span class="sd">            Pitch angle :math:`\theta` between the magnetic field and the electron</span>
<span class="sd">            velocity, in radians. Default is ``\pi/2`` (isotropic average).</span>

<span class="sd">        epsilon_B : float or array-like, optional</span>
<span class="sd">            Fraction of post-shock internal energy in magnetic fields,</span>
<span class="sd">            :math:`\epsilon_B`. Default is ``0.1``.</span>

<span class="sd">        epsilon_E : float or array-like, optional</span>
<span class="sd">            Fraction of post-shock internal energy in relativistic electrons,</span>
<span class="sd">            :math:`\epsilon_E`. Default is ``0.1``.</span>

<span class="sd">        gamma_min : float or array-like, optional</span>
<span class="sd">            Minimum electron Lorentz factor :math:`\gamma_{\rm min}`. Default is ``1``.</span>

<span class="sd">        gamma_max : float or array-like, optional</span>
<span class="sd">            Maximum electron Lorentz factor :math:`\gamma_{\rm max}`. Default is ``1e6``.</span>

<span class="sd">            This parameter only affects the calculation when :math:`p &lt; 2`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        B : astropy.units.Quantity</span>
<span class="sd">            The inferred magnetic field strength :math:`B` in **Gauss**.</span>

<span class="sd">        R : astropy.units.Quantity</span>
<span class="sd">            The inferred radius of the synchrotron-emitting region :math:`R`</span>
<span class="sd">            in **cm**.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function follows the formalism laid out in :footcite:t:`demarchiRadioAnalysisSN2004C2022` (DM22) to compute</span>
<span class="sd">        the magnetic field strength and radius of the synchrotron-emitting region from the observed break frequency and</span>
<span class="sd">        flux density of a broken power-law SED. The calculations assume a power-law distribution of electron energies</span>
<span class="sd">        characterized by the index :math:`p`.</span>

<span class="sd">        Letting :math:`\nu_{\rm brk}` be the break frequency (in GHz) between the SSA-thick and SSA-thin regimes, and</span>
<span class="sd">        :math:`F_{\nu_{\rm brk}}` be the flux density (in Jy) at that frequency, the magnetic field strength :math:`B`</span>
<span class="sd">        (in Gauss) and radius :math:`R` (in cm) of the emitting region can be computed</span>
<span class="sd">        by requiring that the asymptotic behavior of</span>
<span class="sd">        the optically thick and thin synchrotron spectra match at :math:`\nu_{\rm brk}`. The equations used are</span>
<span class="sd">        equations</span>
<span class="sd">        (16) and (17) from DM22 with minor alterations.</span>

<span class="sd">        In treating the electron energy distribution, some additional care is taken based on the value of :math:`p`. In</span>
<span class="sd">        particular, we assume a power-law distribution of electron Lorentz factors :math:`\Gamma` such that</span>

<span class="sd">        .. math::</span>

<span class="sd">            N(\Gamma) d\Gamma = K_e \Gamma^{-p} d\Gamma,\;\; \Gamma_{\rm min} \leq \Gamma \leq \Gamma_{\rm max},</span>

<span class="sd">        where :math:`K_e` is the normalization constant, :math:`\Gamma_{\rm min}` is the minimum Lorentz factor,</span>
<span class="sd">        and :math:`\Gamma_{\rm max}` is the maximum Lorentz factor. For values of :math:`p &gt; 2`, the total energy is</span>
<span class="sd">        dominated by electrons near :math:`\Gamma_{\rm min}`, while for :math:`p &lt; 2`, it is dominated by those near</span>
<span class="sd">        :math:`\Gamma_{\rm max}`.</span>

<span class="sd">        To account for this, when :math:`p &gt; 2`, we enforce :math:`\Gamma_{\rm max} = \infty` in the energy integral,</span>
<span class="sd">        while</span>
<span class="sd">        for :math:`p &lt; 2`, we enforce the upper limit on the energy integral to be :math:`\Gamma_{\rm max}`. This leads</span>
<span class="sd">        to</span>
<span class="sd">        a correction factor :math:`\delta` defined as:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \delta = \begin{cases} 1, &amp; p &gt; 2 \[6pt]</span>
<span class="sd">            \left(\frac{\Gamma_{\rm max}}{\Gamma_{\rm min}}\right)^{2 - p} - 1, &amp; p &lt; 2 \end{cases}</span>

<span class="sd">        which modifies the expressions for :math:`B` and :math:`R` accordingly.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>

<span class="sd">        .. footbibliography::</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Validate units of all unit bearing quantities and coerce them to the expected</span>
        <span class="c1"># units for the optimized backend.</span>
        <span class="n">nu_brk</span> <span class="o">=</span> <span class="n">ensure_in_units</span><span class="p">(</span><span class="n">nu_brk</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">GHz</span><span class="p">)</span>
        <span class="n">F_nu_brk</span> <span class="o">=</span> <span class="n">ensure_in_units</span><span class="p">(</span><span class="n">F_nu_brk</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Jy</span><span class="p">)</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="n">ensure_in_units</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Mpc</span><span class="p">)</span>

        <span class="c1"># Check the validity of p values. We need to ensure that ``p`` behaves as an array at</span>
        <span class="c1"># this point, so we cast it explicitly.</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;compute_BR_from_BPL does not support p = 2. &quot;</span>
                <span class="s2">&quot;Use p slightly above or below 2, or implement a dedicated &quot;</span>
                <span class="s2">&quot;logarithmic normalization for this case.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Dispatch to the optimized backend.</span>
        <span class="n">B</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_opt_from_params_to_physics</span><span class="p">(</span>
            <span class="n">nu_brk</span><span class="o">=</span><span class="n">nu_brk</span><span class="p">,</span>
            <span class="n">F_nu_brk</span><span class="o">=</span><span class="n">F_nu_brk</span><span class="p">,</span>
            <span class="n">distance</span><span class="o">=</span><span class="n">distance</span><span class="p">,</span>
            <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span>
            <span class="n">f</span><span class="o">=</span><span class="n">f</span><span class="p">,</span>
            <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span>
            <span class="n">epsilon_B</span><span class="o">=</span><span class="n">epsilon_B</span><span class="p">,</span>
            <span class="n">epsilon_E</span><span class="o">=</span><span class="n">epsilon_E</span><span class="p">,</span>
            <span class="n">gamma_min</span><span class="o">=</span><span class="n">gamma_min</span><span class="p">,</span>
            <span class="n">gamma_max</span><span class="o">=</span><span class="n">gamma_max</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">B</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">Gauss</span><span class="p">,</span> <span class="n">R</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">cm</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_opt_from_physics_to_params</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">B</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">R</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">distance</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">p</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">3.0</span><span class="p">,</span>
        <span class="n">f</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">theta</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">epsilon_B</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">epsilon_E</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">gamma_min</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">gamma_max</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e6</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the synchrotron self-absorption frequency and peak flux.</span>

<span class="sd">        This is a **low-level, performance-optimized routine** that assumes all</span>
<span class="sd">        inputs are provided as dimensionless scalars or NumPy arrays in CGS units.</span>
<span class="sd">        No unit validation or safety checks are performed.</span>

<span class="sd">        The function analytically eliminates the normalization of the electron</span>
<span class="sd">        energy distribution using microphysical energy-partition assumptions,</span>
<span class="sd">        introducing a correction factor ``delta`` to account for the convergence</span>
<span class="sd">        of the electron energy integral when :math:`p &lt; 2`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        B : float or array-like</span>
<span class="sd">            Magnetic field strength in Gauss.</span>

<span class="sd">        R : float or array-like</span>
<span class="sd">            Radius of the emitting region in cm.</span>

<span class="sd">        distance : float or array-like</span>
<span class="sd">            Distance to the source in cm.</span>

<span class="sd">        p, f, theta, epsilon_B, epsilon_E, gamma_min, gamma_max</span>
<span class="sd">            See the user-facing function ``compute_BPL_SED_from_BR``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nu_brk : float or array-like</span>
<span class="sd">            Synchrotron self-absorption break frequency (Hz-equivalent CGS).</span>

<span class="sd">        F_nu_brk : float or array-like</span>
<span class="sd">            Peak flux density at the break frequency (CGS-equivalent).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        See notes in the user-facing wrapper function `compute_BR_from_BPL` for details on the</span>
<span class="sd">        underlying physics and assumptions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Validate input parameters. We do NOT check explicitly for shape correctness of the arrays, instead opting</span>
        <span class="c1"># to allow an error to rise naturally if the shapes are incompatible during computation. We do want to ensure</span>
        <span class="c1"># that all of the constants are cast properly for array operations and masking.</span>
        <span class="n">p</span><span class="p">,</span> <span class="n">gamma_min</span><span class="p">,</span> <span class="n">gamma_max</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;f8&quot;</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">gamma_min</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;f8&quot;</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">gamma_max</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;f8&quot;</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="c1"># Obtain the synchrotron coefficients relevant for this scenario. We need c_1,c_5, and c_6.</span>
        <span class="n">c_5</span> <span class="o">=</span> <span class="n">compute_c5_parameter</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>  <span class="c1"># Should match shape of p.</span>
        <span class="n">c_6</span> <span class="o">=</span> <span class="n">compute_c6_parameter</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>  <span class="c1"># Should match shape of p.</span>
        <span class="n">c_1</span> <span class="o">=</span> <span class="n">c_1_cgs</span>  <span class="c1"># Scalar constant.</span>

        <span class="c1"># Construct the array for delta. See the documentation notes for details on the procedure here / physical</span>
        <span class="c1"># motivation. To do this efficiently, we pre-allocate the array and then fill in values based on the conditions.</span>
        <span class="c1"># Because we pre-allocate with ones, we only need to fill in values where p &lt; 2. In THIS IMPLEMENTATION, we</span>
        <span class="c1"># ignore</span>
        <span class="c1"># cases where p == 2 for efficiency; these should be screened for upstream if needed.</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">_p_lt_2_mask</span> <span class="o">=</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="mi">2</span>
        <span class="n">delta</span><span class="p">[</span><span class="n">_p_lt_2_mask</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">gamma_max</span><span class="p">[</span><span class="n">_p_lt_2_mask</span><span class="p">]</span> <span class="o">/</span> <span class="n">gamma_min</span><span class="p">[</span><span class="n">_p_lt_2_mask</span><span class="p">])</span> <span class="o">**</span> <span class="p">(</span>
            <span class="mi">2</span> <span class="o">-</span> <span class="n">p</span><span class="p">[</span><span class="n">_p_lt_2_mask</span><span class="p">]</span>
        <span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># Fill in values where p &lt; 2.</span>

        <span class="c1"># Construct the &quot;p_norm&quot; term used in the B and R calculations. This allows us to handle the two branches</span>
        <span class="c1"># of the solution (p &lt; 2 and p &gt; 2) in a unified way.</span>
        <span class="c1"># Note that we take the absolute value here to avoid issues with negative bases and fractional exponents.</span>
        <span class="c1"># The p == 2 case is handled upstream.</span>
        <span class="n">p_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mf">2.0</span><span class="p">)</span>

        <span class="c1"># Compute the electron energy floor using the gamma_min parameter and the standard formula.</span>
        <span class="n">E_l</span> <span class="o">=</span> <span class="n">electron_rest_energy_cgs</span> <span class="o">*</span> <span class="n">gamma_min</span>

        <span class="c1"># Calculate nu_brk. We break this into parts for clarity. See the notes on this function for an explanation of</span>
        <span class="c1"># where this formula comes from.</span>
        <span class="n">_nu_brk_coeff</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">c_1</span>
        <span class="n">_nu_brk_t1</span> <span class="o">=</span> <span class="n">R</span> <span class="o">*</span> <span class="n">f</span> <span class="o">*</span> <span class="p">(</span><span class="n">epsilon_E</span> <span class="o">/</span> <span class="p">(</span><span class="n">delta</span> <span class="o">*</span> <span class="n">epsilon_B</span><span class="p">))</span> <span class="o">*</span> <span class="n">p_norm</span> <span class="o">/</span> <span class="p">(</span><span class="mi">6</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="n">_nu_brk_t2</span> <span class="o">=</span> <span class="n">c_6</span> <span class="o">**</span> <span class="p">(</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">4</span><span class="p">))</span>
        <span class="n">_nu_brk_t3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">**</span> <span class="p">((</span><span class="n">p</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">4</span><span class="p">))</span>
        <span class="n">_nu_brk_E_l_exp</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span>
        <span class="n">_nu_brk_B_exp</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">6</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span>

        <span class="n">nu_brk</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">_nu_brk_coeff</span>
            <span class="o">*</span> <span class="p">(</span><span class="n">_nu_brk_t1</span> <span class="o">**</span> <span class="p">(</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)))</span>
            <span class="o">*</span> <span class="p">(</span><span class="n">E_l</span><span class="o">**</span><span class="n">_nu_brk_E_l_exp</span><span class="p">)</span>
            <span class="o">*</span> <span class="p">(</span><span class="n">B</span><span class="o">**</span><span class="n">_nu_brk_B_exp</span><span class="p">)</span>
            <span class="o">*</span> <span class="n">_nu_brk_t2</span>
            <span class="o">*</span> <span class="n">_nu_brk_t3</span>
        <span class="p">)</span>

        <span class="c1"># Calculate F_nu_brk by inserting nu_brk into either the optically thick or thin formula.</span>
        <span class="c1"># We choose the optically thick formula here (equation 14 of DeMarchi+22) for consistency.</span>
        <span class="n">_F_nu_brk_coeff</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_5</span> <span class="o">/</span> <span class="n">c_6</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">R</span> <span class="o">/</span> <span class="n">distance</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">_F_nu_brk_t1</span> <span class="o">=</span> <span class="p">(</span><span class="n">B</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">_F_nu_brk_t2</span> <span class="o">=</span> <span class="p">(</span><span class="n">nu_brk</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">c_1</span><span class="p">))</span> <span class="o">**</span> <span class="p">(</span><span class="mi">5</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">F_nu_brk</span> <span class="o">=</span> <span class="n">_F_nu_brk_coeff</span> <span class="o">*</span> <span class="n">_F_nu_brk_t1</span> <span class="o">*</span> <span class="n">_F_nu_brk_t2</span>

        <span class="k">return</span> <span class="n">nu_brk</span><span class="p">,</span> <span class="n">F_nu_brk</span>

<div class="viewcode-block" id="SSA_SED_PowerLaw.from_physics_to_params">
<a class="viewcode-back" href="../../../_as_gen/radiation.synchrotron.SEDs.SSA_SED_PowerLaw.from_physics_to_params.html#radiation.synchrotron.SEDs.SSA_SED_PowerLaw.from_physics_to_params">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_physics_to_params</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">B</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">],</span>
        <span class="n">R</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">],</span>
        <span class="n">distance</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">p</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">3.0</span><span class="p">,</span>
        <span class="n">f</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">theta</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">epsilon_B</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">epsilon_E</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">gamma_min</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">gamma_max</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e6</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the synchrotron self-absorption break frequency and peak flux.</span>

<span class="sd">        This is a **low-level, performance-optimized routine** that assumes all</span>
<span class="sd">        inputs are provided as dimensionless scalars or NumPy arrays in CGS units.</span>
<span class="sd">        No unit validation or safety checks are performed.</span>

<span class="sd">        The function analytically eliminates the normalization of the electron</span>
<span class="sd">        energy distribution using microphysical energy-partition assumptions,</span>
<span class="sd">        introducing a correction factor ``delta`` to account for the convergence</span>
<span class="sd">        of the electron energy integral when :math:`p &lt; 2`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        B : float or array-like</span>
<span class="sd">            Magnetic field strength in Gauss.</span>

<span class="sd">        R : float or array-like</span>
<span class="sd">            Radius of the emitting region in cm.</span>

<span class="sd">        distance : float or array-like</span>
<span class="sd">            Distance to the source in Mpc.</span>

<span class="sd">        p, f, theta, epsilon_B, epsilon_E, gamma_min, gamma_max</span>
<span class="sd">            See the user-facing function ``compute_BPL_SED_from_BR``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nu_brk : float or array-like</span>
<span class="sd">            Synchrotron self-absorption break frequency (Hz-equivalent CGS).</span>

<span class="sd">        F_nu_brk : float or array-like</span>
<span class="sd">            Peak flux density at the break frequency (CGS-equivalent).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        In the optically thick regime, the synchrotron SED follows a power law</span>

<span class="sd">        .. math::</span>

<span class="sd">            F_\nu = \frac{c_5}{c_6} \left(B\sin\theta\right)^{-1/2} \left(\frac{\nu}{2c_1}\right)^{5/2}</span>
<span class="sd">            \frac{\pi R^2}{d^2}.</span>

<span class="sd">        In the optically thin regime, the SED follows a different power law:</span>

<span class="sd">        .. math::</span>

<span class="sd">            F_\nu = \frac{4\pi f R^3}{3 d^2} c_5 N_0 \left(B\sin \theta\right)^{(p+1)/2}</span>
<span class="sd">            \left(\frac{\nu}{2c_1}\right)^{-(p-1)/2}.</span>

<span class="sd">        We define the break frequency :math:`\nu_{\rm brk}` as the frequency where these two power laws intersect and</span>
<span class="sd">        the</span>
<span class="sd">        corresponding peak flux density :math:`F_{\nu_{\rm brk}}`. By equating the two expressions for :math:`F_\nu` at</span>
<span class="sd">        :math:`\nu = \nu_{\rm brk}`, we can solve for :math:`\nu_{\rm brk}` and :math:`F_{\nu_{\rm brk}}` in terms of</span>
<span class="sd">        the physical parameters :math:`B`, :math:`R`, and :math:`d`.</span>

<span class="sd">        Equation these two equations yields</span>

<span class="sd">        .. math::</span>

<span class="sd">            \nu_{\rm brk} = 2 c_1 \left[\frac{4}{3} c_6 f N_0\right]^{2/(p+4)} R^{2/(p+4)}</span>
<span class="sd">            \left(B\sin\theta\right)^{(p+2)/(p+4)}</span>

<span class="sd">        Inserting :math:`\nu_{\rm brk}` back into either expression for :math:`F_\nu` gives the peak flux density</span>
<span class="sd">        :math:`F_{\nu_{\rm brk}}`.</span>

<span class="sd">        The normalization :math:`N_0` of the electron distribution is eliminated</span>
<span class="sd">        analytically by equating the total electron energy density to a fraction</span>
<span class="sd">        :math:`\epsilon_E` of the post-shock internal energy density, with magnetic</span>
<span class="sd">        energy fraction :math:`\epsilon_B`.</span>

<span class="sd">        For :math:`p \neq 2`, this introduces a correction factor</span>

<span class="sd">        .. math::</span>

<span class="sd">            \delta =</span>
<span class="sd">            \begin{cases}</span>
<span class="sd">            1, &amp; p &gt; 2 \</span>
<span class="sd">            (\gamma_{\max}/\gamma_{\min})^{2-p} - 1, &amp; p &lt; 2</span>
<span class="sd">            \end{cases}</span>

<span class="sd">        which accounts for the convergence properties of the electron energy integral.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Validate units of all unit bearing quantities and coerce them to the expected</span>
        <span class="c1"># units for the optimized backend.</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="s2">&quot;units&quot;</span><span class="p">):</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">Gauss</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="s2">&quot;units&quot;</span><span class="p">):</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">cm</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="s2">&quot;units&quot;</span><span class="p">):</span>
            <span class="n">distance</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">cm</span><span class="p">)</span>

        <span class="c1"># Check the validity of p values. We need to ensure that ``p`` behaves as an array at</span>
        <span class="c1"># this point, so we cast it explicitly.</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;compute_BR_from_BPL does not support p = 2. &quot;</span>
                <span class="s2">&quot;Use p slightly above or below 2, or implement a dedicated &quot;</span>
                <span class="s2">&quot;logarithmic normalization for this case.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Dispatch to the optimized backend.</span>
        <span class="n">nu</span><span class="p">,</span> <span class="n">F_nu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_opt_from_physics_to_params</span><span class="p">(</span>
            <span class="n">B</span><span class="o">=</span><span class="n">B</span><span class="p">,</span>
            <span class="n">R</span><span class="o">=</span><span class="n">R</span><span class="p">,</span>
            <span class="n">distance</span><span class="o">=</span><span class="n">distance</span><span class="p">,</span>
            <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span>
            <span class="n">f</span><span class="o">=</span><span class="n">f</span><span class="p">,</span>
            <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span>
            <span class="n">epsilon_B</span><span class="o">=</span><span class="n">epsilon_B</span><span class="p">,</span>
            <span class="n">epsilon_E</span><span class="o">=</span><span class="n">epsilon_E</span><span class="p">,</span>
            <span class="n">gamma_min</span><span class="o">=</span><span class="n">gamma_min</span><span class="p">,</span>
            <span class="n">gamma_max</span><span class="o">=</span><span class="n">gamma_max</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">nu</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">Hz</span><span class="p">,</span> <span class="n">F_nu</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">erg</span> <span class="o">/</span> <span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">s</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">cm</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">Hz</span><span class="p">)</span></div>
</div>

</pre></div>

                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright 2025, Eliza Diggins.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 9.0.4.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  <!-- # L10n: Setting the PST URL as an argument as this does not need to be localized -->
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.1.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>